<?php
/**
 * @file
 * The FolderShare REST command-line client.
 *
 * Use "foldershare --help" for help.
 *
 * DO NOT EDIT THIS FILE!
 *
 * This file has been built automatically by concatenating a set of API source
 * files in order to create a single stand-alone application. If you need to
 * modify this application, you should edit the source files instead, then
 * re-concatenate them into a new application.
 *
 * This file contains the following source files:
 *   FolderShareConnect.php
 *   FolderShareFormat.php
 *   FolderShareCommands.php
 *   Main.php
 *
 * Built on: Fri Feb 28 12:12:31 PST 2020
 */



/**
 * Manages communications with a web site using the FolderShare Drupal module.
 *
 * This class handles client-server communications for client applications
 * communicating with a remote server running the Drupal content management
 * system and the FolderShare module. Drupal manages the content and provides
 * a general-purpose web services (i.e. "REST") interface. FolderShare
 * supports that interface in its management of a hierarchy of files and
 * folders stored on the server.
 *
 * This class's methods configure the client-server communications path,
 * then use that path to send requests to the server and handle responses
 * back from the server. The requests supported here include:
 *
 * - Create folders.
 * - Upload files and folders.
 * - Download files and folders.
 * - Get lists of files and folders.
 * - Search files and folders.
 * - Get file and folder names and other descriptive values.
 * - Rename and edit file and folder description values.
 * - Copy and move files and folders.
 * - Delete files and folders.
 * - Get FolderShare settings.
 * - Get web site settings related to these services.
 *
 * <B>Web server setup</B><BR>
 * In order for this class to communicate with a web server, the following
 * must have been configured by the site administrator on that server:
 *
 * - The site must be running the Drupal content management system.
 *
 * - The FolderShare module for Drupal must be installed.
 *
 * - The Drupal REST services module must be installed.
 *
 * - The FolderShare REST module for Drupal must be installed.
 *
 * - The FolderShare resource for REST must be enabled and configured to
 *   enable:
 *   - GET, POST, PATCH, and DELETE methods.
 *   - The JSON serialization format.
 *   - An authentication service (such as the default cookie authentication).
 *
 * Applications may use this class to open a connection to a web server,
 * authenticate the user across that connection, then issue
 * one or more requests on the connection. The connection is automatically
 * closed when the connection object is deleted.
 *
 * <B>Return formats</B><BR>
 * Many requests can return information to the client in one of these formats:
 *
 * - 'full' returns a complex serialized entity or list of entities as an
 *   associative array of fields that each containing an array of values,
 *   which may in turn include on or more named values that may be scalars
 *   or further arrays. This structure matches the layout of data on the
 *   server and it is suitable for re-use in a future call to create or
 *   update a file or folder. However, it is not very user-friendly.
 *
 * - 'keyvalue' returns a simply serialized entity as an associative array
 *   of field names that each contain either a scalar value or an array of
 *   scalar values. The key-value array is easier to process by client
 *   code and it can be converted to a user-friendly output.
 */
class FolderShareConnect {

  /*--------------------------------------------------------------------
   *
   * Version.
   *
   *--------------------------------------------------------------------*/

  /**
   * The version number of this class.
   *
   * @var string
   */
  const VERSION = '1.1.0 (February 2020)';

  /**
   * The minimum supported protocol version.
   *
   * @var float
   */
  const MINIMUM_PROTOCOL_VERSION = 1.1;

  /*--------------------------------------------------------------------
   *
   * Authentication constants.
   *
   *--------------------------------------------------------------------*/

  /**
   * A connection authentication type that does no authentication.
   *
   * This value is a default until a specific authentication style has
   * been set up.  However, web sites will only allow anonymous use
   * without authentication.
   *
   * @var string
   * @see ::getAuthenticationType()
   * @see ::getAuthenticationTypeName()
   * @see ::login()
   */
  const AUTHENTICATION_NONE = '';

  /**
   * A basic authentication type that uses a user name and password.
   *
   * Drupal core supports basic authentication, and it is this style that
   * is used for some web services. With basic authentication, the caller of
   * this class provides a user name and password that are included on every
   * request to the server. This requires that the server re-authenticate
   * on every request, which is a high overhead when client-server
   * communications requires multiple requests to accomplish a task (which
   * is the case for FolderShare REST access). For this reason, this
   * authentication type is not recommended.
   *
   * Basic authentication can fail if the user name and password
   * are invalid.
   *
   * When a connection uses SSL encryption, the user name and password
   * are included in the encrypted content so they cannot be seen by
   * intermediate parties.
   *
   * @var string
   * @see ::getAuthenticationType()
   * @see ::getAuthenticationTypeName()
   * @see ::getPassword()
   * @see ::getUserName()
   * @see ::login()
   */
  const AUTHENTICATION_BASIC = 'basic_auth';

  /**
   * A cookie authentication type that uses a session cookie.
   *
   * Drupal core supports cookie authentication, and it is this style
   * that is used by web browsers. With cookie authentication, the
   * caller of this class provides a user name and password that are
   * used for an initial connection to the server. The server returns
   * a session cookie and that cookie is used for further requests.
   *
   * Cookie authentication can fail if the session cookie cannot be
   * obtained. This can happen if the server has been configured to use a
   * non-standard user login form, such as one that requires a CAPTCHA.
   *
   * Cookie authentication can also fail if the user name and password
   * are invalid.
   *
   * When a connection uses SSL encryption, the user name and password
   * are included in the encrypted content so they cannot be seen by
   * intermediate parties.
   *
   * @var string
   * @see ::getAuthenticationType()
   * @see ::getAuthenticationTypeName()
   * @see ::getPassword()
   * @see ::getUserName()
   * @see ::login()
   */
  const AUTHENTICATION_COOKIE = 'cookie';

  /**
   * The preference order for authentication types.
   *
   * When a server supports multiple authentication types, this order
   * specifies a preference. An authentication type earlier in the list
   * is preferred over one later in the list.
   *
   * @var array
   * @see ::verifyServer()
   * @see ::getAuthenticationType()
   * @see ::getAuthenticationTypeName()
   * @see ::getPassword()
   * @see ::getUserName()
   * @see ::login()
   */
  const AUTHENTICATION_PREFERENCE_ORDER = [
    self::AUTHENTICATION_COOKIE,
    // TODO As of 2/1/2019, the basic_auth module does not appear to be
    // working properly, or there is something wrong here in how we parse
    // results.
    self::AUTHENTICATION_BASIC,
  ];

  /**
   * A flag for an unspecified serialization format.
   *
   * This flag is used when the serialization format is not yet known,
   * prior to server verification.
   *
   * This is not a valid serialization format for actual use.
   *
   * @var string
   * @see ::verifyServer()
   * @see ::getSerializationFormat()
   * @see ::getSerializationFormatName()
   */
  const SERIALIZATION_NONE = '';

  /**
   * The JSON serialization format.
   *
   * When the server connection is first verified, a list of supported
   * serialization formats is queried from the server. One of those is
   * selected for all further communications.
   *
   * The JSON format serializes entities as JSON objects and arrays.
   *
   * @var string
   * @see ::verifyServer()
   * @see ::getSerializationFormat()
   * @see ::getSerializationFormatName()
   */
  const SERIALIZATION_JSON = 'json';

  /**
   * The JSON + HAL serialization format.
   *
   * When the server connection is first verified, a list of supported
   * serialization formats is queried from the server. One of those is
   * selected for all further communications.
   *
   * The JSONHAL format serializes entities as JSON objects and arrays,
   * and may append linkage information.
   *
   * @see ::verifyServer()
   * @see ::getSerializationFormat()
   * @see ::getSerializationFormatName()
   */
  const SERIALIZATION_JSONHAL = 'hal_json';

  /**
   * The preference order for serialization formats.
   *
   * When a server supports multiple serialization formats, this order
   * specifies a preference. A format earlier in the list is preferred over
   * one later in the list.
   *
   * @var array
   * @see ::verifyServer()
   * @see ::getSerializationFormat()
   * @see ::getSerializationFormatName()
   */
  const SERIALIZATION_PREFERENCE_ORDER = [
    self::SERIALIZATION_JSON,
    self::SERIALIZATION_JSONHAL,
  ];

  /*--------------------------------------------------------------------
   *
   * Login state constants.
   *
   *--------------------------------------------------------------------*/

  /**
   * An authentication status indicating the user is not logged in.
   *
   * This is the state for the connection before a login is performed,
   * or when there is no user name and all accesses will be anonymous.
   *
   * @var int
   * @see ::login()
   */
  const STATUS_NOT_LOGGED_IN = 0;

  /**
   * An authentication status indicating user login failed.
   *
   * This state indicates that login credentials were set and tried, but
   * failed.
   *
   * @var int
   * @see ::login()
   */
  const STATUS_FAILED = (-1);

  /**
   * An authentication status indicating the user is logged in.
   *
   * This state indicates that authentication was performed successfully.
   *
   * @var int
   * @see ::login()
   */
  const STATUS_LOGGED_IN = 1;

  /*--------------------------------------------------------------------
   *
   * CURL constants.
   *
   *--------------------------------------------------------------------*/

  /**
   * The default HTTP connect timeout, in seconds.
   *
   * The default timeout is long enough to connect to a server, even
   * when it is busy. The CURL default is 300 seconds. A 0 causes CURL
   * to use this default.
   *
   * @var int
   */
  const DEFAULT_CURL_CONNECT_TIMEOUT = 0;

  /**
   * The default HTTP request timeout, in seconds.
   *
   * The default timeout is long enough for most GET, PATCH, and DELETE
   * requests, even when the server is busy. The CURL default is 0, which
   * disables the timeout and waits indefinitely. This is probably not a
   * good idea, so a non-zero timeout is preferred here.
   *
   * @var int
   */
  const DEFAULT_CURL_TIMEOUT = 120;

  /*--------------------------------------------------------------------
   *
   * Upload and download flags.
   *
   *--------------------------------------------------------------------*/

  /**
   * A bitmask indicating a download should overwrite local files.
   *
   * @var int
   */
  const DOWNLOAD_OVERWRITE = (1<<0);

  /**
   * A bitmask indicating a download should update local files.
   *
   * Files are downloaded if there is no local file, or if the remote file
   * is newer than the local file.
   *
   * @var int
   */
  const DOWNLOAD_UPDATE = (1<<1);

  /**
   * A bitmask indicating a download should preserve timestamps.
   *
   * @var int
   */
  const DOWNLOAD_PRESERVE = (1<<2);

  /**
   * A bitmask indicating an upload should overwrite remote files.
   *
   * @var int
   */
  const UPLOAD_OVERWRITE = (1<<0);

  /**
   * A bitmask indicating a upload should update remote files.
   *
   * Files are upload if there is no remote file, or if the local file
   * is newer than the remote file.
   *
   * @var int
   */
  const UPLOAD_UPDATE = (1<<1);

  /**
   * A bitmask indicating a upload should preserve timestamps.
   *
   * @var int
   */
  const UPLOAD_PRESERVE = (1<<2);

  /*--------------------------------------------------------------------
   *
   * URL constants.
   *
   *--------------------------------------------------------------------*/

  /**
   * The URL path for requesting a CSRF token.
   *
   * The path only contains the string following the scheme, domain, and
   * optional port on a URL (e.g. for "http://example:80/stuff", only
   * include "stuff").
   *
   * This path is defined within Drupal core's REST services module and
   * cannot be changed.
   */
  const URL_CSRF_TOKEN = '/session/token';

  /**
   * The URL path for logging in using cookie authentication.
   *
   * This path is defined within Drupal core's User module and cannot
   * be changed.
   */
  const URL_USER_LOGIN = '/user/login';

  /**
   * The URL path for logging out using cookie authentication.
   *
   * This path is defined within Drupal core's User module and cannot
   * be changed.
   */
  const URL_USER_LOGOUT = '/user/logout';

  /**
   * The URL path for an HTTP GET request.
   *
   * The path only contains the string following the scheme, domain, and
   * optional port on a URL (e.g. for "http://example:80/stuff", only
   * include "stuff"). An entity ID and format query will be added.
   *
   * This path is defined within the FolderShare resource for REST and
   * cannot be changed.
   */
  const URL_GET = '/foldershare';

  /**
   * The URL path for an HTTP DELETE request.
   *
   * The path only contains the string following the scheme, domain, and
   * optional port on a URL (e.g. for "http://example:80/stuff", only
   * include "stuff"). There is no entity ID for this path.
   *
   * This path is defined within the FolderShare resource for REST and
   * cannot be changed.
   */
  const URL_DELETE = '/entity/foldershare';

  /**
   * The URL path for an HTTP PATCH request.
   *
   * The path only contains the string following the scheme, domain, and
   * optional port on a URL (e.g. for "http://example:80/stuff", only
   * include "stuff"). An entity ID and format query will be added.
   *
   * This path is defined within the FolderShare resource for REST and
   * cannot be changed.
   */
  const URL_PATCH = '/entity/foldershare';

  /**
   * The URL path for an HTTP POST request.
   *
   * The path only contains the string following the scheme, domain, and
   * optional port on a URL (e.g. for "http://example:80/stuff", only
   * include "stuff").
   *
   * This path is defined within the FolderShare resource for REST and
   * cannot be changed.
   */
  const URL_POST = '/entity/foldershare';

  /**
   * The URL path for an HTTP POST request to upload a file or folder.
   *
   * The path leads to an upload form instead of to the REST resource
   * because the REST module currently does not support base class
   * features needed for file upload.
   *
   * This path is defined within the FolderShare module and cannot be
   * changed.
   */
  const URL_UPLOAD = '/foldershare/upload';

  /*--------------------------------------------------------------------
   *
   * Progress states.
   *
   *--------------------------------------------------------------------*/

  /**
   * The indicator that progress reporting is about to start.
   *
   * @var int
   * @see ::isProgress()
   * @see ::setProgress()
   * @see ::download()
   * @see ::upload()
   */
  const PROGRESS_START = 0;

  /**
   * The indicator that progress reporting is continuing.
   *
   * @var int
   * @see ::isProgress()
   * @see ::setProgress()
   * @see ::download()
   * @see ::upload()
   */
  const PROGRESS_CONTINUE = 1;

  /**
   * The indicator that progress reporting has finished.
   *
   * @var int
   * @see ::isProgress()
   * @see ::setProgress()
   * @see ::download()
   * @see ::upload()
   */
  const PROGRESS_END = 2;

  /*--------------------------------------------------------------------
   *
   * Comment error messages.
   *
   *--------------------------------------------------------------------*/

  const ERROR_EMPTY_REMOTE_NAME =
    "Missing remote item name.";
  const ERROR_EMPTY_REMOTE_FOLDER_NAME =
    "Missing remote folder name.";
  const ERROR_EMPTY_REMOTE_PATH =
    "Empty remote file or folder path.";
  const ERROR_EMPTY_LOCAL_PATH =
    "Empty local file or folder path.";
  const ERROR_EMPTY_REMOTE_DESTINATION_PATH =
    "Empty remote destination file or folder path.";
  const ERROR_EMPTY_REMOTE_USER =
    "Missing remote user name or ID.";

  /*--------------------------------------------------------------------
   *
   * Fields - flags.
   *
   *--------------------------------------------------------------------*/

  /**
   * When TRUE, this class writes status messages to STDERR.
   *
   * @var string
   * @see ::isVerbose()
   * @see ::setVerbose()
   */
  protected $verbose;

  /**
   * When TRUE, this class writes progress messages to STDERR.
   *
   * Progress is only reported on upload and download.
   *
   * @var string
   * @see ::isProgress()
   * @see ::setProgress()
   * @see ::upload()
   * @see ::download()
   */
  protected $progress;

  /**
   * The current progress state.
   *
   * @var int
   * @see ::PROGRESS_START
   * @see ::PROGRESS_CONTINUE
   * @see ::PROGRESS_END
   */
  protected $progressState;

  /**
   * The current progress largest target size during a current transfer.
   *
   * This value is initialized to zero on PROGRESS_START.
   *
   * @var int
   */
  protected $progressHighestTarget;

  /**
   * The most recently output progress percentage.
   *
   * This value is initialized to zero on PROGRESS_START.
   *
   * @var int
   */
  protected $progressPercentage;

  /*--------------------------------------------------------------------
   *
   * Fields - user-provided parameters.
   *
   *--------------------------------------------------------------------*/

  /**
   * A flag indicating if the host name is a name, an IPv4 address, or
   * an IPv6 address.
   *
   * The value is one of:
   * - 'hostname'.
   * - 'ipv4'.
   * - 'ipv6';
   *
   * @var string
   * @see ::getHostName()
   * @see ::getHostNameStyle()
   * @see ::getHostNameAndPortNumber()
   * @see ::setHostName()
   */
  protected $hostNameStyle = 'hostname';

  /**
   * The host name or IP address for the web site.
   *
   * The host name is used to build a URL to a Drupal site. During use,
   * the URL will have Drupal routes added that lead to specific REST
   * resources.
   *
   * @var string
   * @see ::getHostName()
   * @see ::getHostNameStyle()
   * @see ::setHostName()
   */
  protected $hostName = '';

  /**
   * The port number for the web site.
   *
   * The host name and port are used to build a URL to a Drupal site.
   * During use, the URL will have Drupal routes added that lead to specific
   * REST resources.
   *
   * @var int
   * @see ::getPortNumber()
   * @see ::setPortNumber()
   * @see ::setHostName()
   */
  protected $portNumber = (-1);

  /**
   * The user name if using basic or cookie authentication.
   *
   * When using basic authentication, the user name and password are
   * sent on every request to the server. When using cookie authentication,
   * the user name and password are only sent on an initial login request,
   * which returns a session cookie used for all further requests.
   *
   * If the user name is empty, access falls back to anonymous access.
   * GET operations that query site configurations will always work
   * anonymously. GET, POST, PATCH, and DELETE operations that apply to
   * entities may fail depending upon how site permissions are set for
   * anonymous access.
   *
   * @var string
   * @see ::getUserName()
   * @see ::setUserNameAndPassword()
   */
  protected $userName;

  /**
   * The user password if using basic or cookie authentication.
   *
   * When using basic authentication, the user name and password are
   * sent on every request to the server. When using cookie authentication,
   * the user name and password are only sent on an initial login request,
   * which returns a session cookie used for all further requests.
   *
   * If the password is empty, the account has no password. This is rare
   * except for the anonymous account.
   *
   * @var string
   * @see ::getPassword()
   * @see ::setUserNameAndPassword()
   */
  protected $password;

  /**
   * The current preferred format for content returned by the server.
   *
   * Some requests to the server return content, such as the list of fields
   * in a FolderShare entity (a file or folder). The format of that
   * returned content can vary depending upon the selected return format:
   * - 'full' = returns a full detailed entity or list of entities.
   * - 'keyvalue' = returns a simplified entity or list of entities.
   *
   * @var string
   * @see ::setReturnFormat()
   * @see ::getReturnFormat()
   */
  protected $format;

  /*--------------------------------------------------------------------
   *
   * Fields - server characteristics.
   *
   *--------------------------------------------------------------------*/

  /**
   * The CURL session handle after it has been initialized.
   *
   * The session handle is created when an object of this class is
   * constructed, and released when the object is destroyed.
   *
   * The CURL session object is used for all communications with the server.
   *
   * @var resource
   */
  protected $curlSession;

  /**
   * A flag indicating that server communications has been validated.
   *
   * This flag is initialized to FALSE when an object of this class is
   * constructed, and it is reset to FALSE any time the host name is
   * changed. The flag is set to TRUE by verifyServer(), which issues
   * intial communications to the server before the caller of this class
   * makes their first request. If verification fails, no further server
   * communications can be done. This may occur if the host name or port
   * are bad.
   *
   * @var bool
   * @see ::verifyServer()
   */
  protected $serverVerified;

  /**
   * The list of HTTP verbs supported by the remote site.
   *
   * The string array is changed from empty to a list of the names of
   * supported HTTP verbs when the server connection is verified on the
   * first request. HTTP verbs are always in upper case and are one of the
   * following values:
   * - GET.
   * - DELETE.
   * - PATCH.
   * - POST.
   *
   * This list of supported HTTP verbs is checked on each call to this
   * class before trying to send the request. If the verb is not supported,
   * the request is aborted.
   *
   * Typically, servers support all of the above HTTP verbs.
   *
   * @var string[]
   * @see ::verifyServer()
   * @see ::getHttpVerbs()
   */
  protected $httpVerbs;

  /**
   * The list of serialization and authentication choices supported by the site.
   *
   * This associative array is indexed by HTTP verb (e.g. "GET", "POST", etc.).
   * Each array entry has two children named "serializer-formats" and
   * "authentication-providers". Each of these are an array of strings that
   * name the specific serializers and authentication providers supported by
   * the site.
   *
   * This list is initialized when the server connection is verified. It is
   * to guide authentication and the serialization format used for
   * communicating entities.
   *
   * @var array
   * @see ::verifyServer()
   * @see ::getServerConfiguration()
   */
  protected $httpConfiguration;

  /*--------------------------------------------------------------------
   *
   * Fields - communications.
   *
   *--------------------------------------------------------------------*/

  /**
   * The CSRF token, or NULL if empty.
   *
   * The "Cross-Site-Request-Forgery" (CSRF) token is retrieved from
   * the server on the first request to the server. The token is then
   * attached to all further non-safe requests to the same server
   * (e.g. POST, PATCH, and DELETE, but not for GET).
   *
   * @var string
   * @see ::clearCsrfToken()
   * @see ::getCsrfToken()
   */
  protected $csrfToken;

  /**
   * The logout token when using cookies.
   *
   * @var string
   */
  protected $cookieLogoutToken;

  /**
   * The authentication type.
   *
   * This is one of AUTHENTICATION_NONE, AUTHENTICATION_BASIC, or
   * AUTHENTICATION_COOKIE.
   *
   * @var int
   * @see ::getUserName()
   * @see ::getPassword()
   * @see ::getAuthenticationType()
   * @see ::setUserNameAndPassword()
   */
  protected $authenticationType;

  /**
   * Whether the user's credentials have been authenticated (logged in).
   *
   * @var int
   * @see ::STATUS_NOT_LOGGED_IN
   * @see ::STATUS_FAILED
   * @see ::STATUS_LOGGED_IN
   */
  protected $authenticationStatus;

  /**
   * The chosen serialization format.
   *
   * This is one of the formats in $httpConfiguration, which lists all
   * serialization formats supported by the site. This cannot be empty
   * and is always one of SERIALIZATION_NONE, SERIALIZATION_JSON, or
   * SERIALIZATION_JSONHAL.
   *
   * @var string
   * @see ::SERIALIZATION_NONE
   * @see ::SERIALIZATION_JSON
   * @see ::SERIALIZATION_JSONHAL
   * @see ::getServerConfiguration()
   * @see ::getSerializationFormat()
   * @see ::verifyServer()
   */
  protected $serializationFormat;

  /**
   * The most recent download path.
   *
   * During a file download from the server, the intended local destination
   * is stored here for use by progress reporting.
   *
   * @var string
   * @see ::download()
   * @see ::downloadFile()
   * @see ::downloadProgressCallback()
   */
  private $downloadLocalPath;

  /**
   * The most recent upload path.
   *
   * During a file upload to the server, the source local path is stored here
   * for use by progress reporting.
   *
   * @var string
   * @see ::httpPost()
   * @see ::upload()
   * @see ::uploadProgressCallback()
   */
  private $uploadLocalPath;

  /*--------------------------------------------------------------------
   *
   * Construction & Destruction.
   *
   *--------------------------------------------------------------------*/

  /**
   * Creates a new connection ready to communicate to a remote host.
   *
   * Constructing an object of this class initializes internal state, but
   * does not open a connection to a server yet. The caller must set
   * the host name and, if needed, the authentication credentials to use.
   * Thereafter, methods that request data from the server open the
   * connection and send and receive the appropriate data.
   *
   * @see ::setHostName()
   * @see ::setUserNameAndPassword()
   */
  public function __construct() {
    if (phpversion('curl') === FALSE) {
      throw new \RuntimeException(
        "The required PHP CURL package is not installed.");
    }

    $this->authenticationType   = self::AUTHENTICATION_NONE;
    $this->authenticationStatus = self::STATUS_NOT_LOGGED_IN;
    $this->serializationFormat  = self::SERIALIZATION_NONE;
    $this->userName             = '';
    $this->password             = '';
    $this->format               = 'full';
    $this->verbose              = FALSE;
    $this->progress             = FALSE;

    $this->clearCsrfToken();
    $this->unverifyServer();

    $this->curlSession = curl_init();
  }

  /**
   * Closes the connection to the remote server.
   *
   * If the user is logged in, they are logged out first.
   */
  public function __destruct() {
    $this->logout();
    curl_close($this->curlSession);
  }

  /*--------------------------------------------------------------------
   *
   * Verbosity.
   *
   *--------------------------------------------------------------------*/

  /**
   * Returns TRUE if the connection has been set to show progress.
   *
   * For file uploads and downloads, when progress is enabled messages
   * are written to STDERR as content is uploaded or downloaded.
   *
   * @return bool
   *   Returns TRUE if the connection is set to show progress.
   *
   * @see ::setProgress()
   */
  public function isProgress() {
    return $this->progress;
  }

  /**
   * Sets whether the connection should show progress.
   *
   * For file uploads and downloads, when progress is enabled messages
   * are written to STDERR as content is uploaded or downloaded.
   *
   * @param bool $verbose
   *   Sets the connection's progress setting to TRUE (show) or FALSE (not).
   *
   * @see ::isProgress()
   */
  public function setProgress(bool $progress) {
    $this->progress = $progress;
  }

  /**
   * Returns TRUE if the connection has been set to be verbose.
   *
   * When the connection is verbose, status messages are written to STDERR
   * for each operation. This is useful when debugging, but probably not
   * a feature users will enjoy.
   *
   * @return bool
   *   Returns TRUE if the connection is verbose.
   *
   * @see ::setVerbose()
   */
  public function isVerbose() {
    return $this->verbose;
  }

  /**
   * Sets whether the connection is verbose.
   *
   * When the connection is verbose, status messages are written to STDERR
   * for each operation. This is useful when debugging, but probably not
   * a feature users will enjoy.
   *
   * @param bool $verbose
   *   Sets the connection's verbosity to TRUE (verbose) or FALSE (not).
   *
   * @see ::isVerbose()
   */
  public function setVerbose(bool $verbose) {
    $this->verbose = $verbose;
  }

  /**
   * Prints a message to STDERR if verbosity is enabled.
   *
   * @param string $message
   *   The message to print if verbosity is enabled.
   */
  protected function printVerbose(string $message) {
    if ($this->verbose === TRUE && empty($message) === FALSE) {
      fwrite(STDERR, "FolderShareConnect: $message\n");
    }
  }

  /*--------------------------------------------------------------------
   *
   * Host.
   *
   *--------------------------------------------------------------------*/

  /**
   * Gets the name of the host for the connection.
   *
   * The port number, if specified, is not included.
   *
   * @return string
   *   The host name for the web site.
   *
   * @see ::getHostNameStyle()
   * @see ::getHostNameAndPortNumber()
   * @see ::getPortNumber()
   * @see ::setHostName()
   */
  public function getHostName() {
    return $this->hostName;
  }

  /**
   * Gets the host name style.
   *
   * The returned value is one of:
   * - 'hostname' for a name (e.g. example.com).
   * - 'ipv4' for an IPv4 address (e.g. 127.0.0.1).
   * - 'ipv6' for an IPv6 address (e.g. fe80::420:ff8d:2e5:759).
   *
   * @return string
   *   The host name style for the web site.
   *
   * @see ::getHostName()
   * @see ::setHostName()
   * @see ::getPortNumber()
   */
  public function getHostNameStyle() {
    return $this->hostNameStyle;
  }

  /**
   * Gets the host name and port number.
   *
   * The returned value depends upon the host name style and whether a
   * port number has been provided.
   *
   * - "example.com" if the style is "hostname", the host is "example.com",
   *   and no port number has been set.
   *
   * - "example.com:1234" if the style is "hostname", the host is "example.com",
   *   and the port number is "1234".
   *
   * - "127.0.0.1" if the style is "ipv4", the host is "127.0.0.1",
   *   and no port number has been set.
   *
   * - "127.0.0.1:1234" if the style is "ipv4", the host is "127.0.0.1",
   *   and the port number is "1234".
   *
   * - "[fe80::420:ff8d:2e5:759]" if the style is "ipv6", the host is
   *   "fe80::420:ff8d:2e5:759", and no port number has been set.
   *
   * - "[fe80::420:ff8d:2e5:759]:1234" if the style is "ipv6", the host is
   *   "fe80::420:ff8d:2e5:759", and the port number is "1234".
   *
   * The inclusion of square brackets around IPv6 addresses is per IETF
   * RFC 2732 on the format for literal IPv6 addresses in URLs.
   *
   * @return string
   *   The host name and port number for the web site.
   *
   * @see ::getHostName()
   * @see ::getHostNameStyle()
   * @see ::getPortNumber()
   */
  public function getHostNameAndPortNumber() {
    switch ($this->hostNameStyle) {
      case 'hostname':
      case 'ipv4':
        if ($this->portNumber === (-1)) {
          return $this->hostName;
        }
        return $this->hostName . ':' . $this->portNumber;

      case 'ipv6':
        if ($this->portNumber === (-1)) {
          return '[' . $this->hostName . ']';
        }
        return '[' . $this->hostName . ']:' . $this->portNumber;
    }
  }

  /**
   * Gets the port number of the host for the connection.
   *
   * A (-1) is returned if no port number has been set explicitly.
   *
   * @return int
   *   The port number for the web site.
   *
   * @see ::setHostNameAndPortNumber()
   * @see ::getPortNumber()
   */
  public function getPortNumber() {
    return $this->portNumber;
  }

  /**
   * Sets the host name and an optional port for the connection.
   *
   * The host name selects the site with which this connection communicates.
   * Host names may include a domain name (e.g. "example.com"), an IPv4
   * address, or an IPv6 address. IPv6 addresses may be surrounded by
   * square brackets, per IETF RFC 2732 on the literal format for IPv6
   * addresses in URLs.
   *
   * The host name may be followed by an optional colon and port number,
   * or the port number may be passed as a second argument to the method.
   * Port numbers be positive integers from 0 through 65535. If a port
   * number argument is given, it overrides any included at the end of
   * the host name. If no port is given, communications uses a default.
   *
   * Examples:
   * - "example.com" = a host name and default port.
   * - "example.com:80" = a host name and port.
   * - "127.0.0.1" = an IPv4 address and default port.
   * - "127.0.0.1:80" = an IPv4 address and port.
   * - "fe80::420:ff8d:2e5:759" = an IPv6 address and default port.
   * - "[fe80::420:ff8d:2e5:759]" = an IPv6 address and default port.
   * - "[fe80::420:ff8d:2e5:759]:80" = an IPv6 address and port.
   *
   * Setting the host name is normally done immediately after constructing
   * the connection and before issuing any requests. If the host name is
   * changed later, the user is logged out and the connection reset.
   *
   * @param string $hostName
   *   The host name for the web site.
   * @param string $portNumber
   *   (optional, default = '') The port number for the web site. If not
   *   given, the port number defaults to an optional port number included
   *   at the end of the host name. If that too is not given, the port number
   *   defaults to a standard port number.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the host name is malformed.
   *
   * @see ::getHostName()
   * @see ::getHostNameAndPortNumber()
   * @see ::getPortNumber()
   * @see ::logout()
   */
  public function setHostNameAndPortNumber(
    string $hostName,
    string $portNumber = '') {

    $validHostName = '';
    $validPortNumber = -1;
    $validHostNameStyle = 'hostname';
    $mustBeIPv6 = FALSE;

    // Try to split the host name into HOST and PORT.
    //
    // Start by looking for a bracketed IPv6 address. If that does not match,
    // look for a host name, IPv4, or IPv6 address, optionally followed by
    // a colon and port.
    $matches = [];
    if (mb_ereg('^\[([0-9a-fA-F:.]+)\](:([0-9]+))?$', $hostName, $matches) !== FALSE) {
      // The host name appears to be an IPv6 address in square brackets.
      // It may or may not have a port number.
      $mustBeIPv6 = TRUE;
      $server = $matches[1];
      if (empty($portNumber) === TRUE && count($matches) >= 4 && empty($matches[3]) === FALSE) {
        $port = $matches[3];
      }
      else {
        $port = $portNumber;
      }
    }
    else {
      // The host name is not an IPv6 address in square brackets. Use a :
      // as a separator to get components.
      $parts = mb_split(':', $hostName);

      switch (count($parts)) {
        case 1:
          // HOST or IPV4 with no PORT in host name.
          $server = $parts[0];
          $port = $portNumber;
          break;

        case 2:
          // HOST or IPV4 with PORT. If an explicit port number was given,
          // use it instead.
          $server = $parts[0];
          if (empty($portNumber) === TRUE && empty($parts[1]) === FALSE) {
            $port = $parts[1];
          }
          else {
            $port = $portNumber;
          }
          break;

        default:
          // Too many :'s. Possibly an IPv6 address. A port number cannot
          // be on the end of the address since it did not use the
          // square bracket notation checked earlier.
          $server = $hostName;
          $port = $portNumber;
          $mustBeIPv6 = TRUE;
          break;
      }
    }

    // Validate the host or IP address.
    if ($mustBeIPv6 === TRUE) {
      // Just validate the server as an IPv6 address because parsing so far
      // says it must be that, or something invalid.
      $result = filter_var(
        $server,
        FILTER_VALIDATE_IP,
        [
          'flags' => FILTER_FLAG_IPV6,
        ]);

      if ($result !== FALSE) {
        // Valid IPv6 address.
        $validHostName = $result;
        $validHostNameStyle = 'ipv6';
      }
      else {
        throw new \InvalidArgumentException(
          "Malformed host name.\nThe host name should be a name like \"example.com\" or an IPv4 or IPv6 address. Host names may include a colon and integer port number on the end.");
      }
    }
    else {
      // Check for a valid host name, IPv4 address, or IPv6 address.
      $result = filter_var(
        $server,
        FILTER_VALIDATE_DOMAIN,
        [
          'flags' => FILTER_FLAG_HOSTNAME,
        ]);

      if ($result !== FALSE) {
        // Valid host name.
        $validHostName = $result;
        $validHostNameStyle = 'hostname';
      }
      else {
        $result = filter_var(
          $server,
          FILTER_VALIDATE_IP,
          [
            'flags' => FILTER_FLAG_IPV4,
          ]);

        if ($result !== FALSE) {
          // Valid IPv4 address.
          $validHostName = $result;
          $validHostNameStyle = 'ipv4';
        }
        else {
          $result = filter_var(
            $server,
            FILTER_VALIDATE_IP,
            [
              'flags' => FILTER_FLAG_IPV6,
            ]);

          if ($result !== FALSE) {
            // Valid IPv6 address.
            $validHostName = $result;
            $validHostNameStyle = 'ipv6';
          }
          else {
            throw new \InvalidArgumentException(
              "Malformed host name.\nThe host name should be a name like \"example.com\" or an IPv4 or IPv6 address. Host names may include a colon and integer port number on the end.");
          }
        }
      }
    }

    // Validate the port, if any. It must be a simple positive integer.
    if (empty($port) === FALSE) {
      if (preg_match('/^[0-9]+$/', $port) !== 1) {
        // Port number is not numeric. We may have been given a URL
        // for the host name and it was parsed like this:
        // - "http"
        // - "//example.com/path"
        //
        // This would interpret "//example.com/path" as a port number,
        // and fail here.
        throw new \InvalidArgumentException(
          "Malformed host name.\nThe host name should be a name like \"example.com\" or an IPv4 or IPv6 address. Host names may include a colon and integer port number on the end.");
      }

      $port = intval($port);
      if ($port > 65535) {
        // Port number is out of range.
        throw new \InvalidArgumentException(
          "Invalid port number.\nPort numbers must be positive integers from 0 through 65535.");
      }

      $validPortNumber = $port;
    }

    // Log out.
    $this->logout();

    $this->clearCsrfToken();
    $this->unverifyServer();

    // Save the parsed results.
    $this->hostName      = $validHostName;
    $this->hostNameStyle = $validHostNameStyle;
    $this->portNumber    = $validPortNumber;
  }

  /*--------------------------------------------------------------------
   *
   * Authentication.
   *
   *--------------------------------------------------------------------*/

  /**
   * Returns the authentication type in use.
   *
   * The authentication type is set at login as one of:
   * - ATHENTICATION_NONE = there is no user authentication.
   * - ATHENTICATION_BASIC = authentication uses a user name and password.
   * - ATHENTICATION_COOKIE = authentication uses a session cookie along
   *   with a user name and password.
   *
   * @return string
   *   Returns the authentication type.
   *
   * @see ::AUTHENTICATION_NONE
   * @see ::AUTHENTICATION_BASIC
   * @see ::AUTHENTICATION_COOKIE
   */
  public function getAuthenticationType() {
    return $this->authenticationType;
  }

  /**
   * Returns a human-friendly name string for the authentication type.
   *
   * @param string $authenticationType
   *   The authentication type to translate into a name string.
   *
   * @return string
   *   Returns a human-friendly name for the authentication type.
   *
   * @see ::getAuthenticationType()
   */
  public function getAuthenticationTypeName(string $authenticationType) {
    switch ($authenticationType) {
      case self::AUTHENTICATION_NONE:
        return "No Authentication";

      case self::AUTHENTICATION_BASIC:
        return "Basic Authentication";

      case self::AUTHENTICATION_COOKIE:
        return "Cookie Authentication";

      default:
        return "Unknown Authentication: $authenticationType";
    }
  }

  /**
   * Gets the user name, if set, when using basic and cookie authentication.
   *
   * The user name is set at login.
   *
   * @return string
   *   Returns the current user name.
   *
   * @see ::getPassword()
   * @see ::login()
   * @see ::logout()
   */
  public function getUserName() {
    return $this->userName;
  }

  /**
   * Gets the password, if set, when using basic and cookie authentication.
   *
   * The password is set at login.
   *
   * @return string
   *   Returns the current password.
   *
   * @see ::getUserName()
   * @see ::login()
   * @see ::logout()
   */
  public function getPassword() {
    return $this->password;
  }

  /**
   * Returns TRUE if the user is logged in.
   *
   * A connection is logged in if credentials were supplied to login()
   * and those credentials have been confirmed by the server. Confirmation
   * is performed differently for different authentication types:
   * - AUTHENTICATION_NONE: credentials are never confirmed and this
   *   function always returns FALSE.
   * - AUTHENTICATION_COOKIE: credentials are confirmed at login().
   * - AUTHENTICATION_BASIC: credentials are confirmed on the first request
   *   after login().
   *
   * @return bool
   *   Returns TRUE if the connection has been logged in, and FALSE
   *   otherwise.
   */
  public function isLoggedIn() {
    switch ($this->authenticationStatus) {
      default:
      case self::STATUS_NOT_LOGGED_IN:
      case self::STATUS_FAILED:
        return FALSE;

      case self::STATUS_LOGGED_IN:
        return TRUE;
    }
  }

  /**
   * Returns a human-friendly name string for the authentication status.
   *
   * @param int $authenticationStatus
   *   The authentication status to translate into a name string.
   *
   * @return string
   *   Returns a human-friendly name for the authentication status.
   */
  protected function getAuthenticationStatusName(int $authenticationStatus) {
    switch ($authenticationStatus) {
      case self::STATUS_NOT_LOGGED_IN:
        return "Not logged in";

      case self::STATUS_FAILED:
        return "Login failed";

      case self::STATUS_LOGGED_IN:
        return "Logged in";

      default:
        return "Unknown authentication status: $authenticationStatus";
    }
  }

  /*--------------------------------------------------------------------
   *
   * Configuration.
   *
   *--------------------------------------------------------------------*/

  /**
   * Returns the currently selected format for returned data.
   *
   * For requests that return data, that data is returned as an associative
   * array in one of two formats:
   * - 'full' = returns a full detailed entity or list of entities.
   * - 'keyvalue' = returns a simplified entity or list of entities.
   *
   * @return string
   *   The name of a server-known format for returned data.
   *
   * @see ::setReturnFormat()
   */
  public function getReturnFormat() {
    return $this->format;
  }

  /**
   * Sets the currently selected format for returned data.
   *
   * For requests that return data, that data is returned as an associative
   * array in one of two formats:
   * - 'full' = returns a full detailed entity or list of entities.
   * - 'keyvalue' = returns a simplified entity or list of entities.
   *
   * @param string $format
   *   The name of a server-known format for returned data.
   *
   * @see ::getReturnFormat()
   */
  public function setReturnFormat(string $format) {
    $this->format = $format;
  }

  /**
   * Returns the client-server serialization format.
   *
   * The serialization format describes the internal syntax used for
   * communicating entities between the client and server. The format is
   * one of those supported for entities by the server.
   *
   * @return string
   *   Returns the name of the serialization format.
   *
   * @see ::SERIALIZATION_JSON
   * @see ::SERIALIZATION_JSONHAL
   * @see ::verifyServer()
   * @see ::getServerConfiguration()
   */
  public function getSerializationFormat() {
    return $this->serializationFormat;
  }

  /**
   * Returns a human-friendly name string for the serialization format.
   *
   * @param string $serializationFormat
   *   The serialization format to translate into a name string.
   *
   * @return string
   *   Returns a human-friendly name for the serialization format.
   *
   * @see ::getSerializationFormat()
   */
  public function getSerializationFormatName(string $serializationFormat) {
    switch ($serializationFormat) {
      case self::SERIALIZATION_NONE:
        return "No Serialization";

      case self::SERIALIZATION_JSON:
        return "JSON Serialization";

      case self::SERIALIZATION_JSONHAL:
        return "JSON + Hypertext Application Language (HAL) Serialization";

      default:
        return "Unknown Serialization: $serializationFormat";
    }
  }

  /**
   * Returns the URL format option for the serialization format.
   *
   * The current serialization format mandates an option on request URLs
   * that indicates the serialization format to use. This method returns
   * that string.
   *
   * @return string
   *   Returns the URL option string for the serialization format.
   */
  private function getSerializationUrlQuery() {
    switch ($this->serializationFormat) {
      default:
      case self::SERIALIZATION_NONE:
        return '';

      case self::SERIALIZATION_JSON:
        return '_format=json';

      case self::SERIALIZATION_JSONHAL:
        return '_format=hal_json';
    }
  }

  /*--------------------------------------------------------------------
   *
   * Error messages.
   *
   *--------------------------------------------------------------------*/

  /**
   * Returns a nicer CURL error message.
   *
   * CURL errors indicate a communications problem. For all errors, CURL can
   * provide a brief error message, but these messages are rarely sufficient
   * to explain to a user what is going on and what they can do about it.
   *
   * This method maps selected error numbers to friendlier error messages.
   * If the error number is not recognized, the default CURL error message
   * is returned.
   *
   * @param int $errno
   *   The CURL error number.
   *
   * @return string
   *   Returns a friendly error message.
   */
  protected function getNiceCurlErrorMessage(int $errno) {
    switch ($errno) {
      case CURLE_URL_MALFORMAT:
        return <<<'EOS'
The host name is not in the proper format.
Please check that the name does not include a "/", space, or other punctuation characters.
EOS;

      case CURLE_URL_MALFORMAT_USER:
      case CURLE_MALFORMAT_USER:
        return <<<'EOS'
The user name is not in the proper format.
Please check that the name does not include a ":", space, or other punctuation characters.
EOS;

      case CURLE_COULDNT_RESOLVE_HOST:
        return <<<'EOS'
The host could not be found.
Please check your host name for typos.
EOS;

      case CURLE_HTTP_PORT_FAILED:
        if ($this->portNumber === 80) {
          return <<<'EOS'
The host refused a connection on the default port 80.
The host may not support web service access or it may require a different port.  You may specify a port by adding ":" and a port number to the end of the host name (e.g. "example.com:1234").
EOS;
        }

        $port = $this->portNumber;
        return <<<EOS
The host refused a connection on the specified port $port.
Please check that the port number is correct.
EOS;

      case CURLE_COULDNT_CONNECT:
      case CURLE_OPERATION_TIMEOUTED:
        return <<<'EOS'
The host is not responding.
The host may be down, there could be a network problem, or the host may not support the network connections required by this application.
EOS;

      case CURLE_BAD_PASSWORD_ENTERED:
        return <<<'EOS'
The host denied access because the user name or password is incorrect.
Please check your user name and password for typos.
EOS;

      case CURLE_TOO_MANY_REDIRECTS:
        return <<<'EOS'
There is a communications problem with the host.
The host is repeatedly redirecting requests to another host, or to the same host in a never-ending cycle. Please report this to the host's administrator.
EOS;

      case CURLE_SEND_ERROR:
        return <<<'EOS'
The host unexpectedly stopped receiving requests.
The host may have gone down or there could be a network problem.
EOS;

      case CURLE_RECV_ERROR:
        return <<<'EOS'
The host unexpectedly stopped sending information.
The host may have gone down or there could be a network problem.
EOS;

      case CURLE_FILESIZE_EXCEEDED:
        return <<<'EOS'
The host reported that the file size was too large.
The file may be too large to transfer.
EOS;

      case CURLE_PARTIAL_FILE:
        return <<<'EOS'
The host failed to send the entire file.
The host may be busy, there may be a connection problem, or the file may be too large to transfer reliably.
EOS;

      default:
        return curl_error($this->curlSession);
    }
  }

  /**
   * Returns a nicer HTTP error message.
   *
   * Web servers that respond with an error HTTP code may or may not include
   * a message with that code. If they do not, this method returns a nicer
   * message for a variety of common HTTP codes.
   *
   * @param int $httpCode
   *   The HTTP code.
   *
   * @return string
   *   Returns friendlier error message.
   */
  protected function getNiceHttpErrorMessage(int $httpCode) {
    //
    // The list below is intentionally incomplete. HTTP codes that are not
    // likely for requests issued by this class are not included. For
    // instance, codes associated with WebDAV, IM, and proxies are not
    // included.
    //
    switch ($httpCode) {
      case 200:
        // OK.
        return <<<'EOS'
The request succeeded.
EOS;

      case 201:
        // Created.
        return <<<'EOS'
The request to create content succeeded.
EOS;

      case 202:
        // Accepted.
        return <<<'EOS'
The request was accepted and processing is in progress.
EOS;

      case 204:
        // No content.
        return <<<'EOS'
The request succeeded and, as expected, no content was returned.
EOS;

      case 400:
        // Bad request.
        return <<<'EOS'
There is a problem with the request.
The host rejected the request because it is too large or it is improperly formatted. This is probably a programming error. Please contact the developers of this software.
EOS;

      case 401:
        // Unauthorized. This really should be handled outside this method
        // so that the server's response header can be considered.
        return <<<'EOS'
The host has denied access.
The host may require additional authentication or the host may be blocking access from your local host or network.
EOS;

      case 403:
        // Forbidden.
        return <<<'EOS'
The host denied access. You do not have permission for this request.
EOS;

      case 404:
        // Not found.
        return <<<'EOS'
The requested information could not be found.
EOS;

      case 405:
        // Method not allowed.
        return <<<'EOS'
The host does not support this type of information request.
EOS;

      case 406:
        // Not acceptable.
        return <<<'EOS'
The host does not support information interchange in a format recognized by this application.
EOS;

      case 408:
        // Request timeout.
        return <<<'EOS'
The host is unexpectedly not responding.
The host may have gone down, there could be a network problem, or the host may have had a problem with the request.
EOS;

      case 410:
        // Gone.
        return <<<'EOS'
The requested information is no longer available.
EOS;

      case 429:
        // Too many requests.
        return <<<'EOS'
The host is declining connections because of too many requests.
The host is rate limiting its communications and the number of requests has exceeded that limit.
EOS;

      case 500:
        // Internal server error.
        return <<<'EOS'
The host encountered an unknown internal error.
If this continues, please report this to the host's administrator.
EOS;

      case 503:
        // Service unavailable.
        return <<<'EOS'
The host's services are temporarily unavailable.
Please check back later.
EOS;

      default:
        // All other error codes are obscure. Return a generic message.
        return <<<EOS
The host responded with an unexpected HTTP error code: $httpCode.
EOS;
    }
  }

  /*--------------------------------------------------------------------
   *
   * Utilities.
   *
   * The miscellaneous functions here provide mixed functionality to
   * later code.
   *
   *--------------------------------------------------------------------*/

  /**
   * Parses a URI for remote content into its component parts.
   *
   * URIs for remote Foldershare files and folders have a variety of
   * supported forms:
   * - SCHEME://USER/PATH
   * - SCHEME://USER/
   * - SCHEME://USER
   * - SCHEME:/PATH
   * - SCHEME:/
   * - //USER/PATH
   * - //USER/
   * - //USER
   * - /PATH
   * - /
   *
   * SCHEME is either "personal" or "public".
   *
   * The use of '//' and '/' is per URI specifications and is independent
   * of the local file system's conventions (e.g. '/' for Linux/BSD/macOS,
   * and '\' for Windows).
   *
   * @param string $uri
   *   The remote file or folder URI to parse.
   *
   * @return array
   *   Returns an associative array with three keys:
   *   - 'scheme': "personal", "private", or "".
   *   - 'user': a user name or "".
   *   - 'path': the file path or "".
   *
   * @see ::normalizeUri()
   * @see ::normalizeUris()
   */
  public static function parseUri(string $uri) {
    $scheme = '';
    $user = '';
    $filepath = '';
    $parts = [];

    // Get the scheme ("personal" or "public"), if any.
    if (mb_ereg('^((personal)|(public)):(/.*$)', $uri, $parts) !== FALSE) {
      // SCHEME://USER/PATH
      // SCHEME://USER/
      // SCHEME://USER
      // SCHEME:/PATH
      // SCHEME:/
      $scheme = $parts[1];
      $rest = $parts[4];
    }
    else {
      $rest = $uri;
    }

    // Get the user (name or ID), if any.
    if (mb_ereg('^//([^/]+)(/.*)?$', $rest, $parts) !== FALSE) {
      // //USER/PATH
      // //USER/
      // //USER
      $user = $parts[1];
      $filepath = $parts[2];
    }
    else {
      // /PATH
      // /
      $filepath = $rest;
    }

    if (empty($filepath) === TRUE) {
      $filepath = '/';
    }

    return [
      'scheme' => $scheme,
      'user'   => $user,
      'path'   => $filepath,
    ];
  }

  /**
   * Normalizes a URI for remote content by remove redundant slashes.
   *
   * The "/" path is returned as-is. All other paths have trailing slashes
   * removed, and intermediate redundant slashes reduced to a single slash.
   * 
   * Examples:
   * - "/" is normalized as "/".
   * - "//" is normalized as "/".
   * - "a" is normalized as "a".
   * - "/a" is normalized as "/a".
   * - "/a/" is normalized as "/a".
   * - "/a//b" is normalized as "/a/b".
   *
   * @param string $uri
   *   A remote file or folder URI.
   * @param bool $removeTrailingSlash
   *   (optional, default = TRUE) When TRUE, any trailing slashes are removed.
   *
   * @return string
   *   Returns the normalized URI.
   *
   * @see ::normalizeUris()
   * @see ::parseUri()
   */
  public static function normalizeUri(
    string $uri,
    bool $removeTrailingSlash = TRUE) {

    if (empty($uri) === TRUE) {
      return '';
    }

    // Split the URI into an optional scheme, optional user, and required path.
    $parts = self::parseUri($uri);
    $scheme   = $parts['scheme'];
    $user     = $parts['user'];
    $filepath = $parts['path'];

    // Remove extra slashes in path.
    $normalized = mb_ereg_replace('[/]+', '/', $filepath);
    if ($normalized !== '/' &&
        $normalized !== 'personal:/' &&
        $normalized !== 'public:/' &&
        $removeTrailingSlash === TRUE) {
      $normalized =  mb_ereg_replace('/$', '', $normalized);
    }

    // Rebuild using the normalized URI.
    if (empty($scheme) === FALSE) {
      if (empty($user) === FALSE) {
        return $scheme . '://' . $user . $normalized;
      }
      return $scheme . ':' . $normalized;
    }
    elseif (empty($user) === FALSE) {
      return '//' . $user . $normalized;
    }

    return $normalized;
  }

  /**
   * Normalizes an array of URIs for remote content by remove redundant slashes.
   *
   * The "/" path is returned as-is. All other paths have trailing slashes
   * removed, and intermediate redundant slashes reduced to a single slash.
   * 
   * Examples:
   * - "/" is normalized as "/".
   * - "//" is normalized as "/".
   * - "a" is normalized as "a".
   * - "/a" is normalized as "/a".
   * - "/a/" is normalized as "/a".
   * - "/a//b" is normalized as "/a/b".
   *
   * @param string[] $uris
   *   An array of remote file or folder URIs.
   * @param bool $removeTrailingSlash
   *   (optional, default = TRUE) When TRUE, any trailing slashes are removed.
   *
   * @return string[]
   *   Returns an array of normalized URIs.
   *
   * @see ::normalizeUri()
   * @see ::parseUri()
   */
  public static function normalizeUris(
    array $uris,
    bool $removeTrailingSlash = TRUE) {

    $normalized = [];
    foreach ($uris as $uri) {
      $normalized[] = self::normalizeUri($uri, $removeTrailingSlash);
    }

    return $normalized;
  }

  /**
   * Creates an empty dummy entity.
   *
   * During POST and PATCH operations, a new entity and fields are required
   * in the request. If the operation does not need a detailed entity, or if
   * the caller does not provide one, this dummy entity is used.
   *
   * @return array
   *   Returns a dummy entity array with well-known fields and no values.
   */
  protected function createDummyEntity() {
    // The 'name' field is required, but the others are not.
    // - 'uid'.
    // - 'created'.
    // - 'changed'.
    // - 'description'.
    // - 'kind'.
    // - 'mime'.
    // - 'parentid'.
    // - 'rootid'.
    // - 'size'.
    // - 'file'.
    // - 'image'.
    // - 'media'.
    // - 'grantauthoruids'.
    // - 'grantviewuids'.
    return [
      'name' => [],
    ];
  }

  /**
   * Returns CURL options common to most HTTP requests made here.
   *
   * These options do the following:
   * - Set the user agent.
   * - Request that content be returned.
   * - Disable returning the header.
   * - Enable redirect following.
   * - Set timeouts.
   *
   * If $includeAuthentication is TRUE, then HTTP basic user name and
   * password credentials are added to the header, if they have been set.
   *
   * @param bool $includeAuthentication
   *   (optional, default = TRUE) When TRUE, authentication credentials
   *   are included.
   *
   * @return array
   *   Returns an array of common Curl options.
   *
   * @see ::login()
   */
  protected function getCommonCurlOptions(bool $includeAuthentication = TRUE) {
    $options = [
      // Requests come from this class.
      CURLOPT_USERAGENT      => 'FolderShareConnect',

      // Return the request's results.
      CURLOPT_RETURNTRANSFER => TRUE,

      // Don't include the HTTP header in the results. This corrupts
      // those results. Instead, if the header is needed, a header callback
      // is used.
      CURLOPT_HEADER         => FALSE,

      // Don't encode.
      CURLOPT_ENCODING       => '',

      // Follow redirects.
      CURLOPT_FOLLOWLOCATION => TRUE,
      CURLOPT_AUTOREFERER    => TRUE,
      CURLOPT_MAXREDIRS      => 10,

      // Time-out if things stall.
      CURLOPT_CONNECTTIMEOUT => self::DEFAULT_CURL_CONNECT_TIMEOUT,
      CURLOPT_TIMEOUT        => self::DEFAULT_CURL_TIMEOUT,

      // SSL, verify host and peer.
      CURLOPT_SSL_VERIFYPEER => TRUE,
      CURLOPT_SSL_VERIFYHOST => 2,
    ];

    // SSL, do not use verify status (OCSP certificate stapling) since
    // it is not yet widely supported and causes unexpected failures.
    if (defined('CURLOPT_SSL_VERIFYSTATUS') === TRUE) {
      $options[CURLOPT_SSL_VERIFYSTATUS] = FALSE;
    }

    // If there is a need to include authentication credentials, add the
    // right options.
    if ($includeAuthentication === TRUE) {
      $typeName = $this->getAuthenticationTypeName($this->authenticationType);
      $this->printVerbose("  Using $typeName");

      switch ($this->authenticationType) {
        case self::AUTHENTICATION_BASIC:
          // Add credentials for basic authentication.
          $options[CURLOPT_HTTPAUTH] = CURLAUTH_BASIC;
          $options[CURLOPT_USERNAME] = $this->userName;
          $options[CURLOPT_PASSWORD] = $this->password;
          break;

        case self::AUTHENTICATION_COOKIE:
          // Add credentials for cookie authentication.
          $options[CURLOPT_COOKIEJAR] = "";
          $options[CURLOPT_COOKIEFILE] = "";
          break;
      }
    }

    return $options;
  }

  /*--------------------------------------------------------------------
   *
   * Server verification.
   *
   * These methods verify a connection to a server and request the
   * features it supports.
   *
   *--------------------------------------------------------------------*/

  /**
   * Resets verification of server communications.
   *
   * Server verification is needed prior to the first server request to
   * insure that the server exists and can respond to requests, and to
   * get the list of HTTP verbs supported by the sever.
   *
   * Server verification should be reset each time key communications
   * parameters are changed, such as the host name. It is not necessary to
   * reset on changes to authentication credentials since the server would
   * still exist and still support the same range of HTTP requests.
   *
   * @see ::verifyServer()
   */
  protected function unverifyServer() {
    // Log the user out if they are logged in.
    $this->logout();

    $this->serverVerified       = FALSE;
    $this->httpVerbs            = [];
    $this->httpConfiguration    = [];
    $this->serializationFormat  = self::SERIALIZATION_NONE;
    $this->authenticationType   = self::AUTHENTICATION_NONE;
    $this->authenticationStatus = self::STATUS_NOT_LOGGED_IN;
    $this->logoutToken          = '';

    $this->clearCsrfToken();
  }

  /**
   * Verifies that the server exists and can respond to requests.
   *
   * This method is called the first time a request is made of the server.
   * It serves three purposes:
   * - Validates that the server exists and can respond.
   * - Gets the HTTP verbs that the site responds to.
   * - Gets the HTTP verb serialization and authentication features supported
   *   by the site.
   *
   * An exception is thrown if the server does not exist or cannot respond.
   * An exception is also thrown if the server does not respond with an
   * 'Allow' header that lists supported HTTP verbs.
   *
   * Otherwise the 'Allow' header is used to initialize the $httpVerbs
   * field that lists supported HTTP verbs, such as 'GET', 'POST',
   * 'PATCH', and 'DELETE'.
   *
   * An HTTP configuration request is then sent to get the serialization
   * and authentication features of the site. These may conflict with the
   * server's response about allowed HTTP verbs. These are reconciled and
   * checked for supportability by this software. If there is no known
   * authentication provider supported, or no known serialization format
   * supported, an exception is thrown.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such as with a bad host name.
   *   - The host refuses contact.
   *   - The host does not support the operation.
   *   - The host does not support a known authentication provider.
   *   - The host does not support a known serialization format.
   *
   * @see ::unverifyServer()
   */
  protected function verifyServer() {
    //
    // Validate
    // --------
    // If the server has already been verified, no further action is needed.
    if ($this->serverVerified === TRUE) {
      return;
    }

    //
    // Get configuration
    // -----------------
    // Query the site's configuration. This serves several purposes:
    //
    // - It verifies that the server exists and that we can communicate
    //   with it.
    //
    // - It determines the serialization format to use for further requests.
    //
    // - It determines the authentication mechanism to use for further
    //   requests.
    //
    // - It gets us the HTTP verbs supported (GET, POST, PATCH, DELETE).
    //
    // The response lists the HTTP verbs, serialization formats, and
    // authentication mechanisms supported. Unfortunately, making the
    // request at all requires knowing the right serialization format to
    // use, so we have to iterate over the possibilities.
    //
    // Server verification occurs before a user login, so the current
    // authentication type is AUTHENTICATION_NONE and no credentials will
    // be included in the request.
    //
    // This GET request will fail if the site does not have the FolderShare
    // REST resource enabled, or there is a significant version skew between
    // this client software and the server module.
    $this->clearCsrfToken();

    // Reduce the HTTP verbs to just "GET", which we presume is supported.
    // If it isn't, then the configuration request below will fail and
    // the server does not support communications.
    $this->httpVerbs = ["GET"];

    $this->printVerbose("Verifying server connection with configuration query");

    $serializationFormats = [
      // The JSON format is the most common, so try it first.
      self::SERIALIZATION_JSON,

      // The JSONHAL format is a derivative of JSON that adds links that
      // we can safely ignore.
      self::SERIALIZATION_JSONHAL,
    ];

    $config = NULL;
    $savedException = NULL;

    foreach ($serializationFormats as $format) {
      $this->printVerbose("Looking for server support of '" . $format . "' serialization.");
      try {
        $this->serializationFormat = $format;
        $config = $this->getServerConfiguration();
        break;
      }
      catch (\RuntimeException $e) {
        if ($e->getCode() < 0) {
          // Curl error. Fatal.
          throw $e;
        }

        // Save the exception and try the next format, if any.
        $savedException = $e;
      }
    }

    if ($savedException !== NULL) {
      // Unfortunately, Drupal has not provided a meaningful HTTP code or
      // message on some failures. For instance, if the route we tried is not
      // recognized because the FolderShare REST module is not enabled, Drupal
      // returns a generic "404" error, indicating "The requested information
      // could not be found." This is no help to the user.
      $httpCode = $savedException->getCode();
      $message = $e->getMessage();

      $this->printVerbose("  Server failed with HTTP code $httpCode");
      $this->printVerbose("  $message");

      if ($httpCode === 404) {
        throw new \RuntimeException("REST web services are not enabled on the server.\nThis client supports communications to a server with the FolderShare REST module installed, but the module is not responding. Please contact the site administrator about installing the module.");
      }

      throw new \RuntimeException($message);
    }

    if ($config === NULL) {
      // The server failed to return a configuration from which we can
      // determine what HTTP verbs are supported and what authentication
      // and serialization formats to use.
      $message = "The host did not return a server configuration.\nThere is probably a bug in the server software. Please contact the host's administrator.";
      $this->printVerbose("  Server failed to return a usable server configuration");
      $this->printVerbose("  $message");
      $this->serverVerified = FALSE;
      throw new \RuntimeException($message);
    }

    // Check the FolderShare module version number for compatability.
    if (isset($config['foldershare_rest_protocol']) === FALSE) {
      throw new \RuntimeException("Unknown protocol version for server's FolderShare REST module.\nThis client supports communications protocol version " . self::MINIMUM_PROTOCOL_VERSION . " and above, but the server module is using an unknown protocol version. This prevents this client from communicating with " . $this->getHostName() . ". Please contact the site administrator about updating the site.");
    }

    $serverProtocol = $config['foldershare_rest_protocol'];
    if ($serverProtocol < self::MINIMUM_PROTOCOL_VERSION) {
      throw new \RuntimeException("Protocol version mismatch with server's FolderShare REST module.\nThis client supports communications protocol version " . self::MINIMUM_PROTOCOL_VERSION . " and above, but the server module is using an older $serverProtocol version. This prevents this client from communicating with " . $this->getHostName() . ". Please contact the site administrator about upgrading the site.");
    }

    // Go through the returned configuration and determine what HTTP verbs
    // are supported.
    foreach ($config as $key => $values) {
      switch ($key) {
        case "GET":
        case "POST":
        case "PATCH":
        case "DELETE":
          $this->httpVerbs[] = $key;
          break;

        default:
          // Ignore anything else.
          break;
      }
    }

    $this->printVerbose("  Supported requests: " . implode(', ', $this->httpVerbs));

    // Tentatively verify server connection. This may be reversed below.
    $this->serverVerified = TRUE;

    //
    // Select authentication type
    // --------------------------
    // Based upon the list of authentication providers supported by the
    // server, select a preferred authentication type supported by this client.
    //
    // Make the decision based upon what GET supports on the server, then
    // check that POST, PATCH, and DELETE support it as well. If not, abort.
    $bestAuthenticationType = self::AUTHENTICATION_NONE;

    foreach (self::AUTHENTICATION_PREFERENCE_ORDER as $preference) {
      if (in_array($preference, $config['GET']['authentication-providers']) === TRUE) {
        $bestAuthenticationType = $preference;
        break;
      }
    }

    if ($bestAuthenticationType === self::AUTHENTICATION_NONE) {
      // None of the authentication types supported by this client are
      // listed as supported by the server.
      $message = <<<'EOS'
The host does not support any known authentication methods.
This can occur if the host's web services configuration has not enabled any of the authentication methods supported by this software. Please contact the host's administrator.
EOS;
      $this->printVerbose("  Server does not support any known authentication provider");
      $this->printVerbose("  $message");
      $this->serverVerified = FALSE;
      throw new \RuntimeException($message);
    }

    foreach ($this->httpVerbs as $verb) {
      if (in_array($bestAuthenticationType, $config[$verb]['authentication-providers']) === FALSE) {
        // The best authentication type chosen above is NOT supported by
        // this HTTP verb.
        $message = <<<'EOS'
The host has a confusing configuration for authentication providers.
This can occur if the host's administrator has missconfigured web services and enabled a different authentication provider for each of the web service methods. Please contact the host's administrator.
EOS;
        $this->printVerbose("  Server does not have same authentication providers for all HTTP verbs");
        $this->printVerbose("  $message");
        $this->serverVerified = FALSE;
        throw new \RuntimeException($message);
      }
    }

    $this->authenticationType = $bestAuthenticationType;

    //
    // Select serialization format
    // ---------------------------
    // Based upon the lsit of serialization formats supported by the
    // server, select a preferred format supported by this client.
    //
    // Make the decision based upon what GET supports on the server, then
    // check that POST, PATCH, and DELETE support it as well. If not, abort.
    $bestSerializationFormat = self::SERIALIZATION_NONE;

    foreach (self::SERIALIZATION_PREFERENCE_ORDER as $preference) {
      if (in_array($preference, $config['GET']['serializer-formats']) === TRUE) {
        $bestSerializationFormat = $preference;
        break;
      }
    }

    if ($bestSerializationFormat === self::SERIALIZATION_NONE) {
      // None of the serialization formats supported by this client are
      // listed as supported by the server.
      $message = <<<'EOS'
The host does not support any known serialization methods.
This can occur if the host's web services configuration has not enabled any of the serialization formats supported by this software. Please contact the host's administrator.
EOS;
      $this->printVerbose("  Server does not support any known serialization formats");
      $this->printVerbose("  $message");
      $this->serverVerified = FALSE;
      throw new \RuntimeException($message);
    }

    foreach ($this->httpVerbs as $verb) {
      if (in_array($bestSerializationFormat, $config[$verb]['serializer-formats']) === FALSE) {
        // The best format chosen above is NOT supported by this HTTP verb.
        $message = <<<'EOS'
The host has a confusing configuration for serialization formats.
This can occur if the host's administrator has missconfigured web services and enabled a different serialization format for each of the web service methods. Please contact the host's administrator.
EOS;
        $this->printVerbose("  Server does not have same serialization format for all HTTP verbs");
        $this->printVerbose("  $message");
        $this->serverVerified = FALSE;
        throw new \RuntimeException($message);
      }
    }

    $this->serializationFormat = $bestSerializationFormat;

    // Done at last!
    $this->printVerbose("  Server connection verified");
    $this->printVerbose("    Authentication type to use: " .
      $this->getAuthenticationTypeName($this->authenticationType));
    $this->printVerbose("    Serialization format to use: " .
      $this->getSerializationFormatName($this->serializationFormat));

    // Get the CSRF token.
    $this->getCsrfToken();
  }

  /**
   * Returns TRUE if HTTP DELETE requests are supported on the server.
   *
   * If no requests have been made to the server yet, this method makes
   * a server request to get the list of HTTP requests supported.
   *
   * @return bool
   *   Returns TRUE if HTTP DELETE requests are supported.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact.
   *   - The host does not support the operation.
   */
  public function isHttpDeleteSupported() {
    $this->verifyServer();
    return in_array('DELETE', $this->httpVerbs);
  }

  /**
   * Returns TRUE if HTTP GET requests are supported on the server.
   *
   * If no requests have been made to the server yet, this method makes
   * a server request to get the list of HTTP requests supported.
   *
   * @return bool
   *   Returns TRUE if HTTP GET requests are supported.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact.
   *   - The host does not support the operation.
   */
  public function isHttpGetSupported() {
    $this->verifyServer();
    return in_array('GET', $this->httpVerbs);
  }

  /**
   * Returns TRUE if HTTP PATCH requests are supported on the server.
   *
   * If no requests have been made to the server yet, this method makes
   * a server request to get the list of HTTP requests supported.
   *
   * @return bool
   *   Returns TRUE if HTTP PATCH requests are supported.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact.
   *   - The host does not support the operation.
   */
  public function isHttpPatchSupported() {
    $this->verifyServer();
    return in_array('PATCH', $this->httpVerbs);
  }

  /**
   * Returns TRUE if HTTP POST requests are supported on the server.
   *
   * If no requests have been made to the server yet, this method makes
   * a server request to get the list of HTTP requests supported.
   *
   * @return bool
   *   Returns TRUE if HTTP POST requests are supported.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact.
   *   - The host does not support the operation.
   */
  public function isHttpPostSupported() {
    $this->verifyServer();
    return in_array('POST', $this->httpVerbs);
  }

  /**
   * Gets a list of HTTP operations supported on the server.
   *
   * If no requests have been made to the server yet, this method makes
   * a server request to get the list of HTTP requests supported. Typically
   * these include:
   * - GET = get items or configuration information.
   * - POST = create or upload new items.
   * - PATCH = change existing items.
   * - DELETE = delete existing items.
   *
   * A host usually has all of these enabled, but for security reasons it
   * is possible for a host to disable some or all of them. For instance,
   * a host that publishes public content may have GET enabled, but it
   * may disable POST, PATCH, and DELETE so that that content cannot be
   * modified.
   *
   * @return string[]
   *   Returns an array listing the HTTP verbs supported by the server.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact.
   *   - The host does not support the operation.
   *
   * @see ::getServerConfiguration()
   * @see ::isHttpDeleteSupported()
   * @see ::isHttpGetSupported()
   * @see ::isHttpPatchSupported()
   * @see ::isHttpPostSupported()
   */
  public function getHttpVerbs() {
    $this->verifyServer();
    return $this->httpVerbs;
  }

  /*--------------------------------------------------------------------
   *
   * CSRF token handling.
   *
   * A CSRF (Cross-Site Request Forgery) token must be requested, returned,
   * and used for all operations that might change remote content (e.g.
   * for POST, PATCH, and DELETE requests).
   *
   *--------------------------------------------------------------------*/

  /**
   * Clears the CSRF token saved from a prior request.
   *
   * The connection's CSRF token is initially cleared and it must be
   * cleared again (to trigger a future request for a new CSRF token)
   * any time primary communications parameters are changed, such as
   * the host name. Logging out also clears the CSRF token.
   *
   * @see ::getCsrfToken()
   * @see ::logout()
   */
  protected function clearCsrfToken() {
    $this->csrfToken = NULL;
  }

  /**
   * Returns the current CSRF token.
   *
   * A "Cross-Site Request Forgery" (CSRF) is a web site or user attack
   * that sends a message to a server, without the user's knowledge, to
   * change the user's data on the server. The message reuses the current
   * authentication credentials of a logged in user.
   *
   * A CSRF token is a randomly generated string created by the server and
   * issued to the client for use throughout a session. Drupal requires
   * that all "non-safe" HTTP requests (i.e. anything except OPTIONS, GET,
   * and HEAD) send a previously acquired CSRF token as part of its
   * validation mechanism. Requests without the CSRF token, or with a wrong
   * token, are rejected.
   *
   * The communications methods in this class call this method to get the
   * current CSRF token each time they need to make a "non-safe" operation.
   * If no token has been requested from the site yet, a request is made
   * immediately to get a new CSRF token. That token is saved and re-used
   * on future calls.
   *
   * Cookie-based authentication automatically retreives the CSRF token
   * during login. Other authentication types may require an explicit
   * request to get a CSRF token.
   *
   * @return string
   *   Returns the current CSRF token, or NULL if a token could not
   *   be retrieved because the site is down or it does not respond to
   *   a token request.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *
   * @see ::clearCsrfToken()
   * @see ::login()
   */
  protected function getCsrfToken() {
    //
    // Return current token (if any)
    // -----------------------------
    // If a previous request for a CSRF token has already returned one
    // for this session, return it immediately.
    if ($this->csrfToken !== NULL) {
      return $this->csrfToken;
    }

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    //
    // Authentication credentials are not required. In fact, if they are
    // included, the request will fail.
    $options = $this->getCommonCurlOptions(FALSE);
    $options[CURLOPT_HTTPGET] = TRUE;
    $options[CURLOPT_URL] = $this->getHostNameAndPortNumber() .
      self::URL_CSRF_TOKEN;

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue GET
    // ---------
    // Issue an HTTP GET to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content is the CSRF token string.
    $this->printVerbose("Getting CSRF token");
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_RESPONSE_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    if ($httpCode !== 200) {
      // A CSRF token was not returned! Operations that require the token
      // cannot be done.
      if (isset($content['message']) === TRUE) {
        $message = $content['message'];
      }
      else {
        $message = $this->getNiceHttpErrorMessage($httpCode);
      }

      $this->printVerbose("  Server failed with HTTP code $httpCode");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    $this->printVerbose("  CSRF token received");
    $this->csrfToken = $content;
    return $this->csrfToken;
  }

  /*--------------------------------------------------------------------
   *
   * Login and logout.
   *
   * Login uses the authentication type and credentials to establish an
   * authenticated connection with the server. Logout reverses that.
   *
   *--------------------------------------------------------------------*/

  /**
   * Logs the user in to the server using the given authentication credentials.
   *
   * Authentication credentials include a user name and password for
   * the remote server. Setting these credentials and logging in must be
   * done before any requests may be sent to the server.
   *
   * The way authentication credentials are used depends upon the
   * authentication type:
   * - AUTHENTICATION_NONE does not use the credentials at all. Requests
   *   to the server are not authenticated, which usually means the caller
   *   only has access to public content that is available to anonymous
   *   visitors to the site.
   * - AUTHENTICATION_BASIC sends the credentials along on every request.
   *   The server checks the credentials before responding.
   * - AUTHENTICATION_COOKIE sends the credentials along on an initial
   *   "login" request during which the server checks the credentials before
   *   responding with a session cookie. The session cookie is then sent
   *   along on all subsequent requests.
   *
   * AUTHENTICATION_NONE is the initial state for a newly opened connection
   * object, but it is rarely suitable for use. Most activities require an
   * authenticated connection.
   *
   * AUTHENTICATION_COOKIE is the style used by web browsers where the user
   * logs into a site, then makes requests for site pages. The browser saves
   * the session cookie and automatically re-uses it for each request.
   *
   * AUTHENTICATION_BASIC is the style used by many web services. The
   * credentials are passed along with every request and there are no cookies
   * involved. This works because web services are often isolated requests
   * rather than a user asking for page after page after page.
   *
   * The AUTHENTICATION_COOKIE type is the most efficient when multiple
   * requests are made through the same open connection. This type only does
   * full authentication on the server at the start of a series of requests.
   * However, if the server has a non-standard login process, then this
   * class cannot reliably get the session cookie and authentication will
   * fail.
   *
   * The AUTHENTICATION_BASIC type is the most reliable since it can work
   * regardless of the login process.
   *
   * Authentication failure can occur for several reasons:
   * - The server may not support web services at all.
   * - The server may have a non-standard user login form that requires a
   *   CAPTCHA or other required input that this software cannot provide.
   * - The server may not have the authentication type enabled.
   * - The server may reject the user name and password as invalid.
   *
   * If the user name is empty, no authentication can be done and the
   * authentication type is automatically reset to AUTHENTICATION_NONE.
   *
   * @param string $userName
   *   The user name. If the name is empty, authentication is disabled and
   *   the authentication type is set to AUTHENTICATION_NONE. This is
   *   anonymous login for public content access only.
   * @param string $password
   *   The password. An empty password is allowed, but discouraged.
   *
   * @return bool
   *   Returns TRUE if the login is successful, and FALSE otherwise.
   *   Failed authentication often throws an exception.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the user name is not empty, but it includes
   *   illegal characters or is longer than 255 characters. Also throws an
   *   exception if the password is longer than 255 characters.
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such as with a bad host name.
   *   - The host refuses contact.
   *   - The authentication type is not accepted.
   *   - The user name or password are not accepted.
   *
   * @see ::getUserName()
   * @see ::getPassword()
   * @see ::getAuthenticationType()
   * @see ::isLoggedIn()
   * @see ::logout()
   */
  public function login(string $userName, string $password) {
    //
    // Validate user name & password
    // -----------------------------
    // Drupal's User module uses a UserNameConstraintValidator to verify that
    // user names are well-formed. The code used here mimics that code:
    if (empty($userName) === FALSE) {
      if (mb_substr($userName, 0, 1) == ' ') {
        throw new \InvalidArgumentException(
          "Malformed username.\nThe username cannot begin with a space.");
      }

      if (mb_substr($userName, -1) == ' ') {
        throw new \InvalidArgumentException(
          "Malformed username.\nThe username cannot end with a space.");
      }

      if (mb_strpos($userName, '  ') !== FALSE) {
        throw new \InvalidArgumentException(
          "Malformed username.\nThe username cannot contain multiple spaces in a row.");
      }

      if (preg_match('/[^\x{80}-\x{F7} a-z0-9@+_.\'-]/i', $userName) === 1 ||
        preg_match(
          // Non-printable ISO-8859-1 + NBSP
          '/[\x{80}-\x{A0}' .
          // Soft-hyphen
          '\x{AD}' .
          // Various space characters
          '\x{2000}-\x{200F}' .
          // Bidirectional text overrides
          '\x{2028}-\x{202F}' .
          // Various text hinting characters
          '\x{205F}-\x{206F}' .
          // Byte order mark
          '\x{FEFF}' .
          // Full-width latin
          '\x{FF01}-\x{FF60}' .
          // Replacement characters
          '\x{FFF9}-\x{FFFD}' .
          // NULL byte and control characters
          '\x{0}-\x{1F}]/u',
          $userName) === 1) {
        throw new \InvalidArgumentException(
          "Malformed username.\nThe username contains an illegal character.");
      }

      if (mb_strlen($userName) > 60) {
        throw new \InvalidArgumentException(
          "Malformed username.\nThe username is too long: it must be 60 characters or less.");
      }
    }

    if (mb_strlen($password) > 255) {
      throw new \InvalidArgumentException(
        "Malformed password.\nThe password is too long: it must be 255 characters or less.");
    }

    //
    // Verify server
    // -------------
    // If the server connection has not yet been verified, do so now.
    // We cannot log in without being sure that the host and port are
    // right and that a server is responding.
    //
    // Verification also checks the authentication types supported by the
    // server and selects the best one. We need this in order to login below.
    //
    // Verification also checks the serialization formats supported by the
    // server and selects the best one. We'll need this later when
    // communicating with the server.
    //
    // This call returns immediately if the server is already verified.
    //
    // This call throws an exception if the host name is bad or there
    // is some other problem communicating with the server, such as no
    // known authentication type or serialization format.
    $this->verifyServer();

    //
    // Log out
    // -------
    // If the user is already logged in, then log out first. After this,
    // the authentication status is guaranteed to be STATUS_NOT_LOGGED_IN.
    //
    // This call returns immediately if the user is not logged in.
    $this->logout();

    //
    // Save values
    // -----------
    // If the user name is empty, ignore the password too.
    $this->userName = $userName;
    $this->password = $password;
    if (empty($userName) === TRUE) {
      $this->password = '';
    }

    //
    // Skip logging in for anonymous
    // -----------------------------
    // If there is no user name, then there is no logging in. All accesses
    // are anonymous.
    if (empty($this->userName) === TRUE) {
      $this->authenticationStatus = self::STATUS_LOGGED_IN;
      $this->printVerbose("  Authentication skipped for anonymous access");
      return TRUE;
    }

    if (empty($userName) === TRUE) {
      $this->printVerbose("Logging in for user='$this->userName'");
    }

    //
    // Log in
    // ------
    // Use the authentication type determined during server verification.
    $this->printVerbose("  Logging in with " .
      $this->getAuthenticationTypeName($this->authenticationType));

    switch ($this->authenticationType) {
      case self::AUTHENTICATION_COOKIE:
        // Authentication uses a session cookie.
        //
        // When using cookie authentication, the user is logged in by sending
        // credentials now. On success, the server returns a session cookie
        // that is used for further requests.
        try {
          $this->loginForCookie();
          $this->authenticationStatus = self::STATUS_LOGGED_IN;
          $this->printVerbose("  Authentication succeeded");
        }
        catch (\Exception $e) {
          $this->authenticationStatus = self::STATUS_FAILED;
          $this->printVerbose("  Authentication failed");
          throw $e;
        }
        return TRUE;

      case self::AUTHENTICATION_BASIC:
        // Authentication is on every request.
        //
        // When using basic authentication, the user is logged in separately
        // on every request. There is no explicit login process. To verify
        // the user name and password are valid, we need to make a request.
        //
        // If there is no user name, then all accesses are anonymous and
        // there is no need to verify credentials.
        try {
          $this->getVersion();
          $this->authenticationStatus = self::STATUS_LOGGED_IN;
          $this->printVerbose("  Authentication succeeded");
        }
        catch (\Exception $e) {
          $this->authenticationStatus = self::STATUS_FAILED;
          $this->printVerbose("  Authentication failed");
          $message = <<<'EOS'
The login to the host has failed.
The user name and/or password may be incorrect. Please check them for typos. If they appear correct, it is also possible that the account has been blocked. If the account is new, it may not yet have been activated. Please contact the host's administrator.
EOS;
          $this->printVerbose("  $message");
          throw new \RuntimeException($message);
        }
        return TRUE;

      default:
        // Unknown authentication method.
        $this->authenticationStatus = self::STATUS_FAILED;
        $this->printVerbose("  Authentication failed");
        $message = <<<'EOS'
The login to the host has failed.
The host uses an unknown authentication method.
EOS;
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }
  }

  /**
   * Logs in using cookie authentication.
   *
   * The current credentials are used to log in and request a session
   * cookie, which is automatically saved for further use within CURL.
   * A successful login also returns and saves the CSRF token and a
   * logout token.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such as with a bad host name.
   *   - The host does not support the operation.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The arguments are malformed.
   *   - The arguments are invalid, such as for non-existent items.
   *
   * @see ::login()
   */
  private function loginForCookie() {
    //
    // Create headers
    // --------------
    // The headers specify that post fields are in JSON format.
    $headers = [];
    $headers[] = 'Content-Type: application/json';

    $postFields = [
      'name' => $this->userName,
      'pass' => $this->password,
    ];

    $postText = json_encode($postFields);

    //
    // Create URL
    // ----------
    // The POST URL includes:
    // - The host name.
    // - The post web services path.
    // - The return syntax.
    $url = $this->getHostNameAndPortNumber() . self::URL_USER_LOGIN . '?_format=json';

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    //
    // Setting COOKIELIST to "ALL" clears all prior cookies.
    //
    // Setting COOKIEFILE to "" causes CURL to maintain cookies in memory
    // instead of in a file.
    $options = $this->getCommonCurlOptions(FALSE);

    $options[CURLOPT_URL]        = $url;
    $options[CURLOPT_POST]       = 1;
    $options[CURLOPT_POSTFIELDS] = $postText;
    $options[CURLOPT_COOKIELIST] = "ALL";
    $options[CURLOPT_COOKIEFILE] = "";
    $options[CURLOPT_HTTPHEADER] = $headers;

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue POST
    // ----------
    // Issue an HTTP POST to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_RESPONSE_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    // Decode JSON content.
    if (empty($content) === FALSE) {
      $content = json_decode($content, TRUE);
    }

    switch ($httpCode) {
      case 200:
        // OK. The request succeeded. Continue.
        break;

      case 400:
        // Drupal's UserAuthenticationController checks the incoming
        // credentials and responds with any of several possible errors.
        // Unfortunately, they all come back as a generic HTTP 400 error
        // for a "Bad request":
        // - Missing credentials.
        // - Missing credentials.name.
        // - Missing credentials.pass.
        // - User account has not been activated or is blocked.
        // - Sorry, unrecognized username or password.
        //
        // The first three are not possible because we created and passed
        // the POST fields above.
        //
        // The latter two errors are important and should have been 401 errors.
        if (isset($content['message']) === TRUE) {
          // Use the message returned by Drupal, as bad as it is.
          $message = $content['message'];
          mb_ereg_search_init($message);
          if (mb_ereg_search('blocked') === TRUE) {
            // Replace the message with something friendlier.
            $message = <<<'EOS'
The login to the host has failed.
The account may have been blocked. If the account is new, it may not yet have been activated. Please contact the host's administrator.
EOS;
          }
          elseif (mb_ereg_search('unrecognized') === TRUE) {
            $message = <<<'EOS'
The login to the host has failed.
The user name and/or password may be incorrect. Please check them for typos.
EOS;
          }
        }
        else {
          $message = <<<'EOS'
The login to the host has failed.
The user name and/or password may be incorrect. Please check them for typos. If they appear correct, it is also possible that the account has been blocked. If the account is new, it may not yet have been activated. Please contact the host's administrator.
EOS;
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);

      case 429:
        // Drupal's UserAuthenticationController checks for rapid failed
        // login requests and, after a limit, blocks the account for the
        // requestor's IP address.
        //
        // Fall thru to the 'default' HTTP code handling.
        //
      default:
        if (isset($content['message']) === TRUE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }

    //
    // Parse content
    // -------------
    // The returned content is an associative array of the form:
    // @code
    // [
    //   "current_user" => [
    //     "uid" => 1234,
    //     "roles" => [
    //       "authenticated",
    //       "administrator",
    //       ...
    //     ],
    //     "name" => "myname",
    //   ],
    //   "csrf_token" => "token",
    //   "logout_token" => "token",
    // ]
    // @endcode
    //
    // The "name" we already know since we provided it in the first place.
    // The user ID and roles are irrelevant here.
    //
    // Get and save the CSRF and logout tokens. The CSRF token must be
    // sent to the server on all requests that change content (i.e.
    // POST, PATCH, and DELETE). The logout token must sent to the server
    // to formally log out.
    if (isset($content['csrf_token']) === TRUE) {
      $this->csrfToken = $content['csrf_token'];
    }

    if (isset($content['logout_token']) === TRUE) {
      $this->logoutToken = $content['logout_token'];
    }
  }

  /**
   * Logs the user out of the server.
   *
   * If the user is not logged in, this method has no effect.
   *
   * If the user is logged in, they are logged out and their authentication
   * credentials cleared. Further requests to the server will not provide
   * authentication credentials. These requests may succeed if the server
   * allows unauthenticated access, but they will fail if the user needs
   * to be logged in.
   *
   * @see ::login()
   * @see ::isLoggedIn()
   */
  public function logout() {
    //
    // Logout
    // ------
    // If the server hasn't been verified yet, then we're already logged out.
    // If the user is logged in, log them out.
    if ($this->serverVerified === FALSE) {
      return;
    }

    if ($this->authenticationStatus === self::STATUS_LOGGED_IN) {
      switch ($this->authenticationType) {
        default:
        case self::AUTHENTICATION_BASIC:
          // No logout required.
          break;

        case self::AUTHENTICATION_COOKIE:
          // Logout with the logout token.
          $this->printVerbose("Logging out");
          try {
            $this->logoutForCookie();
          }
          catch (\Exception $e) {
            // Ignore exceptions.
          }

          $this->printVerbose("  Logged out");
          break;
      }
    }

    //
    // Reset
    // -----
    // Clear the authentication status, authentication type, user name,
    // and password.
    $this->authenticationStatus = self::STATUS_NOT_LOGGED_IN;
    $this->userName             = '';
    $this->password             = '';
    $this->logoutToken          = '';
  }

  /**
   * Logs out using cookie authentication.
   *
   * The logout token, if any, is used to log out the user.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such as with a bad host name.
   *   - The host does not support the operation.
   *   - The host refuses contact, such as with bad authentication credentials.
   *
   * @see ::logout()
   */
  private function logoutForCookie() {
    //
    // Validate
    // --------
    // If there is no saved logout token from a prior login, then there
    // is no need to logout.
    if (empty($this->logoutToken) === TRUE) {
      return;
    }

    //
    // Create URL
    // ----------
    // The POST URL includes:
    // - The host name.
    // - The post logout path.
    // - The return syntax.
    // - The logout token.
    $url = $this->getHostNameAndPortNumber() . self::URL_USER_LOGOUT .
      '?' . $this->getSerializationUrlQuery() .
      '&token=' . $this->logoutToken;

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    $options = $this->getCommonCurlOptions(FALSE);

    $options[CURLOPT_URL]        = $url;
    $options[CURLOPT_POST]       = 1;
    $options[CURLOPT_POSTFIELDS] = '';

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue POST
    // ----------
    // Issue an HTTP POST to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_RESPONSE_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    // Decode JSON content.
    if (empty($content) === FALSE) {
      $content = json_decode($content, TRUE);
    }

    // Check for error codes. The following are standard HTTP success codes:
    // - 200 = OK.
    // - 201 = Created.
    // - 202 = Accepted.
    // - 203 = Non-authoritative information.
    // - 204 = No content.
    // - 205 = Reset content.
    // - 206 = Partial content.
    // - 207 = Multi-status.
    // - 208 = Already reported.
    //
    // A POST to log out should always succeed and not return anything.
    //
    // All other standard success codes are unacceptable.
    switch ($httpCode) {
      case 200:
      case 204:
        return;

      default:
        if (isset($content['message']) === TRUE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }
  }

  /*--------------------------------------------------------------------
   *
   * Issue requests.
   *
   * These methods issue HTTP requests for raw data or to trigger operations.
   * Other methods parse that data and return it.
   *
   *--------------------------------------------------------------------*/

  /**
   * Issues a GET request.
   *
   * GET requests are used to retrieve information from the server.  The
   * type of information varies with the operation choice:
   * - Single entity requests:
   *   - 'get-entity' returns an entity.
   *   - 'get-parent' returns an entity's parent entity.
   *   - 'get-root' returns an entity's root entity.
   * - Special entity information requests:
   *   - 'get-sharing' returns an entity's sharing settings.
   * - Entity list requests:
   *   - 'get-ancestors' returns a list of an entity's ancestor entities.
   *   - 'get-descendants' returns a list of an entity's descendant entities.
   *   - 'get-search' returns a search through an entity's subtree.
   * - Configuration and misc data requests:
   *   - 'get-configuration' returns site and module settings.
   *   - 'get-usage' returns module usage stats for the user.
   *   - 'get-version' returns version numbers for site software.
   *
   * GET requests focused on an entity (get the entity, parent, root,
   * ancestors, or descendants) require a full folder path or a numeric
   * entity ID to indicate the entity.
   *
   * @param string $operation
   *   The name of the requested operation (e.g. "get-entity").
   * @param int|string $entityIdOrUri
   *   The numeric entity ID or string path for a remote file or folder.
   *   Some operations do not use this value.
   *
   * @return mixed
   *   Returns a variety of content types depending upon the operation.
   *   In most cases, the content returned is an array.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The arguments are malformed.
   *   - The arguments are invalid, such as for non-existent items.
   */
  protected function httpGet(string $operation, $entityIdOrUri) {
    //
    // Initialize
    // ----------
    // Check if HTTP GET is supported. This may issue a connection to the
    // server to find out. If that fails, an exception is thrown.
    if ($this->serverVerified === TRUE) {
      if ($this->isHttpGetSupported() === FALSE) {
        throw new \RuntimeException("The operation cannot be completed.\nThe host does not support requests to get content.");
      }
    }

    //
    // Create headers
    // --------------
    // The headers specify the GET operation and the source path, if any.
    $headers = [];

    // Set the operation.
    $headers[] = 'X-FolderShare-Get-Operation: ' . $operation;

    // Request the returned data in a specific format.
    $headers[] = 'X-FolderShare-Return-Format: ' . $this->format;

    // Set the source path if an entity ID is not used.
    if (is_numeric($entityIdOrUri) === TRUE) {
      $entityId = intval($entityIdOrUri);
    }
    else {
      // Make sure the path is safe. HTTP headers primarily support ASCII,
      // while paths may include multi-byte characters. Use URL encoding
      // to add them to the header.
      $entityId = 0;
      $headers[] = 'X-FolderShare-Source-Path: ' . rawurlencode($entityIdOrUri);
    }

    //
    // Create URL
    // ----------
    // The GET URL includes:
    // - The host name.
    // - The web services path.
    // - The entity ID (even if one is not used).
    // - The serialization format.
    $url = $this->getHostNameAndPortNumber() . self::URL_GET .
      '/' . $entityId .
      '?' . $this->getSerializationUrlQuery();

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    //
    // Authentication settings should be included for most operations.
    //
    // A CSRF token is not required.
    $this->printVerbose("Issuing GET for $operation");
    $options = $this->getCommonCurlOptions(TRUE);

    $options[CURLOPT_URL]        = $url;
    $options[CURLOPT_HTTPGET]    = TRUE;
    $options[CURLOPT_HTTPHEADER] = $headers;

    if ($this->serverVerified === FALSE) {
      // This GET is the first one with a new server choice. Add an option
      // to clear all cookies.
      $options[CURLOPT_COOKIELIST] = "ALL";
    }

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue GET
    // ---------
    // Issue an HTTP GET to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_RESPONSE_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message, (-$errno));
    }

    // Decode JSON content.
    if (empty($content) === FALSE) {
      $content = json_decode($content, TRUE);
    }

    // Check for error codes. The following are standard HTTP success codes:
    // - 200 = OK.
    // - 201 = Created.
    // - 202 = Accepted.
    // - 203 = Non-authoritative information.
    // - 204 = No content.
    // - 205 = Reset content.
    // - 206 = Partial content.
    // - 207 = Multi-status.
    // - 208 = Already reported.
    // - 226 = IM used.
    //
    // A 200 is returned when there is content, and 204 when there isn't.
    // Both are OK.
    //
    // All other standard success codes are unacceptable.
    switch ($httpCode) {
      case 200:
        $this->printVerbose("  Request complete");
        return $content;

      case 204:
        $this->printVerbose("  Request complete");
        if (empty($content) === TRUE) {
          return NULL;
        }
        return $content;

      default:
        if (isset($content['message']) === TRUE &&
            empty($content['message']) === FALSE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message, $httpCode);
    }
  }

  /**
   * Deletes content on a web server.
   *
   * DELETE requests are used to delete a single entity, or a subtree,
   * based upon the operation choice:
   * - 'delete-file' deletes a single file.
   * - 'delete-folder' deletes a single empty folder.
   * - 'delete-folder-tree' deletes a single folder recursively.
   * - 'delete-file-or-folder' deletes a single file or empty folder.
   * - 'delete-file-or-folder-tree' deletes anything recursively.
   *
   * DELETE requests require a full folder path or a numeric entity ID
   * to indicate the entity to delete.
   *
   * DELETE requests do not return content. On an error, an exception
   * is thrown.
   *
   * @param string $operation
   *   The name of the requested operation (e.g. "delete-file").
   * @param int|string $entityIdOrUri
   *   Some operations do not use this value.
   *   The numeric entity ID or string path for a remote file or folder.
   *
   * @return mixed
   *   Always empty.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The arguments are malformed.
   *   - The arguments are invalid, such as for non-existent items.
   */
  protected function httpDelete(string $operation, $entityIdOrUri) {
    //
    // Initialize
    // ----------
    // Check if HTTP DELETE is supported. This may issue a connection to the
    // server to find out. If that fails, an exception is thrown.
    if ($this->isHttpDeleteSupported() === FALSE) {
      throw new \RuntimeException("The operation cannot be completed.\nThe host does not support requests to delete content.");
    }

    //
    // Create headers
    // --------------
    // The headers specify the DELETE operation and the source path.
    // There is no return format header because DELETE never returns
    // anything except success or error codes.
    $headers = [];

    // Set the operation.
    $headers[] = 'X-FolderShare-Delete-Operation: ' . $operation;

    // Get the CSRF token. This may trigger a GET request to the server.
    // If that fails, an exception is thrown.
    $headers[] = 'X-CSRF-Token: ' . $this->getCsrfToken();

    // Set the source path if an entity ID is not used.
    if (is_numeric($entityIdOrUri) === TRUE) {
      $entityId = intval($entityIdOrUri);
    }
    else {
      // Make sure the path is safe. HTTP headers primarily support ASCII,
      // while paths may include multi-byte characters. Use URL encoding
      // to add them to the header.
      $entityId = -1;
      $headers[] = 'X-FolderShare-Source-Path: ' . rawurlencode($entityIdOrUri);
    }

    //
    // Create URL
    // ----------
    // The DELETE URL includes:
    // - The host name.
    // - The web services path.
    // - The serialization format.
    // - An optional entity ID.
    if ($entityId === (-1)) {
      $url = $this->getHostNameAndPortNumber() . self::URL_DELETE .
        '/?' . $this->getSerializationUrlQuery();
    }
    else {
      $url = $this->getHostNameAndPortNumber() . self::URL_DELETE .
        '?' . $this->getSerializationUrlQuery() .
        '&id=' . $entityId;
    }

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    //
    // Authentication settings should be included for most operations.
    //
    // A CSRF token is required.
    $this->printVerbose("Issuing DELETE for $operation");
    $options = $this->getCommonCurlOptions(TRUE);

    $options[CURLOPT_URL]           = $url;
    $options[CURLOPT_CUSTOMREQUEST] = 'DELETE';
    $options[CURLOPT_HTTPHEADER]    = $headers;

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue DELETE
    // ------------
    // Issue an HTTP DELETE to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_RESPONSE_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    // Decode JSON content.
    if (empty($content) === FALSE) {
      $content = json_decode($content, TRUE);
    }

    // Check for error codes. The following are standard HTTP success codes:
    // - 200 = OK.
    // - 201 = Created.
    // - 202 = Accepted.
    // - 203 = Non-authoritative information.
    // - 204 = No content.
    // - 205 = Reset content.
    // - 206 = Partial content.
    // - 207 = Multi-status.
    // - 208 = Already reported.
    // - 226 = IM used.
    //
    // Since a DELETE never returns anything, only a 204 is valid.
    //
    // All other standard success codes are unacceptable.
    switch ($httpCode) {
      case 204:
        $this->printVerbose("  Request complete");
        if (empty($content) === TRUE) {
          return NULL;
        }
        return $content;

      default:
        if (isset($content['message']) === TRUE &&
            empty($content['message']) === FALSE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }
  }

  /**
   * Posts new content to the web server.
   *
   * POST requests are used to create a single entity based upon the
   * operation choice:
   * - 'new-rootfolder' creates a new root folder.
   * - 'new-folder' creates a new subfolder.
   * - 'new-file' creates a new file.
   * - 'new-media' creates a new media item.
   *
   * POST requests never support a numeric entity ID since the operation
   * is creating an entity. The $path argument selects the location in
   * which to create the new entity.
   *
   * @param string $operation
   *   The name of the requested operation.
   * @param string $path
   *   The path to a remote parent folder into which to place a new entity.
   * @param string $name
   *   The name of the new item being created.
   * @param string $localPath
   *   (optional, default = '') The path to a local file to upload as an
   *   attachment to the POST.
   * @param bool $modified
   *   (optional, default = (-1)) When not (-1), the newly created item's
   *   last modification time is set to the given value.
   *
   * @return mixed
   *   Returns a variety of content types depending upon the operation.
   *   In most cases, the content returned is an array.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The arguments are malformed.
   *   - The arguments are invalid, such as for non-existent items.
   */
  protected function httpPost(
    string $operation,
    string $path,
    string $name,
    string $localPath = '',
    int $modified = (-1)) {

    //
    // Initialize
    // ----------
    // Check if HTTP POST is supported. This may issue a connection to the
    // server to find out. If that fails, an exception is thrown.
    if ($this->isHttpPostSupported() === FALSE) {
      throw new \RuntimeException(
        "The operation cannot be completed.\nThe host does not support requests to create or upload new content.");
    }

    //
    // Create headers
    // --------------
    // The headers specify the POST operation and the destination path.
    $headers = [];

    // Set the operation.
    $headers[] = 'X-FolderShare-Post-Operation: ' . $operation;

    // Get the CSRF token. This may trigger a GET request to the server.
    // If that fails, an exception is thrown.
    $headers[] = 'X-CSRF-Token: ' . $this->getCsrfToken();

    // Make sure the path is safe. HTTP headers primarily support ASCII,
    // while paths may include multi-byte characters. Use URL encoding
    // to add them to the header.
    $headers[] = 'X-FolderShare-Destination-Path: ' . rawurlencode($path);

    // Set the content disposition, which gives the name of the item
    // to be created, whether it is a folder or a file.
    $headers[] = 'Content-Disposition: attachment; filename="' . $name . '"';

    // Set the content type, which is always a binary data stream. For
    // new folders, this stream is empty. For uploaded files, this is the
    // raw byte stream for the file.
    $headers[] = "Content-Type: application/octet-stream";

    // When preserving timestamps, send the local path's last modified time.
    // Technically, the "Last-Modified" header is intended as an HTTP response,
    // not a request, but it has the right meaning here so we use it.
    if ($modified >= 0) {
      // The timestamp in the header must be formatted in a specific
      // OS-independent way so that it can be used on the server without
      // knowing what the client's OS and time epoch conventions are.
      $oldTimezone = date_default_timezone_get();
      date_default_timezone_set('GMT');
      $modifiedString = date('D, d M Y H:i:s e', $modified);
      date_default_timezone_set($oldTimezone);
      $headers[] = "Last-Modified: $modifiedString";
    }

    //
    // Create URL
    // ----------
    // The POST URL includes:
    // - The host name.
    // - The post web services path.
    // - The return syntax.
    $url = $this->getHostNameAndPortNumber() . self::URL_POST .
      '?' . $this->getSerializationUrlQuery();

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    //
    // Authentication settings should be included for most operations.
    //
    // A CSRF token is required.
    //
    // The POST needs the file to attach, if given.
    $this->printVerbose("Issuing POST for $operation");
    $options = $this->getCommonCurlOptions(TRUE);

    $options[CURLOPT_URL]         = $url;
    $options[CURLOPT_SAFE_UPLOAD] = TRUE;
    $options[CURLOPT_HTTPHEADER]  = $headers;
    $options[CURLOPT_POST]        = TRUE;
    $options[CURLOPT_POSTFIELDS]  = '';

    if (empty($localPath) === FALSE) {
      // A local file path has been given for a file to upload.
      //
      // WARNING: This reads the entire local file into a byte array and
      // assigns it into the CURL options. If the file is large, this will
      // require a lot of memory.
      $options[CURLOPT_POSTFIELDS] = file_get_contents($localPath);

      // Disable the timeout for the file transfer.
      $options[CURLOPT_TIMEOUT] = 0;
    }

    // For uploads, use a maximum send buffer size.
    if (defined('CURLOPT_UPLOAD_BUFFERSIZE') === TRUE) {
      // 2Mbytes is the documented maximum supported by the CURL library.
      // There is no defined constant for it.
      $options[CURLOPT_UPLOAD_BUFFERSIZE] = 2000000;
    }

    // If verbosity is requested, nominate a progress callback to report
    // bytes downloaded so far.
    if (empty($localPath) === FALSE &&
        $this->progress === TRUE) {
      $options[CURLOPT_NOPROGRESS]       = FALSE;
      $options[CURLOPT_PROGRESSFUNCTION] = [
        $this,
        'uploadProgressCallback',
      ];
      $this->progressState = self::PROGRESS_START;
      $this->progressHighestTarget = 0;
      $this->progressPercentage = 0;
    }

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue POST
    // ----------
    // Issue an HTTP POST to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_RESPONSE_CODE);
    $errno    = curl_errno($this->curlSession);

    unset($options);

    if ($this->progress === TRUE) {
      fwrite(STDERR, "\n");
    }

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    // Decode JSON content.
    if (empty($content) === FALSE) {
      $content = json_decode($content, TRUE);
    }

    // Check for error codes. The following are standard HTTP success codes:
    // - 200 = OK.
    // - 201 = Created.
    // - 202 = Accepted.
    // - 203 = Non-authoritative information.
    // - 204 = No content.
    // - 205 = Reset content.
    // - 206 = Partial content.
    // - 207 = Multi-status.
    // - 208 = Already reported.
    // - 226 = IM used.
    //
    // A POST always creates content, so all successful requests return 201.
    //
    // All other standard success codes are unacceptable.
    switch ($httpCode) {
      case 201:
        $this->printVerbose("  Request complete");
        if (empty($content) === TRUE) {
          return NULL;
        }
        return $content;

      default:
        if (isset($content['message']) === TRUE &&
            empty($content['message']) === FALSE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }
  }

  /**
   * Responds to a progress callback during a file upload.
   *
   * This method is called repeatedly while uploading (posting) a file.
   * Each call passes information on the upload progress. This is used
   * to keep track of the start and end of an upload and output
   * a progress message.
   *
   * This callback is only invoked if progress message output has been
   * enabled.
   *
   * @param resource $resource
   *   The file resource.
   * @param int $downloadTarget
   *   Unused.
   * @param int $downloadSoFar
   *   Unused.
   * @param int $uploadTarget
   *   The target number of bytes to upload.
   * @param int $uploadSoFar
   *   The number of bytes uploaded so far.
   *
   * @return int
   *   Always returns 0.
   *
   * @see ::httpPost()
   * @see ::upload()
   * @see ::isProgress()
   * @see ::setProgress()
   */
  private function uploadProgressCallback(
    $resource,
    $downloadTarget,
    $downloadSoFar,
    $uploadTarget,
    $uploadSoFar) {

    // See comments on CURL quirks in downloadProgressCallback(). Testing
    // has NOT found similar quirks with uploads to SSL sites. Nevertheless,
    // we do similar checks here.
    if (empty($this->uploadLocalPath) === TRUE) {
      // Malformed progress setup. Nothing to report.
      return 0;
    }

    $uploadTarget = (int) $uploadTarget;
    $uploadSoFar  = (int) $uploadSoFar;

    if ($uploadTarget <= 0) {
      // Invalid upload target. This may be the start or end SSL handshake.
      return 0;
    }

    if ($uploadTarget < $this->progressHighestTarget) {
      // Post-file transfer progress. This may be from a final SSL handshake.
      return 0;
    }

    if ($uploadTarget > $this->progressHighestTarget) {
      // Actual file transfer after start SSL handshake. Record the target
      // and resume progress output.
      $this->progressHighestTarget = $uploadTarget;
      $this->progressState = self::PROGRESS_CONTINUE;
      $this->progressPercentage = 0;
    }

    if ($this->progressState == self::PROGRESS_END) {
      // After last progress message when the transfer appears to be done.
      return 0;
    }

    $percentage  = (int) (($uploadSoFar / $this->progressHighestTarget) * 100.0);
    if ($percentage !== $this->progressPercentage) {
      // Only report an update if the percentage has changed.
      $filename = $this->uploadLocalPath;
      $bytesSoFar = FolderShareFormat::formatBytes(
        $uploadSoFar,
        1000,
        FALSE,
        0);
      $bytesTarget = FolderShareFormat::formatBytes(
        $this->progressHighestTarget,
        1000,
        FALSE,
        0);
      $percentageFmt = number_format($percentage, 0);

      fwrite(STDERR, "\x0D  $filename: $bytesSoFar/$bytesTarget ($percentageFmt%)  ");

      $this->progressPercentage = $percentage;
    }

    if ($uploadSoFar == $this->progressHighestTarget) {
      // End of transfer. Further progress messages are not needed. However,
      // this could just be the end of a starting SSL handshake.
      $this->progressState = self::PROGRESS_END;
    }
    else {
      // Continuing transfer. Future messages should be output.
      $this->progressState = self::PROGRESS_CONTINUE;
    }

    return 0;
  }

  /**
   * Updates content on the web server.
   *
   * PATCH requests are used to update a single entity based upon the
   * operation choice:
   * - 'update-entity' changes one or more entity fields.
   * - 'update-sharing' changes an entity's sharing settings.
   * - 'move-overwrite' moves/renames an entity, optionally overwriting.
   * - 'move-no-overwrite' moves/renames an entity without overwriting.
   *
   * PATCH requests require a full folder path or a numeric entity ID
   * to indicate the entity to delete.
   *
   * @param string $operation
   *   The name of the requested operation.
   * @param int|string $entityIdOrUri
   *   The numeric entity ID or string path for a remote file or folder.
   * @param string $destinationPath
   *   (optional, default = "") The string path for the remote destination
   *   on move and copy operations. Other operations do not use this value.
   * @param string $userName
   *   (optional, default = "") The user name or ID.
   * @param array $postFields
   *   (optional, default = []) The post fields in 'full' entity format
   *   for operations that need additional values.
   *
   * @return mixed
   *   Returns a variety of content types depending upon the operation.
   *   In most cases, the content returned is an array.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The arguments are malformed.
   *   - The arguments are invalid, such as for non-existent items.
   */
  protected function httpPatch(
    string $operation,
    string $entityIdOrUri = '',
    string $destinationPath = '',
    string $userName = '',
    array $postFields = []) {

    //
    // Initialize
    // ----------
    // Check if HTTP POST is supported. This may issue a connection to the
    // server to find out. If that fails, an exception is thrown.
    if ($this->isHttpPostSupported() === FALSE) {
      throw new \RuntimeException("The operation cannot be completed.\nThe host does not support requests to create or upload new content.");
    }

    //
    // Create headers
    // --------------
    // The headers specify the POST operation and the source path, if any.
    $headers = [];

    // Set the operation.
    $headers[] = 'X-FolderShare-Patch-Operation: ' . $operation;

    // Get the CSRF token. This may trigger a GET request to the server.
    // If that fails, an exception is thrown.
    $headers[] = 'X-CSRF-Token: ' . $this->getCsrfToken();

    // Set the source path if an entity ID is not used.
    if (is_numeric($entityIdOrUri) === TRUE) {
      $entityId = intval($entityIdOrUri);
    }
    else {
      // Make sure the path is safe. HTTP headers primarily support ASCII,
      // while paths may include multi-byte characters. Use URL encoding
      // to add them to the header.
      $entityId = -1;
      $headers[] = 'X-FolderShare-Source-Path: ' . rawurlencode($entityIdOrUri);
    }

    // Set the destination path, if any.
    if (empty($destinationPath) === FALSE) {
      $headers[] = 'X-FolderShare-Destination-Path: ' . rawurlencode($destinationPath);
    }

    // Set the user name, if any.
    if (empty($userName) === FALSE) {
      $headers[] = 'X-FolderShare-User: ' . rawurlencode($userName);
    }

    // POST fields are serialized as JSON.
    $headers[] = 'Content-Type: application/json';

    // Request the returned data in a specific format.
    $headers[] = 'X-FolderShare-Return-Format: ' . $this->format;

    // Process post fields, if provided.
    if (empty($postFields) === TRUE) {
      $postFields = $this->createDummyEntity();
    }

    $postText = json_encode($postFields);

    //
    // Create URL
    // ----------
    // The PATCH URL includes:
    // - The host name.
    // - The canonical web services path.
    // - The serialization format.
    // - The entity ID (if any).
    if ($entityId === (-1)) {
      $url = $this->getHostNameAndPortNumber() . self::URL_PATCH .
        '/?' . $this->getSerializationUrlQuery();
    }
    else {
      $url = $this->getHostNameAndPortNumber() . self::URL_PATCH .
        '?' . $this->getSerializationUrlQuery() .
        '&id=' . $entityId;
    }

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    //
    // Authentication settings should be included for most operations.
    //
    // A CSRF token is required.
    $this->printVerbose("Issuing PATCH for $operation");
    $options = $this->getCommonCurlOptions(TRUE);

    $options[CURLOPT_URL]           = $url;
    $options[CURLOPT_CUSTOMREQUEST] = 'PATCH';
    $options[CURLOPT_SAFE_UPLOAD]   = TRUE;
    $options[CURLOPT_POSTFIELDS]    = $postText;
    $options[CURLOPT_HTTPHEADER]    = $headers;

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue PATCH
    // -----------
    // Issue an HTTP PATCH to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_RESPONSE_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    // Decode JSON content.
    if (empty($content) === FALSE) {
      $content = json_decode($content, TRUE);
    }

    // Check for error codes. The following are standard HTTP success codes:
    // - 200 = OK.
    // - 201 = Created.
    // - 202 = Accepted.
    // - 203 = Non-authoritative information.
    // - 204 = No content.
    // - 205 = Reset content.
    // - 206 = Partial content.
    // - 207 = Multi-status.
    // - 208 = Already reported.
    // - 226 = IM used.
    //
    // A PATCH may modify or create content, so 200 and 201 are acceptable.
    //
    // All other standard success codes are unacceptable.
    switch ($httpCode) {
      case 200:
        $this->printVerbose("  Request complete");
        return $content;

      case 201:
        $this->printVerbose("  Request complete");
        if (empty($content) === TRUE) {
          return NULL;
        }
        return $content;

      default:
        if (isset($content['message']) === TRUE &&
            empty($content['message']) === FALSE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }
  }

  /*--------------------------------------------------------------------
   *
   * GET requests.
   *
   * These methods issue low-level HTTP GET requests and return
   * appropriate structured content.
   *
   *--------------------------------------------------------------------*/

  /**
   * Gets information about a file or folder.
   *
   * An array is returned that describes the item.
   *
   * The format of the returned content depends upon the currently selected
   * return format. The content includes mandatory fields for each item,
   * including its name, creation and modified dates, MIME type, kind,
   * entity ID, and parent and root item IDs. The returned content may
   * include additional fields if they are not empty, including the item's
   * description, comments, etc.
   *
   * @param int|string $entityIdOrUri
   *   The numeric entity ID or string URI for a remote file or folder.
   * @param bool $recurse
   *   (optional, default = FALSE) When TRUE, the method recurses to return
   *   information about the entity and all its children, and their children.
   *
   * @return array
   *   Returns an array containing information about file or folder items.
   *   When $recurse is FALSE, the array describes a single entity. When
   *   $recurse is TRUE, the array has numeric indexes and describes a
   *   list of entities from recursion downward from the indicated item.
   *   The format of the information on each item depends upon the current
   *   return format.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the remote URI is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The remote URI is malformed.
   *   - The item does not exist.
   *   - The user does not have necessary permissions.
   *
   * @see ::download()
   */
  public function getFileOrFolder($entityIdOrUri, bool $recurse = FALSE) {
    //
    // Validate
    // --------
    // The remote URI can be an integer entit ID or a string URI.
    // If the URI is a string, it cannot be empty. Further checking of
    // the URI, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrUri) === TRUE &&
        empty($entityIdOrUri) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    //
    // Get information on the starting entity
    // --------------------------------------
    // Get the entity.
    $entity = $this->httpGet("get-entity", $entityIdOrUri);

    // If recursion is not requested, return the entity.
    if ($recurse === FALSE) {
      return $entity;
    }

    // If the the entity is not a folder, return the entity.
    switch ($this->getReturnFormat()) {
      case 'keyvalue':
        if ($entity['kind'] !== 'folder') {
          return [$entity];
        }
        break;

      case 'full':
        if ($entity['kind'][0]['value'] !== 'folder') {
          return [$entity];
        }
        break;
    }

    //
    // Recurse
    // -------
    $results = [$entity];
    $pendingIds = [$entityIdOrUri];

    switch ($this->getReturnFormat()) {
      case 'keyvalue':
        while (empty($pendingIds) === FALSE) {
          $id = array_shift($pendingIds);

          // Get information on all descendants. Add folders to
          // the pending list.
          $descendants = $this->getDescendants($id);
          if (empty($descendants) === FALSE) {
            foreach ($descendants as $d) {
              $results[] = $d;
              if ($d['kind'] === 'folder') {
                $pendingIds[] = $d['id'];
              }
            }
          }
        }
        return $results;

      case 'full':
        while (empty($pendingIds) === FALSE) {
          $id = array_shift($pendingIds);

          // Get information on all descendants. Add folders to
          // the pending list.
          $descendants = $this->getDescendants($id);
          if (empty($descendants) === FALSE) {
            foreach ($descendants as $d) {
              $results[] = $d;
              if ($d['kind'][0]['value'] !== 'folder') {
                $pendingIds[] = $d['id'][0]['value'];
              }
            }
          }
        }
        return $results;

      default:
        return $results;
    }
  }

  /**
   * Gets information about a file or folder's parent folder.
   *
   * An array is returned that describes the item's parent folder.
   *
   * The format of the returned content depends upon the currently selected
   * return format. The content includes mandatory fields for each item,
   * including its name, creation and modified dates, MIME type, kind,
   * entity ID, and parent and root item IDs. The returned content may
   * include additional fields if they are not empty, including the item's
   * description, comments, etc.
   *
   * @param int|string $entityIdOrUri
   *   The numeric entity ID or string path for a remote file or folder
   *   for whome parent folder information is returned.
   *
   * @return array
   *   Returns an array of information describing the file or folder's
   *   parent folder. The format of the information depends upon the
   *   current return format.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The item does not exist.
   *   - The user does not have necessary permissions.
   *
   * @see ::download()
   * @see ::getRootItem()
   */
  public function getParentFolder($entityIdOrUri) {
    //
    // Validate
    // --------
    // If the path is a string, it cannot be empty. Further checking of
    // the path, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrUri) === TRUE &&
        empty($entityIdOrUri) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    //
    // Execute
    // -------
    // Issue the request.
    return $this->httpGet("get-parent", $entityIdOrUri);
  }

  /**
   * Gets information about a file or folder's top-level (root) folder.
   *
   * An array is returned that describes the item's top-level (root) folder.
   *
   * The format of the returned content depends upon the currently selected
   * return format. The content includes mandatory fields for each item,
   * including its name, creation and modified dates, MIME type, kind,
   * entity ID, and parent and root item IDs. The returned content may
   * include additional fields if they are not empty, including the item's
   * description, comments, etc.
   *
   * @param int|string $entityIdOrUri
   *   The numeric entity ID or string path for a remote file or folder
   *   for whome root item information is returned.
   *
   * @return array
   *   Returns an array of information describing the file or folder's
   *   root item. The format of the information depends upon the
   *   current return format.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The item does not exist.
   *   - The user does not have necessary permissions.
   *
   * @see ::download()
   * @see ::getParentFolder()
   * @see ::getRootItems()
   */
  public function getRootItem($entityIdOrUri) {
    //
    // Validate
    // --------
    // If the path is a string, it cannot be empty. Further checking of
    // the path, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrUri) === TRUE &&
        empty($entityIdOrUri) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    //
    // Execute
    // -------
    // Issue the request.
    return $this->httpGet("get-root", $entityIdOrUri);
  }

  /**
   * Gets a list of ancestor folders for a file or folder.
   *
   * An array is returned that contains a list of ancestors, ordered from
   * the top-level folder down to (but not including) the indicated item.
   *
   * The format of the returned content depends upon the currently selected
   * return format. The content includes mandatory fields for each item,
   * including its name, creation and modified dates, MIME type, kind,
   * entity ID, and parent and root item IDs. The returned content may
   * include additional fields if they are not empty, including the item's
   * description, comments, etc.
   *
   * @param int|string $entityIdOrUri
   *   The numeric entity ID or string path for a remote file or folder
   *   for whome ancestor information is returned.
   *
   * @return array
   *   Returns an array of information describing a list of the file or
   *   folder's ancestors. The format of the information depends upon
   *   the current return format.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The item does not exist.
   *   - The user does not have necessary permissions.
   *
   * @see ::download()
   */
  public function getAncestors($entityIdOrUri) {
    //
    // Validate
    // --------
    // If the path is a string, it cannot be empty. Further checking of
    // the path, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrUri) === TRUE &&
        empty($entityIdOrUri) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    //
    // Execute
    // -------
    // Issue the request.
    return $this->httpGet("get-ancestors", $entityIdOrUri);
  }

  /**
   * Gets a list of descendant (child) files and folders for a folder.
   *
   * An array is returned that contains a list of descendants, if any.
   * If the item is a file, there are no descendants.
   *
   * The format of the returned content depends upon the currently selected
   * return format. The content includes mandatory fields for each item,
   * including its name, creation and modified dates, MIME type, kind,
   * entity ID, and parent and root item IDs. The returned content may
   * include additional fields if they are not empty, including the item's
   * description, comments, etc.
   *
   * @param int|string $entityIdOrUri
   *   The numeric entity ID or string path for a remote file or folder
   *   for whome descendant (child) folder information is returned.
   *
   * @return array
   *   Returns an array of information describing a list of the item's
   *   descendants. The format of the information depends upon the current
   *   return format.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The item does not exist.
   *   - The user does not have necessary permissions.
   *
   * @see ::download()
   */
  public function getDescendants($entityIdOrUri) {
    //
    // Validate
    // --------
    // If the path is a string, it cannot be empty. Further checking of
    // the path, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrUri) === TRUE &&
        empty($entityIdOrUri) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    //
    // Execute
    // -------
    // Issue the request.
    return $this->httpGet("get-descendants", $entityIdOrUri);
  }

  /**
   * Gets a list of top-level items.
   *
   * An array is returned that contains a list of top-level items in
   * the selected "scheme". Recognized schemes include:
   *   - 'personal' returns the user's own top-level items and those shared
   *     with them.
   *   - 'public' returns all publically accessible top-level items.
   *
   * The format of the returned content depends upon the currently selected
   * return format. The content includes mandatory fields for each item,
   * including its name, creation and modified dates, MIME type, kind,
   * entity ID, and parent and root item IDs. The returned content may
   * include additional fields if they are not empty, including the item's
   * description, comments, etc.
   *
   * @param string $scheme
   *   (optional, default = 'personal') The 'personal' or 'public' scheme
   *   that indicates the root list to return.
   *
   * @return array
   *   Returns an array of information describing a list of root items.
   *   The format of the information depends upon the current return format.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the scheme is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   *   - The root item scheme is malformed.
   *   - The user's root item list is locked by another process.
   *
   * @see ::download()
   * @see ::getRootItem()
   */
  public function getRootItems(string $scheme = 'personal') {
    //
    // Validate
    // --------
    // The scheme cannot be empty. Further scheme checking is left to
    // the server.
    if (empty($scheme) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    //
    // Execute
    // -------
    // Issue the request.
    return $this->httpGet("get-descendants", $scheme . ':/');
  }

  /**
   * Get a report on the user's FolderShare usage.
   *
   * An associative array is returned where keys and values indicate the
   * current user's level of usage of the FolderShare virtual file system
   * on the server. The following keys are expected:
   * - 'nFolders' = the number of subfolders.
   * - 'nFiles' = the number of files.
   * - 'nBytes' = the amount of storage space used, in bytes.
   *
   * The returned array also includes the following keys:
   * - 'host' = the host name.
   * - 'user-id' = the numeric user ID of the authenticated user.
   * - 'user-account-name' = the text account name of the authenticated user.
   * - 'user-display-name' = the text display name of the authenticated user.
   *
   * There may be additional values, depending upon the site and the
   * software installed at the site.
   *
   * @return array
   *   Returns a key-value array describing the user's usage of the module.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   */
  public function getUsage() {
    //
    // Execute
    // -------
    // Issue the request.
    return $this->httpGet("get-usage", 0);
  }

  /**
   * Get a report on the server's software configuraiton.
   *
   * An associative array is returned where keys and values are for
   * server software parameters. The following keys are expected:
   *
   * - 'file-restrict-extensions' = TRUE or FALSE indicating if file name
   *   extension restrictions are enabled.
   *
   * - 'file-allowed-extensions' = a space-separated list of file name
   *   extensions checked, if extension restrictions are enabled.
   *
   * - 'sharing-allowed' = TRUE or FALSE indicating if folder sharing
   *   is enabled on the site.
   *
   * - 'sharing-allowed-with-anonymous' = TRUE or FALSE indicating if folder
   *   sharing with the "anonymous" user (the unauthenticated public) is
   *   enabled on the site.
   *
   * - 'serializer-formats' = a list of serialization formats configured
   *   for the method.
   *
   * - 'authentication-providers' = a list of authentication providers
   *   configured for the method.
   *
   * The returned array also includes the following keys:
   * - 'host' = the host name.
   *
   * There may be additional values, depending upon the site and the
   * software installed at the site.
   *
   * @return array
   *   Returns a key-value array of values describing the site and module
   *   configuration.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   *
   * @see ::getHttpVerbs()
   * @see ::getVersion()
   */
  public function getServerConfiguration() {
    //
    // Execute
    // -------
    // Issue the request.
    return $this->httpGet("get-configuration", 0);
  }

  /**
   * Get a report on software version numbers.
   *
   * An associative array is returned where keys are software items and
   * values are associative arrays that each have two keys and values:
   * - 'name' = the human-readable name of the item.
   * - 'version' = the version number of the item.
   *
   * If $doConnect is FALSE, the returned array only describes the client
   * side software. Otherwise a connection to the server is made and the
   * returned array describes both the client side and server side software.
   *
   * When a connection is made, the returned array also includes the
   * following keys:
   * - 'host' = the host name.
   *
   * @param bool $doConnect
   *   (optional, default = TRUE) When TRUE, the returned array includes
   *   client and server information. When FALSE, the array only includes
   *   client information and no communications with the server is done.
   *
   * @return array
   *   Returns a key-value array of software items and their names and
   *   version numbers.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   *
   * @see ::getServerConfiguration()
   */
  public function getVersion(bool $doConnect = TRUE) {
    //
    // Create API versions
    // -------------------
    // For non-connecting requests, the API's information is all that is
    // returned. For connecting requests, the API's information is prepended
    // to whatever the server returns.
    $curlVersion = curl_version();

    $clientVersions = [
      'client' => [
        'foldershareconnect' => [
          'name'    => 'FolderShareConnect client API',
          'version' => self::VERSION,
        ],
        'clientphp' => [
          'name'    => 'PHP',
          'version' => phpversion(),
        ],
        'curl'      => [
          'name'    => 'cURL library',
          'version' => $curlVersion['version'],
        ],
        'ssl'       => [
          'name'    => 'OpenSSL library',
          'version' => $curlVersion['ssl_version'],
        ],
        'libz'       => [
          'name'    => 'Z compression library',
          'version' => $curlVersion['libz_version'],
        ],
      ],
    ];

    //
    // Execute
    // -------
    // Issue the request.
    if ($doConnect === FALSE) {
      return $clientVersions;
    }

    return array_merge($clientVersions, $this->httpGet("get-version", 0));
  }

  /*--------------------------------------------------------------------
   *
   * DELETE requests.
   *
   *--------------------------------------------------------------------*/

  /**
   * Deletes a file.
   *
   * This request will delete any type of file, including data files,
   * image files, or media items.
   *
   * @param int|string $entityIdOrUri
   *   The numeric entity ID or string path for a remote file.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   *   - The item does not exist.
   *   - The item is not a file.
   *   - The item is locked by another process.
   *
   * @see ::deleteFileOrFolder()
   * @see ::deleteFolder()
   */
  public function deleteFile($entityIdOrUri) {
    //
    // Validate
    // --------
    // If the path is a string, it cannot be empty. Further checking of
    // the path, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrUri) === TRUE &&
        empty($entityIdOrUri) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    //
    // Execute
    // -------
    // Issue the request.
    $this->httpDelete("delete-file", $entityIdOrUri);
  }

  /**
   * Deletes a file or folder, optionally recursively.
   *
   * If the item indicated by the integer ID or path is a folder, and
   * $recurse is FALSE, the folder must be empty. If $recurse is TRUE,
   * non-empty folders will have their content deleted first, recursing
   * as necessary through subfolders.
   *
   * @param int|string $entityIdOrUri
   *   The numeric entity ID or string path for a remote file or folder.
   * @param bool $recurse
   *   (optional, default = FALSE) When TRUE, non-empty folders are deleted
   *   recursively, including any subfolders and their content. When FALSE,
   *   the operation only deletes files or empty folders.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   *   - The item does not exist.
   *   - The item is locked by another process.
   *
   * @see ::deleteFile()
   * @see ::deleteFolder()
   */
  public function deleteFileOrFolder($entityIdOrUri, bool $recurse = FALSE) {
    //
    // Validate
    // --------
    // If the path is a string, it cannot be empty. Further checking of
    // the path, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrUri) === TRUE &&
        empty($entityIdOrUri) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    //
    // Execute
    // -------
    // Issue the request.
    if ($recurse === TRUE) {
      $this->httpDelete("delete-file-or-folder-tree", $entityIdOrUri);
    }
    else {
      $this->httpDelete("delete-file-or-folder", $entityIdOrUri);
    }
  }

  /**
   * Deletes a folder, optionally recursively.
   *
   * The item indicated by an integer ID or a path must be a folder.
   * If $recurse is FALSE, the folder must be empty. If $recurse is TRUE,
   * non-empty folders will have their content deleted first, recursing
   * as necessary through subfolders.
   *
   * @param int|string $entityIdOrUri
   *   The numeric entity ID or string path for a remote folder.
   * @param bool $recurse
   *   (optional, default = FALSE) When TRUE, non-empty folders are deleted
   *   recursively, including any subfolders and their content. When FALSE,
   *   the operation only deletes empty folders.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   *   - The item does not exist.
   *   - The item is not a folder.
   *   - The item is locked by another process.
   *
   * @see ::deleteFile()
   * @see ::deleteFileOrFolder()
   */
  public function deleteFolder($entityIdOrUri, bool $recurse = FALSE) {
    //
    // Validate
    // --------
    // If the path is a string, it cannot be empty. Further checking of
    // the path, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrUri) === TRUE &&
        empty($entityIdOrUri) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    //
    // Execute
    // -------
    // Issue the request.
    if ($recurse === TRUE) {
      $this->httpDelete("delete-folder-tree", $entityIdOrUri);
    }
    else {
      $this->httpDelete("delete-folder", $entityIdOrUri);
    }
  }

  /*--------------------------------------------------------------------
   *
   * POST requests.
   *
   *--------------------------------------------------------------------*/

  /**
   * Creates a new top-level folder.
   *
   * A new top-level folder is created with the selected name in the
   * user's top-level folder list. An exception is thrown if the name
   * is already in use.
   *
   * @param string $name
   *   The name of the new top-level folder.
   * @param bool $modified
   *   (optional, default = (-1)) When not (-1), the newly created folder's
   *   last modification time is set to the given value.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the name is empty.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   *   - The top level folder list is locked by another process.
   *   - The name is malformed.
   *   - The new name would cause a collision.
   *
   * @see ::newFolder()
   */
  public function newRootFolder(
    string $name,
    int $modified = (-1)) {

    //
    // Validate
    // --------
    // The name cannot be empty. Checking that the name is well formed
    // must be done on the server.
    if (empty($name) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_FOLDER_NAME);
    }

    //
    // Execute
    // -------
    // Issue the request.
    $this->httpPost(
      "new-rootfolder",
      "/",
      $name,
      '',
      $modified);
  }

  /**
   * Creates a new folder in a parent folder.
   *
   * A new folder with the selected name is created in the parent folder.
   * An exception is thrown if the name is already in use.
   *
   * @param string $path
   *   The string path for a remote parent folder.
   * @param string $name
   *   The name of the new folder.
   * @param bool $modified
   *   (optional, default = (-1)) When not (-1), the newly created folder's
   *   last modification time is set to the given value.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path or name are empty.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The parent folder does not exist.
   *   - The user does not have necessary permissions.
   *   - The parent folder is locked by another process.
   *   - The name is malformed.
   *   - The new name would cause a collision.
   *
   * @see ::newRootFolder()
   */
  public function newFolder(
    string $path,
    string $name,
    int $modified = (-1)) {
    //
    // Validate
    // --------
    // The path and name cannot be empty. Checking that the path and name
    // are well formed, and that the path refers to an existing folder must be
    // done on the server.
    if (empty($path) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    if (empty($name) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_FOLDER_NAME);
    }

    //
    // Execute
    // -------
    // Issue the request.
    $this->httpPost(
      "new-folder",
      $path,
      $name,
      '',
      $modified);
  }

  /*--------------------------------------------------------------------
   *
   * PATCH requests.
   *
   *--------------------------------------------------------------------*/

  /**
   * Renames a file or folder.
   *
   * The file or folder is named without moving it. An exception is
   * thrown if the new name is already in use.
   *
   * @param string $path
   *   The string path for a remote file or folder.
   * @param string $name
   *   The new name for the item.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path or name are empty.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The item to rename does not exist.
   *   - The user does not have necessary permissions.
   *   - The item is locked by another process.
   *   - The name is malformed.
   *   - The rename would cause a collision.
   *
   * @see ::move()
   */
  public function rename(string $path, string $name) {
    //
    // Validate
    // --------
    // The path and name cannot be empty. Checking that the path and name
    // are well formed, and that the path refers to an existing item must be
    // done on the server.
    if (empty($path) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    if (empty($name) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_NAME);
    }

    //
    // Execute
    // -------
    // Issue the request.
    $this->httpPatch(
      "update-entity",
      $path,
      '',
      '',
      [
        'name' => [
          0 => [
            'value' => $name,
          ],
        ],
      ]);
  }

  /**
   * Updates a file or folder field.
   *
   * The value for the selected field in the file or folder is updated
   * to the new value. An exception is thrown if the field is not known
   * or the value is not valid.
   *
   * Only simple fields may be updated using this method.
   *
   * @param string $path
   *   The string path for a remote file or folder.
   * @param string $fieldName
   *   The name of a simple field in the file or folder.
   * @param string $fieldValue
   *   The new value for the field.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path or field name are empty.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The item to rename does not exist.
   *   - The user does not have necessary permissions.
   *   - The item is locked by another process.
   *   - The name is malformed.
   *   - The rename would cause a collision.
   *
   * @see ::rename()
   */
  public function update(string $path, string $fieldName, string $fieldValue) {
    //
    // Validate
    // --------
    // The path and field name cannot be empty. Checking that the path,
    // field name, and value are well formed, and that the path refers to an
    // existing item must be done on the server.
    if (empty($path) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    if (empty($fieldName) === TRUE) {
      throw new \InvalidArgumentException("Empty field name.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    $this->httpPatch(
      "update-entity",
      $path,
      '',
      '',
      [
        $fieldName => [
          0 => [
            'value' => $fieldValue,
          ],
        ],
      ]);
  }

  /**
   * Moves a file or folder to a new location.
   *
   * This method is modeled after the way the Linux/macOS/BSD "mv" command
   * operates. It supports moving an item, renaming an item in place, or
   * moving and renaming at the same time.
   *
   * The $fromPath must refer to an existing file or folder to be moved
   * and/or renamed.
   *
   * The $toPath may be one of:
   * - A "/" to refer to the top-level folder list.
   * - A path to an existing file or folder.
   * - A path to a non-existant item within an existing parent folder.
   *
   * If $toPath is "/", $fromPath must refer to a folder since files cannot be
   * moved into "/". The moved folder will have the same name as in $fromPath.
   * If there is already an item with the same name in "/", the move will
   * fail unless $overwrite is TRUE.
   *
   * If $toPath refers to a non-existant item, then the item referred to
   * by $fromPath will be moved into the $toPath's parent folder and
   * renamed to use the last name on $toPath. If $toPath's parent folder
   * is "/", then $fromPath must refer to a folder since files cannot be
   * moved into "/".
   *
   * If $toPath refers to an existing folder, the file or folder referred
   * to by $fromPath will be moved into the $toPath folder and retain its
   * current name. If there is already an item with that name in the
   * $toPath folder, the move will fail unless $overwrite is TRUE.
   *
   * If $toPath refers to an existing file, the move will fail unless
   * $overwrite is TRUE. If overwrite is allowed, the item referred to by
   * $fromPath will be moved into the $toPath item's parent folder and
   * renamed to have th last name in $toPath. If $toPath's parent folder
   * is "/", then $fromPath must refer to a folder since files cannot be
   * moved into "/".
   *
   * In any case where an overwrite is required, if $overwrite is FALSE
   * the operation will fail. Otherwise the item to overwrite will be
   * deleted before the move and/or rename takes place.
   *
   * The user must have permission to modify the item referred to by $fromPath.
   * They user must have permission to modify the folder into which the
   * item will be placed. When moving a folder to "/", the user must have
   * permission to create a new top-level folder. And when overwriting an
   * existing item, the user must have permission to delete that item.
   *
   * @param string $fromPath
   *   The string path for a remote file or folder to move.
   * @param string $toPath
   *   The string path to the remote parent folder to receive the moved item.
   *   Use "/" to move a folder to the root list.
   * @param bool $overwrite
   *   (optional, default = FALSE) When TRUE, a move of an item into a folder
   *   that already has an item of the same name will overwrite that item.
   *   When FALSE, an error is generated instead.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - Either path is malformed.
   *   - The item to move/rename does not exist.
   *   - The destination folder does not exist.
   *   - The item is the wrong type for the destination.
   *   - The user does not have necessary permissions.
   *   - One of the item's involved is locked by another process.
   *   - The move/rename would cause a collision, but $overwrite is FALSE.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if either path is empty.
   *
   * @see ::rename()
   */
  public function move(string $fromPath, string $toPath, bool $overwrite = TRUE) {
    //
    // Validate
    // --------
    // Neither path can be empty. Checking that the paths are well formed
    // and refer to appropriate entities must be done on the server.
    if (empty($fromPath) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    if (empty($toPath) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_DESTINATION_PATH);
    }

    //
    // Execute
    // -------
    // Issue the request.
    if ($overwrite === TRUE) {
      $this->httpPatch("move-overwrite", $fromPath, $toPath);
    }
    else {
      $this->httpPatch("move-no-overwrite", $fromPath, $toPath);
    }
  }

  /**
   * Copies a file or folder to a new location.
   *
   * This method is modeled after the way the Linux/macOS/BSD "cp" command
   * operates. It supports copying one or more items to a new destination.
   *
   * The $fromPath must refer to an existing file or folder to be copied
   * and optionally renamed.
   *
   * The $toPath may be one of:
   * - A "/" to refer to the top-level folder list.
   * - A path to an existing file or folder.
   * - A path to a non-existant item within an existing parent folder.
   *
   * If $toPath is "/", the copied item will have the same name as in
   * $fromPath. If there is already an item with the same name in "/",
   * the copy will fail unless $overwrite is TRUE.
   *
   * If $toPath refers to a non-existant item, then the item referred to
   * by $fromPath will be copied into the $toPath's parent folder and
   * renamed to use the last name on $toPath.
   *
   * If $toPath refers to an existing folder, the file or folder referred
   * to by $fromPath will be copied into the $toPath folder and retain its
   * current name. If there is already an item with that name in the
   * $toPath folder, the copy will fail unless $overwrite is TRUE.
   *
   * If $toPath refers to an existing file, the copy will fail unless
   * $overwrite is TRUE. If overwrite is allowed, the item referred to by
   * $fromPath will be copied into the $toPath item's parent folder and
   * renamed to have the last name in $toPath.
   *
   * In any case where an overwrite is required, if $overwrite is FALSE
   * the operation will fail. Otherwise the item to overwrite will be
   * deleted before the copy takes place.
   *
   * The user must have permission to view the item referred to by $fromPath.
   * They user must have permission to modify the folder into which the
   * item will be placed, and permission to create the new item there.
   * When copying a folder to "/", the user must have permission to create
   * a new top-level folder. And when overwriting an existing item, the
   * user must have permission to delete that item.
   *
   * @param string $fromPath
   *   The string path for a remote file or folder.
   * @param string $toPath
   *   The string path to the remote parent folder to receive the copied item.
   *   Use "/" to copy a folder to the root list.
   * @param bool $overwrite
   *   (optional, default = FALSE) When TRUE, a copy of an item into a folder
   *   that already has an item of the same name will overwrite that item.
   *   When FALSE, an error is generated instead.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - Either path is malformed.
   *   - The item to copy does not exist.
   *   - The destination folder does not exist.
   *   - The item is the wrong type for the destination.
   *   - The user does not have necessary permissions.
   *   - One of the item's involved is locked by another process.
   *   - The copy would cause a collision, but $overwrite is FALSE.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if either path is empty.
   *
   * @see ::move()
   */
  public function copy(
    string $fromPath,
    string $toPath,
    bool $overwrite = TRUE) {
    //
    // Validate
    // --------
    // Neither path can be empty. Checking that the paths are well formed
    // and refer to appropriate entities must be done on the server.
    if (empty($fromPath) === TRUE) {
      throw new \InvalidArgumentException(
        self::ERROR_EMPTY_REMOTE_PATH);
    }

    if (empty($toPath) === TRUE) {
      throw new \InvalidArgumentException(
        self::ERROR_EMPTY_REMOTE_DESTINATION_PATH);
    }

    //
    // Execute
    // -------
    // Issue the request. Interpretation of the $fromPath and $toPath
    // variants is handled on the server.
    if ($overwrite === TRUE) {
      $this->httpPatch("copy-overwrite", $fromPath, $toPath);
    }
    else {
      $this->httpPatch("copy-no-overwrite", $fromPath, $toPath);
    }
  }

  /**
   * Downloads a remote file or folder to a local file or folder.
   *
   * This method uses copy semantics modeled after the way the
   * Linux/macOS/BSD "cp" command operates.
   *
   * The $remotePath must refer to an existing file or folder to be
   * downloaded. The user must have permissions to access the remote content.
   *
   * The $localPath must be one of:
   * - A path to an existing file or directory.
   * - A path to a non-existant item within an existing parent directory.
   *
   * The user must have permissions to create and write local content.
   *
   * When the $localPath is an existing directory, downloaded content is
   * added to the directory using file and folder names matching remote
   * content. When the $localPath is an existing file, downloaded content
   * replaces that file if DOWNLOAD_OVERWRITE is set. Otherwise an exception
   * is thrown.
   *
   * When the $localPath is the name of a file or folder that does not yet
   * exist, downloaded content uses that name as the new local name of the
   * downloaded file or folder. The parent directory on the path must exist.
   *
   * When the DOWNLOAD_OVERWRITE flag is set (the default), downloaded
   * content replaces any local content with the same names. Otherwise,
   * when the flag is not set, downloaded files (but not folders) are
   * renamed with a unique numeric sequence number suffix.
   *
   * When the DOWNLOAD_PRESERVE flag is set, downloaded content has
   * modification and access timestamps set to those of the remote content.
   * Otherwise, when the flag is not set (the default), downloaded content
   * has the current date for timestamps.
   *
   * When the DOWNLOAD_UPDATE flag is set, files (but not folders) are
   * only downloaded if there is no local content with the same name, or
   * if the local content is older than the remote content. Otherwise,
   * when the flag is not set (the default), content is always downloaded
   * without regard to local content timestamps.
   *
   * @param string $remotePath
   *   The string path for a remote file or folder to download.
   * @param string $localPath
   *   The string path for a local file or folder indicating the destination
   *   of the download.
   * @param int $flags
   *   (optional, default = DOWNLOAD_OVERWRITE) A bitmask of flags:
   *   - DOWNLOAD_OVERWRITE: When set and $localPath refers to an
   *     existing file, the file will be deleted before the download is done.
   *     When unset, the downloaded file will be given a unique sequence
   *     number to avoid overwriting existing files (e.g. "file-2.txt",
   *     "file-3.txt").
   *   - DOWNLOAD_PRESERVE: When unset, new files and folders have
   *     the current date and time as their creation, modification, and access
   *     times. When set, new files and folders use the remote item's
   *     modification time as their modification and access times. The creation
   *     time cannot be set from PHP so it remains the current date and time.
   *   - DOWNLOAD_UPDATE: When set, a file is downloaded only if it has a
   *     newer modification date or if it doesn't exist locally yet.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - Either path is malformed.
   *   - The item to download does not exist.
   *   - The item to download is not a file or folder.
   *   - The user does not have necessary permissions.
   *   - One of the item's involved is locked by another process.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception on a client error, including the following
   *   conditions:
   *   - The remote path is empty.
   *   - The local path is empty.
   *   - The local path does not indicate a directory or parent directory
   *     that exists and is writable.
   *   - The local path indicates a file that already exists but overwrite
   *     is disabled.
   *
   * @see ::copy()
   * @see ::upload()
   */
  public function download(
    string $remotePath,
    string $localPath,
    int $flags = self::DOWNLOAD_OVERWRITE) {
    //
    // Validate
    // --------
    // Neither path can be empty.
    if (empty($remotePath) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    if (empty($localPath) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_LOCAL_PATH);
    }

    $overwrite = FALSE;
    $preserveTimestamps = FALSE;
    $update = FALSE;

    if (($flags & self::DOWNLOAD_OVERWRITE) !== 0) {
      $overwrite = TRUE;
    }
    if (($flags & self::DOWNLOAD_PRESERVE) !== 0) {
      $preserveTimestamps = TRUE;
    }
    if (($flags & self::DOWNLOAD_UPDATE) !== 0) {
      $update = TRUE;
    }

    //
    // Get a list of items to download
    // -------------------------------
    // If the remote item is a file, the list will just contain that file.
    // But if the remote item is a folder, the list will list that folder
    // and all of its descendants. The list is guaranteed to include parent
    // folders earlier in the list than their children.
    //
    // Temporarily switch to the 'keyvalue' return format so that it is
    // easier to work with the returned information. Important values are:
    //
    // - 'id': The entity ID.
    //
    // - 'kind': The entity kind (e.g. 'file', 'image', 'folder').
    //
    // - 'path': The absolute path to the entity. Paths always use '/' as
    //   the directory separator.
    $originalReturnFormat = $this->getReturnFormat();
    $this->setReturnFormat('keyvalue');

    try {
      $itemsToDownload = $this->getFileOrFolder($remotePath, TRUE);
    }
    catch (\Exception $e) {
      $this->setReturnFormat($originalReturnFormat);
      throw $e;
    }

    $this->setReturnFormat($originalReturnFormat);

    //
    // Determine the top-level local path
    // ----------------------------------
    // Downloading is a remote-to-local copy, so we use the same semantics
    // as a Linux/macOS/BSD "cp" command.
    //
    // Get the last name on the remote path. This is used by some of the
    // cases below.
    $remoteLastName = mb_substr(
        $remotePath,
        mb_strrpos($remotePath, '/') + 1);

    if (@is_link($localPath) === TRUE) {
      // The local path refers to an existing symlink. We need to know
      // if the link target is a file or folder, so get the target path.
      $targetPath = readlink($localPath);
    }
    else {
      // The local path may or may not refer to an existing item. But it
      // isn't a symlink, so use the local path as-is as the target path.
      $targetPath = $localPath;
    }

    // Use the target path for testing, but modify the local path as needed.
    // This will cause downloads to continue to use a local path that
    // refers to a symlink, while testing against what that symlnk actually
    // links to.
    if ($targetPath === '/') {
      // For local Linux/macOS/BSD hosts, a local path of '/' means to
      // copy into the file system root (which is probably a bad idea).
      // Append the last name on the remote path onto the local path.
      if (@is_writable($targetPath) === FALSE) {
        throw new \InvalidArgumentException(
          "You do not have permissiont to write into the directory \"$localPath\".");
      }

      $localPath .= $remoteLastName;
    }
    elseif (@file_exists($targetPath) === TRUE) {
      // The local path refers to something that already exists. The
      // download semantics differ depending upon what it is.
      if (@is_dir($targetPath) === TRUE) {
        // The target is a directory, download into it if it has write
        // permission. Append the last name on the remote path onto the
        // local path.
        if (@is_writable($targetPath) === FALSE) {
          throw new \InvalidArgumentException(
            "You do not have permissiont to write into the directory \"$localPath\".");
        }

        $localPath .= DIRECTORY_SEPARATOR . $remoteLastName;
      }
      elseif (@is_file($targetPath) === TRUE) {
        // The target is a file, only proceed if overwrite is TRUE. In that
        // case, the local item will be replaced with the remote item,
        // even if one is a file and the other is a folder.
        if ($overwrite === FALSE) {
          throw new \InvalidArgumentException(
            "A local file with that name already exists and cannot be overwritten.");
        }
        if (@is_writable($targetPath) === FALSE) {
          throw new \InvalidArgumentException(
            "You do not have permissiont to overwrite the file \"$localPath\".");
        }
      }
      else {
        // The target exists, but it is neither a file or a directory.
        // We've already ruled out symlinks, so this must be a special
        // file of some kind (e.g. a Linux/macOS/BSD device file).
        // Downloads cannot be done to these.
        throw new \InvalidArgumentException(
          "An item named \"$localPath\" already exists but it cannot be overwritten.");
      }
    }
    else {
      // The local path does not refer to an existing item. Parse the local
      // path to get its parent directory and check if that parent is writable.
      $localParentPath = pathinfo($localPath, PATHINFO_DIRNAME);
      if (empty($localParentPath) === TRUE) {
        // There is no parent on the local path. It is therefore a relative
        // path and the assumed parent is the current directory.
        $localParentPath = getcwd();
        if ($localParentPath === FALSE) {
          // On some UNIX variants, getcwd() returns FALSE if one of the
          // current directory's ancestors is not readable/searchable. This
          // is sufficient to cause failure of the download.
          throw new \InvalidArgumentException(
            "The current directory is not readable so it cannot be used to receive a download.");
        }
      }
      elseif (@file_exists($localParentPath) === FALSE) {
        // The local path's parent doesn't exist.
        throw new \InvalidArgumentException(
          "The parent directory \"$localParentPath\" does not exist, so it cannot be used to receive a download.");
      }

      if (@is_writable($localParentPath) === FALSE) {
        throw new \InvalidArgumentException(
          "The directory \"$localPath\" is not writable so it cannot be used to receive a download.");
      }
    }

    //
    // Loop over items to download
    // ---------------------------
    // The download list will contain just one item for a file download,
    // or a download of an empty folder. Otherwise the list contains multiple
    // items and we need to loop over it.
    //
    // For folder entries, create a corresponding local folder. For file
    // entries, download the file.
    $foldersToFix = [];
    foreach ($itemsToDownload as $item) {
      // Silently skip items that cannot be downloaded.
      switch ($item['kind']) {
        case 'file':
        case 'image':
        case 'folder':
          break;

        default:
          continue 2;
      }

      // Use the item's remote path to derive the new local path.
      //
      // - Reduce the absolute remote path to a path relative to the
      //   top level download file/folder.
      //
      // - Swap directory separators from the '/' used in remote paths
      //   to DIRECTORY_SEPARATORs used locally.
      //
      // - Prepend the local path to give us a full path for where the
      //   downloaded item should go.
      $remoteItemPath = $item['path'];
      $localItemPath = mb_ereg_replace($remotePath, '', $remoteItemPath);

      if (DIRECTORY_SEPARATOR !== '/') {
        $localItemPath = mb_ereg_replace('/', DIRECTORY_SEPARATOR, $localItemPath);
      }

      $localItemPath = $localPath . $localItemPath;

      if (empty($localItemPath) === TRUE) {
        // There should be no way for this to happen, but reject it if it does.
        continue;
      }

      switch ($item['kind']) {
        case 'file':
        case 'image':
          // Download the file.
          //
          // For updates, only download if the local file is older or
          // doesn't exist.
          if ($update === TRUE && @is_file($localItemPath) === TRUE) {
            $localModification = @filemtime($localItemPath);
            $remoteModification = @strtotime($item['changed-date']);
            if ($remoteModification <= $localModification) {
              // Remote file is older. Don't copy.
              break;
            }
          }

          // Download the file. If overwriting, the returned path is the
          // same as the intended path. If not overwriting, the returned
          // path is of a sequence number version of the intended path.
          $localItemPath = $this->downloadFile(
            $remoteItemPath,
            $localItemPath,
            $overwrite);

          // When preserving timestamps, change the downloaded file.
          if ($preserveTimestamps === TRUE) {
            $remoteModification = @strtotime($item['changed-date']);
            @touch($localItemPath, $remoteModification, $remoteModification);
          }
          break;

        case 'folder':
          // Create a local folder.
          //
          // Updates and overwrites are irrelevant. If the folder does not
          // exist, create it. Otherwise use it.
          //
          // At the top level, we have already checked earlier that
          // directories are writable. This should not fail.
          if (@is_dir($localItemPath) === FALSE) {
            if (@mkdir($localItemPath, 0777, TRUE) === FALSE) {
              throw new \InvalidArgumentException(
                "The directory \"$localItemPath\" could not be created.");
            }
          }

          // When preserving timestamps, the timestamps must be set when
          // we are all done. Save folder info.
          if ($preserveTimestamps === TRUE) {
            $foldersToFix[] = [
              'path'         => $localItemPath,
              'changed-date' => $item['changed-date'],
            ];
          }
          break;
      }
    }

    //
    // Set folder timestamps
    // ---------------------
    // The loop above may have created folders. Each one will have the
    // current date as the creation, modification, and access dates.
    // If we're preserving timestamps, we'd like the dates to match the
    // remote folder. However, if we set them above, during the download
    // loop, then the addition of children to a folder updates its dates
    // so that they don't match those on the server. To do this right,
    // we have to go back through all of the folders and fix their dates.
    // Since the folder list is in root-to-child order, and we need to
    // change child folders first, we need to reverse the order.
    //
    // Note that local file systems have three dates:
    // - Last access time.
    // - Last content modification time.
    // - Last status change time.
    //
    // Some UNIX systems (e.g. macOS) also have:
    // - Creation (birth) time.
    //
    // The creation and status change times CANNOT BE SET. The creation time
    // is always set to the time the item was created, and the status change
    // time is always updated with permissions or the name is changed.
    //
    // The only things we can set here are the access and modification times.
    // These are both set to the modification time from the server. There is
    // no status change time or access time on the server.
    if ($preserveTimestamps === TRUE &&
        empty($foldersToFix) === FALSE) {
      $foldersToFix = array_reverse($foldersToFix);

      foreach ($foldersToFix as $folder) {
        $modified = @strtotime($folder['changed-date']);
        @touch($folder['path'], $modified, $modified);
      }
    }
  }

  /**
   * Downloads a remote file to a local file.
   *
   * @param string $remotePath
   *   The string path for a remote file to download.
   * @param string $localPath
   *   The string path for a local file indicating the destination
   *   of the download.
   * @param bool $overwrite
   *   (optional, default = TRUE) When TRUE and $localPath refers to an
   *   existing file, the file will be deleted before the download is done.
   *   When FALSE, the downloaded file will be given a unique sequence
   *   number to avoid overwriting existing files (e.g. "file-2.txt",
   *   "file-3.txt").
   *
   * @return string
   *   Returns the path for the downloaded local file. This may differ from
   *   the given $localPath if a sequence number was added.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - Either path is malformed.
   *   - The item to download does not exist.
   *   - The item to download is not a file or folder.
   *   - The user does not have necessary permissions.
   *   - One of the item's involved is locked by another process.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception on a client error, including the following
   *   conditions:
   *   - The remote path is empty.
   *   - The local path is empty.
   *   - The local path does not indicate a directory or parent directory
   *     that exists and is writable.
   *   - The local path indicates a file that already exists but $overwrite
   *     is FALSE.
   *
   * @see ::download()
   */
  private function downloadFile(
    string $remotePath,
    string $localPath,
    bool $overwrite = TRUE) {

    //
    // Create a temporary local file
    // -----------------------------
    // Since downloads can fail or be interrupted, we don't want to leave
    // around a partly downloaded file. The local file during a download
    // is therefore created in the system temp directory. When the download
    // finishes, it is moved to the intended destination.
    //
    // The local temp file must be created now so that an open file handle
    // can be passed to CURL.
    $tmpDir = sys_get_temp_dir();
    $tmpLocalPath = @tempnam($tmpDir, 'foldershare');
    $tmpLocalFile = @fopen($tmpLocalPath, 'wb');
    if ($tmpLocalFile === FALSE) {
      throw new \InvalidArgumentException(
        "Cannot create a temporary file in \"$tmpDir\" to receive the download file.");
    }

    //
    // Create headers
    // --------------
    // The headers specify the GET operation and the source path, if any.
    $headers = [];

    // Set the operation.
    $headers[] = 'X-FolderShare-Get-Operation: download';

    // Make sure the path is safe. HTTP headers primarily support ASCII,
    // while paths may include multi-byte characters. Use URL encoding
    // to add them to the header.
    $headers[] = 'X-FolderShare-Source-Path: ' . rawurlencode($remotePath);

    //
    // Create URL
    // ----------
    // The GET URL includes:
    // - The host name.
    // - The canonical web services path.
    // - The bogus entity ID (even though one is not used).
    // - The return syntax.
    $url = $this->getHostNameAndPortNumber() . self::URL_GET .
      '/0?' . $this->getSerializationUrlQuery();

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    //
    // Authentication settings should be included.
    //
    // A CSRF token is not required.
    $this->printVerbose("Issuing GET for download");
    $options = $this->getCommonCurlOptions(TRUE);

    $options[CURLOPT_URL]        = $url;
    $options[CURLOPT_HTTPGET]    = TRUE;
    $options[CURLOPT_FILE]       = $tmpLocalFile;
    $options[CURLOPT_HTTPHEADER] = $headers;

    // Disable the timeout for the file transfer.
    $options[CURLOPT_TIMEOUT] = 0;

    // For downloads, use a maximum receive buffer size.
    if (defined('CURLOPT_BUFFERSIZE') === TRUE) {
      if (defined('CURL_MAX_READ_SIZE') === TRUE) {
        $options[CURLOPT_BUFFERSIZE] = CURL_MAX_READ_SIZE;
      }
      else {
        // 512Kbytes is the documented maximum. Use it since
        // CURL_MAX_READ_SIZE is not defined.
        $options[CURLOPT_BUFFERSIZE] = 512000;
      }
    }

    // If verbosity is requested, nominate a progress callback to report
    // bytes downloaded so far.
    if ($this->progress === TRUE) {
      $options[CURLOPT_NOPROGRESS]       = FALSE;
      $options[CURLOPT_PROGRESSFUNCTION] = [
        $this,
        'downloadProgressCallback',
      ];
      $this->progressState = self::PROGRESS_START;
      $this->progressHighestTarget = 0;
      $this->progressPercentage = 0;
    }

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue GET
    // ---------
    // Issue an HTTP GET to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $this->downloadLocalPath = $localPath;

    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_RESPONSE_CODE);
    $errno    = curl_errno($this->curlSession);

    // Close the temp file. It may or may not have received anything useful.
    fclose($tmpLocalFile);

    if ($this->progress === TRUE) {
      fwrite(STDERR, "\n");
    }

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      @unlink($tmpLocalPath);
      $message = $this->getNiceHttpErrorMessage($httpCode);
      $this->printVerbose("  Server failed with HTTP code $httpCode");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    // Check for error codes. The following are standard HTTP success codes:
    // - 200 = OK.
    // - 201 = Created.
    // - 202 = Accepted.
    // - 203 = Non-authoritative information.
    // - 204 = No content.
    // - 205 = Reset content.
    // - 206 = Partial content.
    // - 207 = Multi-status.
    // - 208 = Already reported.
    // - 226 = IM used.
    //
    // A 200 is returned when there is a file.
    //
    // All other standard success codes are unacceptable.
    switch ($httpCode) {
      case 200:
        break;

      default:
        // On an error, the error message has been written to the temp file.
        // Read it in, delete the file, and parse the message (if any).
        $content = file_get_contents($tmpLocalPath);
        @unlink($tmpLocalPath);

        if ($content !== FALSE) {
          $content = json_decode($content, TRUE);
        }

        if (empty($content) === FALSE &&
            isset($content['message']) === TRUE &&
            empty($content['message']) === FALSE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }

    // Rename the downloaded temp file using the local path.
    if ($overwrite === TRUE) {
      // Overwrite is enabled. If there is anything already there, delete
      // it first. Then move the temp file into place.
      if (file_exists($localPath) === TRUE &&
          @unlink($localPath) === FALSE) {
        throw new \RuntimeException(
          "Cannot delete old \"$localPath\" before replacing it with the download file.");
      }

      if (@rename($tmpLocalPath, $localPath) === FALSE) {
        throw new \RuntimeException(
          "Cannot rename download file to \"$localPath\".");
      }
    }
    elseif (file_exists($localPath) === FALSE) {
      // Do not overwrite, but there is nothing there anyway. Just move
      // the temp file into place.
      if (@rename($tmpLocalPath, $localPath) === FALSE) {
        throw new \RuntimeException(
          "Cannot rename download file to \"$localPath\".");
      }
    }
    else {
      // Do not overwrite the existing file. Add a unique numeric suffix to
      // the file name. Loop with '-2', '-3', ... until we get a path that
      // doesn't have an existing file.
      $lastSlash = mb_strripos($localPath, '/');
      $lastDot = mb_strripos($localPath, '.');

      if ($lastDot !== FALSE &&
          ($lastSlash === FALSE || $lastDot > $lastSlash)) {
        // The last name on the path has an extension.
        $pathBeforeExtension = mb_substr($localPath, 0, $lastDot);
        $extension = mb_substr($localPath, $lastDot + 1);
      }
      else {
        // The last name on the path does not have an extension.
        $pathBeforeExtension = $localPath;
        $extension = '';
      }

      $pathBeforeExtension .= '-';

      for ($i = 2; ; ++$i) {
        $localPath = $pathBeforeExtension . $i;
        if (empty($extension) === FALSE) {
          $localPath .= '.' . $extension;
        }

        if (file_exists($localPath) === FALSE) {
          if (@rename($tmpLocalPath, $localPath) === FALSE) {
            throw new \RuntimeException(
              "Cannot rename download file to \"$localPath\".");
          }
          break;
        }
      }
    }

    $this->downloadLocalPath = '';

    return $localPath;
  }

  /**
   * Responds to a progress callback during a file download.
   *
   * This method is called repeatedly while downloading a file. Each
   * call passes information on the download progress. This is used
   * to keep track of the start and end of a download and output
   * a progress message.
   *
   * This callback is only invoked if progress message output has been
   * enabled.
   *
   * @param resource $resource
   *   The file resource.
   * @param int $downloadTarget
   *   The target number of bytes to download.
   * @param int $downloadSoFar
   *   The number of bytes downloaded so far.
   * @param int $uploadTarget
   *   Unused.
   * @param int $uploadSoFar
   *   Unused.
   *
   * @return int
   *   Always returns 0.
   *
   * @see ::download()
   * @see ::isProgress()
   * @see ::setProgress()
   */
  private function downloadProgressCallback(
    $resource,
    $downloadTarget,
    $downloadSoFar,
    $uploadTarget,
    $uploadSoFar) {

    // From testing, CURL has some quirks with download progress callbacks.
    //
    // On a non-SSL connection, the $downloadTarget is a constant value
    // equal to the total size of the file being transfered. $downloadSoFar
    // starts at 0 and grows up to the target size.
    //
    // But on an SSL connection, there appear to be 5 phases for each transfer:
    // 1. $downloadTarget = $downloadSoFar = 270 for several calls.
    // 2. $downloadTarget = $downloadSoFar = 0 for several calls.
    // 3. $downloadTarget = file size, and $downloadSoFar varies from 0 to the
    //    total size, as in the non-SSL case.
    // 4. $downloadTarget = $downloadSoFar = 0 for several calls.
    // 5. $downloadTarget = $downloadSoFar = 270 for several calls.
    //
    // Stage 3 is the actual file transfer. The checks below try to filter out
    // stages 2, 4, and 5 from confusing the progress message. However, stage 1
    // is not distinguishable from stage 3 and a short 270 byte file so we
    // have to keep it.
    //
    // Also, we cannot assume 270 bytes is some fixed magic number. It could
    // be anything.
    if (empty($this->downloadLocalPath) === TRUE) {
      // Malformed progress setup. Nothing to report.
      return 0;
    }

    $downloadTarget = (int) $downloadTarget;
    $downloadSoFar  = (int) $downloadSoFar;

    if ($downloadTarget <= 0) {
      // Invalid download target. This may be the start or end SSL handshake.
      return 0;
    }

    if ($downloadTarget < $this->progressHighestTarget) {
      // Post-file transfer progress. This may be from a final SSL handshake.
      return 0;
    }

    if ($downloadTarget > $this->progressHighestTarget) {
      // Actual file transfer after start SSL handshake. Record the target
      // and resume progress output.
      $this->progressHighestTarget = $downloadTarget;
      $this->progressState = self::PROGRESS_CONTINUE;
      $this->progressPercentage = 0;
    }

    if ($this->progressState == self::PROGRESS_END) {
      // After last progress message when the transfer appears to be done.
      return 0;
    }

    $percentage  = (int) (($downloadSoFar / $this->progressHighestTarget) * 100.0);
    if ($percentage !== $this->progressPercentage) {
      // Only report an update if the percentage has changed.
      $filename = $this->downloadLocalPath;
      $bytesSoFar = FolderShareFormat::formatBytes(
        $downloadSoFar,
        1000,
        FALSE,
        0);
      $bytesTarget = FolderShareFormat::formatBytes(
        $this->progressHighestTarget,
        1000,
        FALSE,
        0);
      $percentageFmt = number_format($percentage, 0);

      fwrite(STDERR, "\x0D  $filename: $bytesSoFar/$bytesTarget ($percentageFmt%)  ");
    }

    if ($downloadSoFar == $this->progressHighestTarget) {
      // End of transfer. Further progress messages are not needed. However,
      // this could just be the end of a starting SSL handshake.
      $this->progressState = self::PROGRESS_END;
    }
    else {
      // Continuing transfer. Future messages should be output.
      $this->progressState = self::PROGRESS_CONTINUE;
    }

    return 0;
  }

  /**
   * Uploads a local file to a remote file.
   *
   * This method uses copy semantics modeled after the way the
   * Linux/macOS/BSD "cp" command operates.
   *
   * The $localPath must refer to an existing file or folder to be
   * uploaded. The user must have permissions to access the local content.
   *
   * The $remotePath must be one of:
   * - A path to an existing file or folder.
   * - A path to a non-existant item within an existing parent folder.
   *
   * The user must have permissions to create and write remote content.
   *
   * When the $remotePath is an existing folder, uploaded content is
   * added to the folder using file and folder names matching local
   * content. When the $remotePath is an existing file, uploaded content
   * replaces that file if UPLOAD_OVERWRITE is set. Otherwise an exception
   * is thrown.
   *
   * When the $remotePath is the name of a file or folder that does not yet
   * exist, uploaded content uses that name as the new remote name of the
   * uploaded file or folder. The parent folder on the path must exist.
   *
   * When the UPLOAD_OVERWRITE flag is set (the default), uploaded
   * content replaces any remote content with the same names. Otherwise,
   * when the flag is not set, uploaded files (but not folders) are
   * renamed with a unique numeric sequence number suffix.
   *
   * When the UPLOAD_PRESERVE flag is set, uploaded content has
   * modification and access timestamps set to those of the local content.
   * Otherwise, when the flag is not set (the default), uploaded content
   * has the current date for timestamps.
   *
   * When the UPLOAD_UPDATE flag is set, files (but not folders) are
   * only uploaded if there is no remote content with the same name, or
   * if the remote content is older than the local content. Otherwise,
   * when the flag is not set (the default), content is always uploaded
   * without regard to remote content timestamps.
   *
   * @param string $localPath
   *   The string path for a local file or folder. The file or folder must
   *   exist and be readable.
   * @param string $remoteUri
   *   The string URI for a remote file or folder indicating the destination
   *   of the download. "/" refers to the user's top-level list (a.k.a.
   *   "rootlist"). If the URI has a scheme and user, then the scheme must
   *   be "personal" and the user must be the current user.
   * @param int $flags
   *   (optional, default = UPLOAD_OVERWRITE) A bitmask of flags:
   *   - UPLOAD_OVERWRITE: When set and $localPath refers to an
   *     existing file, the file will be deleted before the download is done.
   *     When unset, the downloaded file will be given a unique sequence
   *     number to avoid overwriting existing files (e.g. "file-2.txt",
   *     "file-3.txt").
   *   - UPLOAD_PRESERVE: When unset, new files and folders have
   *     the current date and time as their creation, modification, and access
   *     times. When set, new files and folders use the remote item's
   *     modification time as their modification and access times. The creation
   *     time cannot be set from PHP so it remains the current date and time.
   *   - UPLOAD_UPDATE: When set, a file is downloaded only if it has a
   *     newer modification date or if it doesn't exist locally yet.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - Either path is malformed.
   *   - The item to upload does not exist.
   *   - The user does not have necessary permissions to create a file.
   *   - One of the item's involved is locked by another process.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception on a client error, including the following
   *   conditions:
   *   - The remote path is empty.
   *   - The local path is empty.
   *   - The local path does not indicate a file or folder that exists.
   *   - The local path does not indicate a file or folder that can be read.
   *   - The local path does not indicate a regular file or folder.
   *
   * @see ::copy()
   * @see ::download()
   */
  public function upload(
    string $localPath,
    string $remoteUri,
    int $flags = self::UPLOAD_OVERWRITE) {

    //
    // Validate
    // --------
    // - Neither path can be empty.
    // - The remote path cannot have a scheme or user.
    // - The local path must refer to a file that exists.
    if (empty($remoteUri) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    $remoteUriParts = self::parseUri($remoteUri);

    $remotePath   = $remoteUriParts['path'];
    $remoteScheme = $remoteUriParts['scheme'];
    $remoteUser   = $remoteUriParts['user'];

    if (empty($remotePath) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }
    if (empty($remoteScheme) === FALSE && $remoteScheme !== 'personal') {
      throw new \InvalidArgumentException(
        "The remote path for an upload must be to the user's personal folder tree.");
    }
    if (empty($remoteUser) === FALSE && $remoteUser !== $this->userName) {
      throw new \InvalidArgumentException(
        "The remote path for an upload must be to the user's personal folder tree.");
    }

    if (empty($localPath) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_LOCAL_PATH);
    }

    $overwrite = FALSE;
    $preserveTimestamps = FALSE;
    $update = FALSE;

    if (($flags & self::UPLOAD_OVERWRITE) !== 0) {
      $overwrite = TRUE;
    }
    if (($flags & self::UPLOAD_PRESERVE) !== 0) {
      $preserveTimestamps = TRUE;
    }
    if (($flags & self::UPLOAD_UPDATE) !== 0) {
      $update = TRUE;
    }

    // Convert the local path into an absolute path, expanding any
    // symbolic links, "/./", "/../", etc.
    $localRealPath = realpath($localPath);
    if ($localRealPath === FALSE) {
      // The local path does not refer to an existing file or folder.
      throw new \InvalidArgumentException(
        "Local \"$localPath\" could not be found to upload.");
    }

    // The real path already expanded all symlinks, but it may still refer
    // to a non-file and non-directory (e.g. a special device file).
    if (@is_file($localRealPath) === FALSE &&
        @is_dir($localRealPath) === FALSE) {
      throw new \InvalidArgumentException(
        "Local \"$localPath\" is not a file or directory so it cannot be uploaded.");
    }

    //
    // Get a list of items to upload
    // -----------------------------
    // If the local item is a file, the list will just contain that file.
    // But if the local item is a folder, the list will list that folder
    // and all of its descendants. The list is guaranteed to include parent
    // folders earlier in the list than their children.
    //
    // Important values in the returned list are:
    //
    // - 'path': The local path to the item. Because of realpath() above,
    //   paths are always absolute. Symlinks are automatically expanded.
    //
    // - 'kind': The item kind (e.g. 'file' or 'folder').
    //
    // - 'modified': The item's last modified date timestamp.
    //
    // - 'size': The file's size. Folders have size 0.
    $itemsToUpload = self::createUploadList($localRealPath);

    //
    // Determine the top-level remote path.
    // ------------------------------------
    // We have $remotePath, but we need to adjust the path to be the name
    // of the intended remote item. It may already be that, or it may be
    // a path to an existing item, a parent item, etc. So we need to determine
    // the case we're handling and adjust the path.
    //
    // When uploading either a file or a folder:
    //   1. upload LOCAL to /
    //     - add LOCAL into /, so use /LOCAL.
    //
    //   2. upload LOCAL to /MISSINGPATH/MISSING
    //      - error. When the last item on the path is missing, the parent
    //        must exist.
    //
    //   3. upload LOCAL to /PATH/MISSING
    //     - add LOCAL to PATH as MISSING, so use /PATH/MISSING.
    //
    //   4. upload LOCAL to /PATH/MISSING/
    //     - error. When the path ends in /, the last name must exist.
    //
    //   5. upload LOCAL to /PATH/EXISTINGFOLDER
    //   6. upload LOCAL to /PATH/EXISTINGFOLDER/
    //     - add LOCAL into EXISTINGFOLDER, so use /PATH/EXISTINGFOLDER/LOCAL.
    //
    //   7. upload LOCAL to /PATH/EXISTINGFILE/
    //     - error. When the path ends in /, the last name must be a folder.
    //
    //   8. upload LOCAL to /PATH/EXISTINGOTHER
    //   9. upload LOCAL to /PATH/EXISTINGOTHER/
    //     - error. Cannot upload a file or folder and replace or add to
    //       anything but a file or folder.
    //
    // When uploading a file:
    //   10. upload LOCALFILE to /PATH/EXISTINGFILE
    //     - overwrite EXISTINGFILE with LOCALFILE, so use /PATH/EXISTINGFILE.
    //
    // When uploading a folder:
    //   11. upload LOCALFOLDER to /PATH/EXISTINGFILE
    //     - error. Cannot overwrite an existing file with a folder.
    //
    // First, look at the remote path and see if it ends in '/'.
    $remotePathEndsInSlash = FALSE;
    if ($remotePath !== '/') {
      $lastSlash = mb_strrpos($remotePath, '/');
      if ($lastSlash === (mb_strlen($remotePath) - 1)) {
        // Note the fact and remove the '/' from the path.
        $remotePathEndsInSlash = TRUE;
        $remotePath = mb_substr($remotePath, 0, $lastSlash);
      }
    }

    // Next, for several cases we'll be appending the local path's file or
    // folder name to the end of the remote path. Get that name.
    $lastLocalName = pathinfo($localRealPath, PATHINFO_BASENAME);

    // And is the local item a file or folder?
    $lastLocalIsFile = @is_file($localRealPath);

    // We need to do existence queries and it is more convenient to be using
    // key-value pairs. The 'kind' key's value is the item kind (e.g.
    // 'file', 'image', 'folder').
    $originalReturnFormat = $this->getReturnFormat();
    $this->setReturnFormat('keyvalue');

    // Now consider each of the above cases.
    if ($remotePath === '/') {
      // 1. Uploading into the user's rootlist. Use the local name as the
      // remote name.
      $remotePath = '/' . $lastLocalName;
    }
    else {
      // Uploading to a destination that may or may not exist. Look it up.
      try {
        $remoteEntity = $this->getFileOrFolder($remotePath, FALSE);

        if ($remoteEntity['kind'] === 'folder') {
          // 5 and 6. The remote path indicates an existing folder.
          // Upload into it using the local name as the remote name.
          $remotePath .= '/' . $lastLocalName;
        }
        elseif ($remoteEntity['kind'] !== 'file' &&
            $remoteEntity['kind'] !== 'image') {
          // 8 and 9. The remote path indicates an existing something that
          // is not a file or folder. Error.
          $this->setReturnFormat($originalReturnFormat);
          throw new \InvalidArgumentException(
            "A remote item with that name already exists and cannot be overwritten.");
        }
        elseif ($remotePathEndsInSlash === TRUE) {
          // 7. The remote path indicates an existing file, but the "/"
          // on the end of the original path means it is required to be a
          // folder. Error.
          $this->setReturnFormat($originalReturnFormat);
          throw new \InvalidArgumentException(
            "A remote item with that name already exists and is not a folder.");
        }
        elseif ($lastLocalIsFile === FALSE) {
          // 11. The remote path indicates an existing file but we're
          // uploading a folder. Error.
          $this->setReturnFormat($originalReturnFormat);
          throw new \InvalidArgumentException(
            "A remote item with that name already exists and cannot be overwritten.");
        }

        // Otherwise 10. The remote path indicates an existing file and we're
        // uploading a file. Use the remote path as-is as the name of the
        // new file.
      }
      catch (\Exception $e) {
        // The remote path does not indicate an existing item.
        if ($remotePathEndsInSlash === TRUE) {
          // 4. The remote path ended in a slash, so the last item on the
          // path must exist and be a folder. But it doesn't exist. Error.
          $this->setReturnFormat($originalReturnFormat);
          throw $e;
        }

        // Check if the parent on the path exists.
        $lastSlash = mb_strrpos($remotePath, '/');
        if ($lastSlash === FALSE || $lastSlash === 0) {
          // 3. The remote path indicated a missing item, but the parent
          // exists because it is "/". Leave the path as-is as the name of
          // the new file or folder.
        }
        else {
          $remoteParentPath = mb_substr($remotePath, 0, $lastSlash);

          try {
            $remoteParentEntity = $this->getFileOrFolder($remoteParentPath, FALSE);

            // Make sure the parent is actually a folder.
            if ($remoteParentEntity['kind'] !== 'folder') {
              $this->setReturnFormat($originalReturnFormat);
              throw new \InvalidArgumentException(
                "\"$remotePath\" is not a folder.");
            }

            // 3. The remote path indicated a missing item, but the parent
            // exists. Leave the path as-is as the name of the new file or
            // folder.
          }
          catch (\Exception $ee) {
            // 2. The remote path refers to a missing item and the parent is
            // missing too. Error.
            //
            // Throw the original exception.
            $this->setReturnFormat($originalReturnFormat);
            throw $e;
          }
        }
      }
    }

    //
    // Loop over items to upload
    // -------------------------
    // The upload list will contain just one item for a file upload,
    // or an upload of an empty folder. Otherwise the list contains multiple
    // items and we need to loop over it.
    //
    // For folder entries, create a corresponding remote folder. For file
    // entries, upload the file.
    foreach ($itemsToUpload as $item) {
      // Use the item's local path to derive the new remote path.
      //
      // - Reduce the absolute local path to a path relative to the
      //   top level upload file/folder.
      //
      // - Swap directory separators from the DIRECTORY_SEPARATORs used in
      //   local paths to '/'s used remotely.
      //
      // - Prepend the remote path to give us a full path for where the
      //   uploaded item should go.
      $localItemPath = $item['path'];
      $remoteItemPath = mb_ereg_replace($localRealPath, '', $localItemPath);
      $progressItemPath = $remoteItemPath;

      if (empty($remoteItemPath) === TRUE) {
        // After removing the real path to the top item to upload, there is
        // nothing left. That's OK. It means this IS the top item. Keep it.
        $remoteItemPath = $remotePath;
        $progressItemPath = $localPath;
      }
      else {
        // After removing the real path to the top item to upload, we have
        // a file or folder path relative to that top item. Convert it from
        // using the local directory separator to using a URI separator '/'.
        // Then prepend the top remote path indicating where the item
        // should go.
        if (DIRECTORY_SEPARATOR !== '/') {
          $remoteItemPath = mb_ereg_replace(
            DIRECTORY_SEPARATOR,
            '/',
            $remoteItemPath);
        }

        $remoteItemPath = $remotePath . $remoteItemPath;
      }

      $localModification = $item['modified'];

      switch ($item['kind']) {
        case 'file':
          // Upload the file.
          try {
            $remoteFile = $this->getFileOrFolder($remoteItemPath, FALSE);

            // Remote file does exist.
            if ($update === TRUE) {
              // The file exists and we're updating it. Only upload if
              // the remote file is older.
              if ($remoteFile['kind'] === 'file') {
                $remoteModification = @strtotime($remoteFile['changed-date']);
                if ($remoteModification >= $localModification) {
                  // Remote file is newer. Don't copy.
                  break;
                }
              }
            }

            // Otherwise, there is a remote file or folder already there
            // and we're not updating or can't update it. If overwriting,
            // delete whatever is there first.
            if ($overwrite === TRUE) {
              try {
                $this->deleteFileOrFolder($remoteItemPath, TRUE);
              }
              catch (\Exception $e) {
                // Delete failed? Cannot continue with upload.
                $this->setReturnFormat($originalReturnFormat);
                throw $e;
              }
            }
          }
          catch (\Exception $e) {
            // Remote file does not exist. That's OK. Upload to create it.
          }

          // Upload the file.
          try {
            $this->uploadLocalPath = $progressItemPath;
            $this->uploadFile(
              $remoteItemPath,
              $localItemPath,
              $overwrite,
              $preserveTimestamps);
            $this->uploadLocalPath = '';
          }
          catch (\Exception $e) {
            $this->setReturnFormat($originalReturnFormat);
            throw $e;
          }
          break;

        case 'folder':
          // Create a remote folder.
          //
          // Updates and overwrites are irrelevant. If the folder does not
          // exist, create it. Otherwise use it.
          try {
            $remoteFolder = $this->getFileOrFolder($remoteItemPath, FALSE);
          }
          catch (\Exception $e) {
            // Remote folder does not exist. Create it.
            try {
              $lastSlash = mb_strrpos($remoteItemPath, '/');
              $remoteLastName = mb_substr($remoteItemPath, $lastSlash + 1);

              if ($lastSlash === 0) {
                $this->newRootFolder($remoteLastName, $localModification);
              }
              else {
                $remoteParentPath = mb_substr(
                    $remoteItemPath,
                    0,
                    mb_strrpos($remoteItemPath, '/'));
                $this->newFolder($remoteParentPath, $remoteLastName, $localModification);
              }
            }
            catch (\Exception $e) {
              $this->setReturnFormat($originalReturnFormat);
              throw new \InvalidArgumentException(
                "The folder \"$remoteItemPath\" could not be created.");
            }
          }
          break;
      }
    }

    $this->setReturnFormat($originalReturnFormat);
  }

  /**
   * Returns a list with the indicated file or folder and all descendants.
   *
   * The given path is assumed to be an absolute path. All returned paths
   * are absolute. Symlinks are followed and their targets included in
   * the results, also as absolute paths.
   *
   * @param string $localPath
   *   The absolute path to an existing local file or folder.
   *
   * @return array
   *   Returns an array containing a list of all local files or directories
   *   that are descendants of given path, starting with the path itself.
   *   Array entries are ordered such that parents occur before children.
   *   Each entry is an associative array containing:
   *   - 'path' = the local path to the file or folder.
   *   - 'kind' = 'file' or 'folder'.
   *   - 'modified' = the last modified date of the file or folder.
   *   - 'size' = the size of files, and zero for folders.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the $localPath or any of its descendants
   *   has one of the following conditions:
   *   - does not exist.
   *   - does not have read permission.
   *   - is a symlink with no target.
   *   - is not a file or directory.
   */
  private function createUploadList(string $localPath) {

    // Add the initial path to a pending list.
    $results = [];
    $pending = [$localPath];

    // Loop on the pending list until it is empty. Each time a directory
    // is encountered, all of its contents are added to the pending list.
    // Looping through the list gradually shifts items off the pending list.
    while (empty($pending) === FALSE) {
      // Get the next path.
      $path = array_shift($pending);

      // The path should exist or it wouldn't be on the list, but be sure.
      if (@file_exists($path) === FALSE) {
        throw new \InvalidArgumentException(
          "Local \"$path\" does not exist.");
      }

      // And insure it is readable for an upload.
      if (@is_readable($path) === FALSE) {
        throw new \InvalidArgumentException(
          "Local \"$path\" is not readable and cannot be uploaded.");
      }

      // If the path is a symlink, get the target and make it absolute.
      if (@is_link($path) === TRUE) {
        $target = readlink($path);
        if ($target === FALSE) {
          throw new \InvalidArgumentException(
            "Local \"$path\" is a link, but the target does not exist.");
        }
        $target = realpath($target);
        if ($target === FALSE) {
          throw new \InvalidArgumentException(
            "Local \"$path\" is a link, but the target does not exist.");
        }
        $path = $target;
      }

      // If the path leads to a file, add the file to the results list.
      // But if it is a directory, add the directory to the results AND
      // add all of the directory's contents to the pending list.
      if (@is_file($path) === TRUE) {
        $results[] = [
          'path'     => $path,
          'kind'     => 'file',
          'size'     => @filesize($path),
          'modified' => @filemtime($path),
        ];
      }
      elseif(@is_dir($path) === TRUE) {
        $results[] = [
          'path'     => $path,
          'kind'     => 'folder',
          'size'     => 0,
          'modified' => @filemtime($path),
        ];

        // Add all of the directory's children to the pending list.
        $d = opendir($path);
        while (($f = readdir($d)) !== FALSE) {
          // Skip '.' and '..' on Linux/macOS/BSD-style systems.
          if ($f === '.' || $f === '..') {
            continue;
          }

          $pending[] = $path . DIRECTORY_SEPARATOR . $f;
        }
        closedir($d);
      }
      else {
        throw new \InvalidArgumentException(
          "Local \"$path\" is not a file or folder and cannot be uploaded.");
      }
    }

    return $results;
  }

  /**
   * Uploads a local file to a remote file.
   *
   * @param string $localPath
   *   The string path for a local file to upload.
   * @param string $remotePath
   *   The string path indicating the remote destination for the file.
   * @param bool $overwrite
   *   (optional, default = TRUE) When TRUE and $remotePath refers to an
   *   existing file, the file will be deleted before the upload is done.
   *   When FALSE, the uploaded file will be given a unique sequence
   *   number to avoid overwriting existing files (e.g. "file-2.txt",
   *   "file-3.txt").
   * @param bool $preserveTimestamps
   *   (optional, default = FALSE) When TRUE the newly uploaded file is
   *   given the same modification time as the local file.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - Either path is malformed.
   *   - The item to upload does not exist.
   *   - The item to upload is not a file or folder.
   *   - The user does not have necessary permissions.
   *   - One of the item's involved is locked by another process.
   *
   * @see ::upload()
   */
  private function uploadFile(
    string $remotePath,
    string $localPath,
    bool $overwrite = TRUE,
    bool $preserveTimestamps = FALSE) {

    // Get the remote file's name and parent path.
    $lastSlash = mb_strrpos($remotePath, '/');
    $remoteLastName = mb_substr($remotePath, $lastSlash);

    if ($lastSlash === 0) {
      $remoteParentPath = '/';
    }
    else {
      $remoteParentPath = mb_substr($remotePath, 0, $lastSlash);
    }

    // Decide on the operation.
    if ($remoteParentPath === '/') {
      $op = 'new-rootfile';
    }
    else {
      $op = 'new-file';
    }

    if ($overwrite === FALSE) {
      $op .= '-no-overwrite';
    }

    // Get the timestamp, if required.
    if ($preserveTimestamps === TRUE) {
      $modified = @filemtime($localPath);
      if ($modified === FALSE) {
        $modified = (-1);
      }
    }
    else {
      $modified = (-1);
    }

    // Upload!
    return $this->httpPost(
      $op,
      $remoteParentPath,
      $remoteLastName,
      $localPath,
      $modified);
  }

  /**
   * Changes ownership of a file or folder, optionally recursively.
   *
   * @param string $user
   *   The new owner's account name or integer user ID.
   * @param string $path
   *   The string path for a remote file or folder.
   * @param bool $recursive
   *   (optional, default = FALSE) When TRUE, ownership is changed for the
   *   remote file or folder and all of its descendants. When FALSE, ownership
   *   is only changed for the indicated file or folder.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path or user are empty.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The item to change does not exist.
   *   - The user name is malformed.
   *   - The user name is for an account that does not exist.
   *   - The user does not have necessary permissions.
   *   - The item is locked by another process.
   */
  public function changeOwner(
    string $user,
    string $path,
    bool $recursive = FALSE) {
    //
    // Validate
    // --------
    // The path and user cannot be empty. Checking that the path and user
    // are well formed, and that the path refers to an existing item must be
    // done on the server.
    if (empty($path) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_PATH);
    }

    if (empty($user) === TRUE) {
      throw new \InvalidArgumentException(self::ERROR_EMPTY_REMOTE_USER);
    }

    //
    // Execute
    // -------
    // Issue the request.
    $this->httpPatch(
      ($recursive === TRUE) ? "change-owner-recursive" : "change-owner",
      $path,
      '',
      $user);
  }

}


/**
 * Provides static functions that assist in specialized content formatting.
 *
 * Intended as a companion class to FolderShareConnect, this class provides
 * optional formatting utility functions to present returned content in
 * special ways.
 */
class FolderShareFormat {

  const MAX_SCREEN_WIDTH = 80;

  /*--------------------------------------------------------------------
   *
   * Key-value formatting.
   *
   *--------------------------------------------------------------------*/

  /**
   * Formats a nested key-value array as text.
   *
   * The keys and values of the array are returned as multi-line text in
   * two columns holding the key and value. Rows are optionally indented.
   *
   * Nested arrays are handled by recursing.
   *
   * @param array $response
   *   The key-value response to convert to text.
   * @param string $indent
   *   (optional, default = '  ') The indent for each key-value line in
   *   the result.
   *
   * @return string
   *   The string representation.
   */
  public static function formatAsText(
    array $response,
    string $indent = '') {

    //
    // Validate
    // --------
    // It is not an error to try and format an empty response array.
    // It could simply mean that there is no response.
    if (empty($response) === TRUE) {
      return '';
    }

    //
    // Prepare
    // -------
    // Make a first pass through all keys to find the longest key.
    // This will become the column width below.
    $maxLength = 0;
    foreach (array_keys($response) as $key) {
      $length = mb_strlen($key);
      if ($length > $maxLength) {
        $maxLength = $length;
      }
    }

    // Add one for a ':'.
    ++$maxLength;

    //
    // Generate output
    // ---------------
    // Make a second pass to format everything. Use the maximum key length
    // to set a uniform field size for outputing key names.
    $format = $indent . '%-' . $maxLength . "s %s\n";
    $text = '';
    foreach ($response as $key => $value) {
      // If the value is a scalar, convert it to a string and output.
      if (is_scalar($value) === TRUE) {
        $text .= sprintf($format, $key . ':', $value);
        continue;
      }

      if (empty($value) === TRUE) {
        $text .= sprintf($format, $key . ':', '');
        continue;
      }

      // Otherwise the value must be an array. Sweep through the array to
      // see if all of its values are scalars and its keys are numeric.
      // This is the case for simple lists.
      $simpleList = TRUE;
      foreach ($value as $k => $v) {
        if (is_int($k) === FALSE || is_scalar($v) === FALSE) {
          $simpleList = FALSE;
          break;
        }
      }

      // If the array is a simple list, format the array as a comma-separated
      // list.
      if ($simpleList === TRUE) {
        $text .= sprintf($format, $key . ':', implode(', ', $value));
        continue;
      }

      // Otherwise recurse.
      $indentMore = $indent . '  ';
      $text .= sprintf($format, $key . ':', '');
      $text .= self::formatAsText($value, $indentMore);
    }

    return $text;
  }

  /*--------------------------------------------------------------------
   *
   * Linux-style formatting.
   *
   *--------------------------------------------------------------------*/

  /**
   * Formats a single entity similar to the output of a Linux 'stat' command.
   *
   * The Linux 'stat' command prints information about a file, directory,
   * or device. It has two primary formats:
   *
   * - (default) A full format shows multiple lines of text with key-value
   *   pairs giving the file name, size, permissions, etc.
   *
   * - A terse format shows a single line of text that condenses the most
   *   important values, including the file name, size, permissions, etc.
   *
   * This method takes 'stat' key-value data from FolderShare and formats
   * it in a full-like or terse-like output that includes essential values
   * for a FolderShare entity. It does not support format control arguments.
   *
   * Linux, BSD, macOS, and others all have 'stat' commands, but their
   * formats differ. This method outputs in a format similar to Linux.
   *
   * The Linux 'stat' output is not particularly user-friendly. Linux users
   * are more likely to be familiar with 'ls' output, which provides similar
   * information.
   *
   * <B>Full mode (default)</B><BR>
   * The full multi-line output of Linux 'stat' includes:
   * - File name.
   * - Size.
   * - Number of blocks.
   * - IO block size.
   * - File type (e.g. "regular file" vs. "device").
   * - Device.
   * - Inode number.
   * - Number of hard links.
   * - Permissions mode as hex and text.
   * - User as ID and account name.
   * - Group as ID and group name.
   * - Time of last access as text.
   * - Time of last modification as text.
   * - Time of last status change as text.
   *
   * Some of these values have FolderShare equivalents, while others do not.
   * This method drops these values:
   * - Number of blocks.
   * - IO block size.
   * - Number of hard links.
   * - Group as ID and group name.
   * - Time of last access as text.
   *
   * And replaces these values:
   * - File type replaced with MIME type.
   * - Device replaced with host name.
   * - Inode number replaced with entity ID.
   * - Time of last status change replaced with creation date.
   *
   * This method also adds a few fields:
   * - Full path.
   * - Parent entity ID.
   * - Root entity ID.
   *
   * This method also slightly adjusts the Linux 'stat' names to be more
   * meaningful here:
   * - "Name" is used instead of the misleading "File", which Linux uses
   *   even for things that are not files.
   * - "Mime type" is used instead of the Linux "FileType".
   *
   * The output of this method looks like:
   * <pre>
   *   Path: "PATH"
   *   Name: "FILENAME"
   *   Size: SIZE         Mime type: TYPE
   *   Host: HOSTNAME     ID: ID  ParentID: ID  RootID: ID
   * Access: SHARING      Uid: (UID/ACCOUNT)
   * Modify: DATE
   * Create: DATE
   * </pre>
   *
   * <B>Terse mode</B><BR>
   * If the $terseMode argument is TRUE, a terse mode is returned instead
   * of the full version above.
   *
   * The terse output of Linux 'stat' is an alias for the format string:
   * - %n %s %b %f %u %g %D %i %h %t %T %X %Y %Z %W %o
   * where:
   * - %n = file name.
   * - %s = size.
   * - %b = number of blocks.
   * - %f = raw permission mode in hex.
   * - %u = user ID.
   * - %g = group ID.
   * - %D = device number in hex.
   * - %i = inode number.
   * - %h = number of hard links.
   * - %t = major device type in hex.
   * - %T = minor device type in hex.
   * - %X = time of last access as a timestamp.
   * - %Y = time of last modification as a timestamp.
   * - %Z = time of last status change as a timestamp.
   * - %o = optimal I/O transfer size hint.
   *
   * Some of these values have FolderShare equivalents, while others do not.
   * Rather than reduce the line to just the FolderShare values, this method
   * retains the columns of the Linux terse mode, but shows a '-' if the
   * value is not relevant.
   *
   * This method shows the following values:
   * - %n = file name.
   * - %s = size.
   * - %b = -.
   * - %f = sharing status.
   * - %u = user ID.
   * - %g = -.
   * - %D = host name.
   * - %i = entity ID.
   * - %h = -.
   * - %t = -.
   * - %T = -.
   * - %X = -.
   * - %Y = time of last modification as a timestamp.
   * - %Z = time of creation as a timestamp.
   * - %o = -.
   *
   * @param array $response
   *   The key-value array response when querying a file or folder.
   * @param bool $terseMode
   *   (optional, default = FALSE) When TRUE, a terse one-line form of
   *   the information is created. Otherwise a multi-line form is created.
   *
   * @return string
   *   Returns a text representation of the response.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the $response array is not for an entity or
   *   list of entities.
   */
  public static function formatAsLinuxStat(
    array $response,
    bool $terseMode = FALSE) {
    //
    // Validate
    // --------
    // Make sure the given server response is key-value data for
    // a single entity or a list of entities.
    if (empty($response) === TRUE) {
      throw new \InvalidArgumentException(
        "Programmer error: Empty response array when formatting as 'stat'.");
    }

    if (isset($response['path']) === FALSE) {
      // The array is not for a single entity. Is it for a list of entities?
      foreach ($response as $r) {
        if (isset($r['path']) === FALSE) {
          throw new \InvalidArgumentException(
            "Programmer error: Response array is not in key-value form when formatting as 'stat'.");
        }
      }

      // Recurse to build the output for a list of entities.
      $text = '';
      foreach ($response as $r) {
        $text .= self::formatAsLinuxStat($r, $terseMode);
      }

      return $text;
    }

    //
    // Generate output
    // ---------------
    // Extract and format relevant values.
    //
    // The 'size' may not be present if a entity does not yet have a size
    // computed.
    //
    // The 'id' may not be present if the entity is a temporary false entity
    // for "/" or some other virtual entity.
    //
    // All other values should be present.
    //
    // Entity fields.
    $size     = (isset($response['size']) === TRUE) ?
      (string) $response['size'] : '0';
    $mimeType = (isset($response['mime']) === TRUE) ?
      $response['mime'] : '-';
    $id       = (isset($response['id']) === TRUE) ?
      (string) $response['id'] : '-';
    $parentId = (isset($response['parentid']) === TRUE) ?
      (string) $response['parentid'] : '-';
    $rootId   = (isset($response['rootid']) === TRUE) ?
      (string) $response['rootid'] : '-';

    // Virtual fields.
    $path        = $response['path'];
    $permission  = $response['sharing-status'];
    $uid         = (isset($response['uid']) === TRUE ?
      $response['uid'] :
      (isset($response['user-id']) === TRUE ?
      $response['user-uid'] : '-'));
    $accountName = (isset($response['uid-account-name']) === TRUE ?
      $response['uid-account-name'] :
      (isset($response['user-account-name']) === TRUE ?
      $response['user-account-name'] : '-'));

    // Create formatted dates. The server provides two forms of each date:
    //
    // - The raw timestamp stored on the server. This is expected to be a
    //   UNIX timestamp with an epoch of Jan 1 1970. However, depending upon
    //   this may be risky because different OSes use different epochs, and
    //   the current host running this client may use a different epoch.
    //
    // - An ISO 8601 format time that includes the year, month, day, hour,
    //   minutes, seconds, and timezone offset in a well-defined parsable
    //   format that is independent of the timestamp epoch.
    //
    // The ISO 8601 time is the one to use. However, it is certainly not
    // in the Linux stat date format. So convert the ISO 8601 date to a
    // local timestamp, and the format that.
    //
    // Formatting codes for date() are:
    // - D = 3-letter day of week.
    // - M = 3-letter month abbreviation.
    // - j = date of week without leading zeroes.
    // - H = hour on 24-hour clock without leading zeroes.
    // - i = minutes with leading zeroes.
    // - s = seconds with leading zeroes.
    // - Y = 4-digit year.
    //
    // Get the current timezone. It should have been set in PHP's .ini
    // file as "date.timezone", or it could have been set explicitly during
    // this script run.
    $tz = date_default_timezone_get();
    $modified = @strtotime($response['changed-date']);
    $created = @strtotime($response['created-date']);

    if ($modified === FALSE) {
      // An older version of the REST protocol had a weak formatted date
      // that may not be parsable. Just use it as-is.
      $modifiedDate = $response['changed-date'];
    }
    elseif ($tz === 'UTC') {
      // UTC is the default and rarely what the user expects. Add it to
      // the formatted date.
      $modifiedDate = date('D M j H:i:s Y e', $modified);
    }
    else {
      // Otherwise use the default timezone for the system.
      $modifiedDate = date('D M j H:i:s Y', $modified);
    }

    if ($created === FALSE) {
      // An older version of the REST protocol had a weak formatted date
      // that may not be parsable. Just use it as-is.
      $createdDate = $response['created-date'];
    }
    elseif ($tz === 'UTC') {
      // UTC is the default and rarely what the user expects. Add it to
      // the formatted date.
      $createdDate = date('D M j H:i:s Y e', $created);
    }
    else {
      // Otherwise use the default timezone for the system.
      $createdDate = date('D M j H:i:s Y', $created);
    }

    // Create simplified file type per Linux.
    // - Root and subfolders = "Directory".
    // - Everything else = "File".
    if ($mimeType === 'folder/directory') {
      $fileType = "Directory ($mimeType)";
    }
    else {
      $fileType = "Regular File ($mimeType)";
    }

    // Site info.
    $host = $response['host'];

    // Get the file name from the path. We cannot use PHP's 'basename'
    // since it uses the current OS's conventions ("locale") rather than
    // our generic conventions. We also need to be multi-byte safe.
    if ($path === '/') {
      $filename = $path;
    }
    else {
      $lastSlashPosition = mb_strrpos($path, '/');
      if ($lastSlashPosition === FALSE) {
        $filename = $path;
      }

      $filename = mb_substr($path, ($lastSlashPosition + 1));
    }

    // Format the output.
    $text = '';
    if ($terseMode === TRUE) {
      $text .= sprintf(
        "%s %s - %s %d - - %d - - - - %d %d -\n",
        $filename,
        $size,
        $permission,
        $uid,
        $id,
        $modified,
        $created);
    }
    else {
      // Formatting here approximately mimics Linux et al.
      // - %6s = the first-in-line label, which Linux shows as <= 6 chars.
      //
      // - %-13s = the indent to the 2nd column, which is also used in Linux.
      //   This length is dictated by the length of human-readable dates in
      //   the Modify/Create lines.
      //
      // File: "FILE"
      // - Mimics Linux. Like Linux, it always uses the "File" label, even
      //   when the item is a folder. Linux shows whatever value is given
      //   to the command (e.g. "./stuff" or "/a/b/c/stuff"). Since we
      //   do not support relative paths, the full path is always shown.
      $text .= sprintf(
        "%6s: \"%s\"\n",
        'File',
        $path);

      // Host: NAME
      // - FolderShare-specific. We cannot add other items to the line
      //   because host/domain names can be long and it would mess up
      //   further line formatting.
      $text .= sprintf(
        "%6s: %-13s\n",
        'Host',
        $host);

      // Size: SIZE  FileType: TYPE (MIME)
      // - Mimics Linux. Spacing to the FileType differs - increased so that
      //   items line up with the next few multi-value lines.
      // - Linux shows the FileType as either "Regular File" or "Directory"
      //   and doesn't include a Mime type. We add the Mime type in parens.
      $text .= sprintf(
        "%6s: %-13s %-9s %s\n",
        'Size',
        $size,
        'FileType:',
        $fileType);

      // ID: ID  ParentID: ID  RootID:  ID
      // - FolderShare-specific. Linux instead shows the device major/minor
      //   numbers, Inode number, and the number of links. We show entity IDs.
      $text .= sprintf(
        "%6s: %-13s %-9s %-9s %s %-9s\n",
        'ID',
        $id,
        'ParentID:',
        $parentId,
        'RootID:',
        $rootId);

      // Mode: STATUS  UID: (UID/LOGIN)
      // - Mimics Linux. Instead of the RWX permissions groups of Linux,
      //   we show the generic sharing status.
      // - Linux formats the UID and account name as (%5d/%8s) because the
      //   original account name length limit was 8 characters, and the
      //   original account ID limit was for a 16-bit number. Linux still
      //   uses this formatting, but overflows this presentation as needed.
      $text .= sprintf(
        "%6s: %-13s %s: (%5d/%8s)\n",
        'Mode',
        $permission,
        'Uid',
        $uid,
        $accountName);

      // Modify: DATE
      // - Mimics Linux.
      $text .= sprintf(
        "%6s: %s\n",
        'Modify',
        $modifiedDate);

      // Create: DATE
      // - FolderShare-specific. Linux et al do not store the creation date.
      //   Instead it has a "Change" time that records the last time inode
      //   data was set (owner, group, link count, mode).
      $text .= sprintf(
        "%6s: %s\n",
        'Create',
        $createdDate);
    }

    return $text;
  }

  /**
   * Formats an entity list similar to the output of a Linux 'ls' command.
   *
   * The Linux 'ls' command prints a list of files and folders. In its
   * default mode, file and folder names are shown in multiple columns
   * sized to fit on the screen. Several common options modify this output
   * to list one file per line and include more information. Some of the
   * most useful options are:
   * - '-l' = show a long form that adds the file's permissions, number of
   *   hard links, owner name, group name, size (in blocks), modified date,
   *   and file name.
   *
   * - '-s' = add the file's size in bytes.
   *
   * - '-i' = add the Inode number.
   *
   * - '-o' = omit the group name with paired with '-l'..
   *
   * There are many more options to Linux 'ls', but they are more obscure
   * and not relevant here.
   *
   * For this method, several options are supported to create a few common
   * output modes:
   *
   * - Short mode. File and folder names are output in mulitple columns
   *   sized to fit within an 80-character wide window. Output is sorted
   *   by the file name. If '-s' or '-i' options are given, the size and
   *   entity ID are included before each name.
   *
   * - Long mode. File and folder names are output with one per line,
   *   including attributes in a Linux style. Lines are sorted by the
   *   file name. The '-s' option is ignored because sizes are always
   *   shown in bytes. If '-i' is given, the entity ID is included at
   *   the start of each line. The group name is always skipped, as if
   *   '-o' were given. The number of hard links is always skipped
   *   since there is no such thing in FolderShare.
   *
   * The following values are available to show in short or long modes:
   * - Entity ID in place of Inode number.
   * - Sharing status in place of Linux permissions.
   * - User account name.
   * - Size (always in bytes).
   * - Modification date.
   * - Name.
   *
   * The following formatting flags are supported:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -1     | Force one-column output.                         |
   * | -f     | Do not sort.                                     |
   * | -F     | Add special symbols on files and folders.        |
   * | -h     | Simplify numbers with byte suffixes (e.g. MB).   |
   * | -i     | Include the inode number.                        |
   * | -l     | Show a long listing format.                      |
   * | -r     | Reverse the sort order.                          |
   * | -s     | Include the size of each item.                   |
   * | -S     | Sort by size.                                    |
   * | -t     | Sort by modification time.                       |
   *
   * @param array $response
   *   The key-value array response when querying a file or folder.
   * @param array $flags
   *   (optional, default = []) Linux 'ls' style command-line flags.
   *
   * @return string
   *   Returns a text representation of the response.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the $response array is not for an entity or
   *   list of entities.
   */
  public static function formatAsLinuxLs(array $response, array $flags = []) {
    //
    // Validate
    // --------
    // Make sure the given server response is key-value data for
    // a single entity or a list of entities.
    if (empty($response) === TRUE) {
      // It is not an error to try and format an empty response array.
      // It could simply mean that a folder listing found nothing to list.
      return '';
    }

    if (isset($response['path']) === TRUE) {
      // Response is for a single entity. Make it an array of one entry
      // and continue.
      $response = [$response];
    }
    else {
      // The array is not for a single entity. Is it for a list of entities?
      foreach ($response as $r) {
        if (isset($r['path']) === FALSE) {
          throw new \InvalidArgumentException(
            "Programmer error: Response array is not in key-value form when formatting for 'ls'.");
        }
      }
    }

    //
    // Check options
    // -------------
    // Look for options we support.
    $longMode = FALSE;
    $showSize = FALSE;
    $showId = FALSE;
    $showSymbol = FALSE;
    $sortBy = 'name';
    $sortOrder = "increasing";
    $sortReverse = FALSE;
    $multiColumn = TRUE;
    $simplifySizes = FALSE;

    foreach ($flags as $flag) {
      switch ($flag) {
        case '-1':
          $multiColumn = FALSE;
          break;

        case '-f':
          $sortOrder = "none";
          break;

        case '-F':
          $showSymbol = TRUE;
          break;

        case '-h':
          $simplifySizes = TRUE;
          break;

        case '-i':
          $showId = TRUE;
          break;

        case '-l':
          $longMode = TRUE;
          $multiColumn = FALSE;
          break;

        case '-r':
          $sortReverse = TRUE;
          break;

        case '-s':
          $showSize = TRUE;
          break;

        case '-S':
          $sortBy = 'size';
          break;

        case '-t':
          $sortBy = 'changed';
          $sortOrder = "decreasing";
          break;
      }
    }

    if ($sortReverse === TRUE && $sortOrder !== "none") {
      if ($sortOrder === "increasing") {
        $sortOrder = "decreasing";
      }
      else {
        $sortOrder = "increasing";
      }
    }

    $n = count($response);

    //
    // Sort
    // ----
    // Sort the response list. The sort is case sensitive, so upper case
    // names bubble to the top of the list.
    if ($sortOrder !== "none") {
      switch ($sortBy) {
        default:
        case 'name':
          if ($sortOrder === "increasing") {
            usort(
              $response,
              function ($a, $b) {
                $aname = basename($a['path']);
                $bname = basename($b['path']);
                return ($aname < $bname) ? (-1) : 1;
              });
          }
          else {
            usort(
              $response,
              function ($a, $b) {
                $aname = basename($a['path']);
                $bname = basename($b['path']);
                return ($aname > $bname) ? (-1) : 1;
              });
          }
          break;

        case 'size':
          if ($sortOrder === "increasing") {
            usort(
              $response,
              function ($a, $b) {
                if (isset($a['size']) === TRUE) {
                  $asize = (float) $a['size'];
                }
                else {
                  $asize = 0;
                }

                if (isset($b['size']) === TRUE) {
                  $bsize = (float) $b['size'];
                }
                else {
                  $bsize = 0;
                }

                return ($asize < $bsize) ? (-1) : 1;
              });
          }
          else {
            usort(
              $response,
              function ($a, $b) {
                if (isset($a['size']) === TRUE) {
                  $asize = (float) $a['size'];
                }
                else {
                  $asize = 0;
                }

                if (isset($b['size']) === TRUE) {
                  $bsize = (float) $b['size'];
                }
                else {
                  $bsize = 0;
                }

                return ($asize > $bsize) ? (-1) : 1;
              });
          }
          break;

        case 'changed':
          if ($sortOrder === "increasing") {
            usort(
              $response,
              function ($a, $b) {
                $atime = $a['changed'];
                $btime = $b['changed'];
                return ($atime < $btime) ? (-1) : 1;
              });
          }
          else {
            usort(
              $response,
              function ($a, $b) {
                $atime = $a['changed'];
                $btime = $b['changed'];
                return ($atime > $btime) ? (-1) : 1;
              });
          }
          break;
      }
    }

    //
    // Generate output
    // ---------------
    // Extract and format relevant values.
    //
    // The 'size' may not be present if a folder does not yet have a size
    // computed. All other values are always present.
    if ($longMode === FALSE) {
      // Output a listing that primarily includes names. Use multiple
      // columns if flagged to do so.
      $filenames = [];
      $maxLength = 0;

      // Loop through the response and find the longest file name
      // and, if needed, the symbol suffix based on the kind.
      foreach ($response as $r) {
        // Get the item name.
        $name = basename($r['path']);

        // Get a symbol suffix based on the kind, if any.
        if ($showSymbol === TRUE) {
          $kind = $r['kind'];
          if ($kind === 'folder') {
            $name .= '/';
          }
        }

        // Save the name for the list below.
        $filenames[] = $name;

        // Keep track of the longest name.
        $length = mb_strlen($name);
        if ($length > $maxLength) {
          $maxLength = $length;
        }
      }

      // If the size and entity ID are included in the output, increase
      // the maximum length to account for the space they require.
      if ($showSize === TRUE) {
        $maxLength += (8 + 1);
      }

      if ($showId === TRUE) {
        $maxLength += (8 + 1);
      }

      if ($multiColumn === TRUE) {
        // Use multi-column output.
        //
        // Add one for a space between columns.
        ++$maxLength;

        // Compute the number of columns of names in the output.
        // Allow a maximum of 80 characters to a line.
        //
        // (80 is an historical line length that dates back to Hollerith punch
        // card widths and FORTRAN, but it remains a common magic number of
        // terminal window widths).
        $nColumns = ceil(self::MAX_SCREEN_WIDTH / $maxLength);
        $nRows = (int) ($n / $nColumns);
        if (($nRows * $nColumns) !== $n) {
          ++$nRows;
        }
      }
      else {
        // Use single-column output.
        $nColumns = 1;
        $nRows = $n;
      }

      // Generate output.
      $text = '';
      for ($i = 0; $i < $nRows; ++$i) {
        $rowText = '';
        for ($j = 0; $j < $nColumns; ++$j) {
          // Compute the index of the next response.
          $index = (($i * $nColumns) + $j);
          if ($index >= $n) {
            continue;
          }

          // Get values.
          $filename = $filenames[$index];
          $size = isset($response[$index]['size']) === TRUE ?
            (string) $response[$index]['size'] : 0;
          $id = $response[$index]['id'];

          // Format the item.
          $itemText = '';
          if ($showId === TRUE) {
            $itemText .= sprintf("%8d ", $id);
          }

          if ($showSize === TRUE) {
            if ($simplifySizes === TRUE) {
              $itemText .= sprintf("%8s ", self::formatBytes($size));
            }
            else {
              $itemText .= sprintf("%8s ", $size);
            }
          }

          $itemText .= sprintf("%-" . $maxLength . "s", $filename);
          if ($j === 0) {
            $rowText .= $itemText;
          }
          else {
            $rowText .= ' ' . $itemText;
          }
        }

        $text .= $rowText . "\n";
      }

      return $text;
    }

    // Do a first pass to determine the maximum width of the permission
    // (sharing status) column and the account name column. The sharing
    // status can be as wide as 15 characters, but it is often less.
    // And the account name column can be as wide as 60 characters (Drupal
    // core maximum), but it is almost always less.
    $maxPermissionWidth = 1;
    $maxAccountNameWidth = 1;

    foreach ($response as $item) {
      // Get values.
      $permission = $item['sharing-status'];
      $accountName = (isset($item['uid-account-name']) === TRUE ?
        $item['uid-account-name'] :
        (isset($item['user-account-name']) === TRUE ?
        $item['user-account-name'] : '-'));

      if (empty($accountName) === TRUE) {
        // The anonymous account has no account name. Revert to its
        // display name, which better exist.
        $accountName = (isset($item['uid-display-name']) === TRUE ?
          $item['uid-display-name'] :
          (isset($item['user-display-name']) === TRUE ?
          $item['user-display-name'] : '-'));
        if (empty($accountName) === TRUE) {
          $accountName = "unknown";
        }
      }

      $len = mb_strlen($permission);
      if ($len > $maxPermissionWidth) {
        $maxPermissionWidth = $len;
      }

      $len = mb_strlen($accountName);
      if ($len > $maxAccountNameWidth) {
        $maxAccountNameWidth = $len;
      }
    }

    // Generate output.
    $text = '';
    foreach ($response as $item) {
      // Get values.
      $filename     = basename($item['path']);
      $size         = isset($item['size']) === TRUE ? (string) $item['size'] : '-';
      $id           = $item['id'];
      $permission   = $item['sharing-status'];
      $accountName = (isset($item['uid-account-name']) === TRUE ?
        $item['uid-account-name'] :
        (isset($item['user-account-name']) === TRUE ?
        $item['user-account-name'] : '-'));

      $modified = strtotime($item['changed-date']);
      $tz = date_default_timezone_get();
      if ($tz === 'UTC') {
        // UTC is the default timezone when nothing is set. This is rarely
        // what the user expects. Add the timezone name to the end.
        $modifiedDate = date('M D H:i e', $modified);
      }
      else {
        // Otherwise format it using the current timezone.
        $modifiedDate = date('M D H:i', $modified);
      }

      if (empty($accountName) === TRUE) {
        // The anonymous account has no account name. Revert to its
        // display name, which better exist.
        $accountName = (isset($item['uid-display-name']) === TRUE ?
          $item['uid-display-name'] :
          (isset($item['user-display-name']) === TRUE ?
          $item['user-display-name'] : '-'));
        if (empty($accountName) === TRUE) {
          $accountName = "unknown";
        }
      }

      // Get a symbol suffix based on the kind, if any.
      if ($showSymbol === TRUE) {
        $kind = $item['kind'];
        if ($kind === 'folder') {
          $filename .= '/';
        }
      }

      // Format the row.
      $idText = '';
      if ($showId === TRUE) {
        $idText = sprintf("%8d ", $id);
      }

      if ($simplifySizes === TRUE) {
        $size = self::formatBytes($size);
      }

      // The maximum "permission" (really sharing status) is 15 characters.
      //
      // The maximum account name is *60* characters (see Drupal core's
      // UserInterface::USERNAME_MAX_LENGTH). But we can't really leave
      // a 60 character field or the list will look odd. Instead, use
      // 15 characters.
      $text .= sprintf(
        "%s%" . $maxPermissionWidth . "s %" . $maxAccountNameWidth . "s %8s %s %s\n",
        $idText,
        $permission,
        $accountName,
        $size,
        $modifiedDate,
        $filename);
    }

    return $text;
  }

  /**
   * Formats a number with a bytes suffix.
   *
   * The given number is formatted and returned as markup that may include
   * a suffix like 'K' for kilobytes, 'M' for megabytes, or 'G' for
   * gigabytes.
   *
   * An optional argument selects whether the unit of 'k' should
   * be the current standard 1000, or the older convention of 1024.
   *
   * Optionally, suffixes may be full words instead of abbreviations.
   *
   * @param mixed $number
   *   The number to format.
   * @param int $kunit
   *   (optional, default = 1000) Either 1000 (ISO standard kilobyte) or
   *   1024 (legacy kibibyte).
   * @param bool $fullWord
   *   (optional, default = FALSE) When FALSE, use an abbreviation suffix,
   *   like "KB". When TRUE, use a full word suffix, like "Kilobytes".
   * @param int $decimalDigits
   *   (optional, default = 2) The number of decimal digits for the resulting
   *   number.
   *
   * @return \Drupal\Core\StringTranslation\TranslatableMarkup
   *   Returns a representation of the number, along with a suffix
   *   that summarizes the value using the selected 'k' units.
   *
   * @internal
   * Drupal's format_size() function is widely used to format values in
   * units of kilobytes, megabytes, etc. Unfortunately, it considers a
   * "kilobyte" equal to 1024 bytes, which is not compliant with the
   * 1998 International Electrotechnical Commission (IEC) and
   * International System of Quantities (ISO) standards. By those standards,
   * a "kilobyte" equals 1000 bytes. This definition retains the SI units
   * convention that "k" is for 1000 (e.g. kilometer, kilogram).
   *
   * The following code is loosely based upon format_size(). It corrects
   * the math for the selected "k" units (kilo or kibi) and uses the
   * corresponding correct suffixes. It also supports a requested number
   * of decimal digits.
   * @endinternal
   */
  public static function formatBytes(
    $number,
    int $kunit = 1000,
    bool $fullWord = FALSE,
    int $decimalDigits = 2) {

    // Validate.
    if ($number <= 0) {
      return "0";
    }
    switch ($kunit) {
      case 1000:
      case 1024:
        $kunit = (float) $kunit;
        break;

      default:
        $kunit = 1000.0;
        break;
    }

    if ($decimalDigits < 0) {
      $decimalDigits = 0;
    }

    if ($number < $kunit) {
      // The quantity is smaller than the 'k' unit. Report it as-is.
      if ($fullWord === TRUE) {
        if ($number === 1) {
          return "1 byte";
        }
        return "$number bytes";
      }

      return ((string) $number) . "B";
    }

    // Find the proper 'k'. Values larger than the largest 'k' unit
    // will just be large numbers ahead of the largest prefix (e.g.
    // "879 YB").
    $value = (((float) $number) / $kunit);
    foreach (['K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'] as $unit) {
      if ($value < $kunit) {
        // The value is now less than the next unit, stop reducing.
        break;
      }

      $value /= $kunit;
    }

    // Simplify the remainder with the proper number of decimal digits.
    $fmt = '%1.' . $decimalDigits . 'f';
    $formattedValue = sprintf($fmt, $value);

    // If using abbrevations, return the formatted value and suffix.
    if ($fullWord === FALSE) {
      // Use abbreviations for suffixes.
      switch ($kunit) {
        default:
        case 1000:
          $suffix = $unit . 'B';
          break;

        case 1024:
          $suffix = $unit . 'iB';
          break;
      }

      return ((string) $formattedValue) . $suffix;
    }

    // When using full words, return the formatted value and word,
    // using singular and plural forms as appropriate.
    $singular = [];
    $plural   = [];
    switch ($kunit) {
      default:
      case 1000:
        $singular = [
          'K' => 'Kilobyte',
          'M' => 'Megabyte',
          'G' => 'Gigabyte',
          'T' => 'Terabyte',
          'P' => 'Petabyte',
          'E' => 'Exabyte',
          'Z' => 'Zettabyte',
          'Y' => 'Yottabyte',
        ];
        $plural = [
          'K' => 'Kilobytes',
          'M' => 'Megabytes',
          'G' => 'Gigabytes',
          'T' => 'Terabytes',
          'P' => 'Petabytes',
          'E' => 'Exabytes',
          'Z' => 'Zettabytes',
          'Y' => 'Yottabytes',
        ];
        break;

      case 1024:
        $singular = [
          'K' => 'Kibibyte',
          'M' => 'Mibibyte',
          'G' => 'Gibibyte',
          'T' => 'Tebibyte',
          'P' => 'Pebibyte',
          'E' => 'Exbibyte',
          'Z' => 'Zebibyte',
          'Y' => 'Yobibyte',
        ];
        $plural = [
          'K' => 'Kibibytes',
          'M' => 'Mibibytes',
          'G' => 'Gibibytes',
          'T' => 'Tebibytes',
          'P' => 'Pebibytes',
          'E' => 'Exbibytes',
          'Z' => 'Zebibytes',
          'Y' => 'Yobibytes',
        ];
        break;
    }

    if ($value <= 1) {
      return ((string) $formattedValue) . $singular[$unit];
    }

    return ((string) $formattedValue) . $plural[$unit];
  }

  /*--------------------------------------------------------------------
   *
   * Usage report formatting.
   *
   *--------------------------------------------------------------------*/

  /**
   * Formats a usage report as text.
   *
   * The keys and values of the array are interpreted as a usage report
   * and formatted as a text table of values.
   *
   * @param array $response
   *   The key-value response to convert to text.
   *
   * @return string
   *   The string representation.
   */
  public static function formatAsUsage(array $response) {
    //
    // Validate
    // --------
    // It is not an error to try and format an empty response array.
    // It could simply mean that there is no response.
    if (empty($response) === TRUE) {
      return '';
    }

    // Make sure the response does appear to be usage information.
    if (isset($response['nFolders']) === FALSE) {
      throw new \InvalidArgumentException(
        "Programmer error: Response array is not in key-value form when formatting for usage data.");
    }

    //
    // Generate output
    // ---------------
    // Pull out user and host information and output that first.
    // Then map the remaining usage information to friendlier names
    // and output that as a key-value list.
    //
    // Get host and user.
    $host = (isset($response['host']) === TRUE) ?
      $response['host'] : 'Unknown host';

    if (isset($response['uid-account-name']) === TRUE) {
      $userName = $response['uid-account-name'];
      if (empty($userName) === TRUE) {
        if (isset($response['uid-display-name']) === TRUE) {
          $userName = $response['uid-display-name'];
        }
      }
    }
    elseif (isset($response['user-account-name']) === TRUE) {
      // Legacy.
      $userName = $response['user-account-name'];
      if (empty($userName) === TRUE) {
        if (isset($response['user-display-name']) === TRUE) {
          $userName = $response['user-display-name'];
        }
      }
    }
    elseif (isset($response['uid']) === TRUE) {
      $userName = $response['uid'];
    }
    elseif (isset($response['user-id']) === TRUE) {
      // Legacy.
      $userName = $response['user-id'];
    }
    else {
      $userName = 'Unknown user';
    }

    $text = "$host usage for $userName:\n";

    // Create an alternate usage array with user-friendly names.
    $alt = [];
    foreach ($response as $k => $r) {
      switch ($k) {
        case 'uid':
        case 'uid-account-name':
        case 'uid-display-name':
        case 'host':
          break;

        case 'user-uid':
        case 'user-account-name':
        case 'user-display-name':
          // Legacy fields that are no longer supported from the server.
          break;

        case 'nFolders':
          $alt['Folders'] = $r;
          break;

        case 'nFiles':
          $alt['Files'] = $r;
          break;

        case 'nBytes':
          $alt['Bytes'] = $r;
          break;

        default:
          $alt[$k] = $r;
          break;
      }
    }

    $text .= self::formatAsText($alt, '  ');
    return $text;
  }

  /*--------------------------------------------------------------------
   *
   * Configuration report formatting.
   *
   *--------------------------------------------------------------------*/

  /**
   * Formats a configuration report as text.
   *
   * The keys and values of the array are interpreted as a configuration report
   * and formatted as a text table of values.
   *
   * @param array $response
   *   The key-value response to convert to text.
   *
   * @return string
   *   The string representation.
   */
  public static function formatAsConfiguration(array $response) {
    //
    // Validate
    // --------
    // It is not an error to try and format an empty response array.
    // It could simply mean that there is no response.
    if (empty($response) === TRUE) {
      return '';
    }

    //
    // Generate output
    // ---------------
    // Show the host first, then map the remaining information into
    // friendlier names and a better structure. Then output that as a
    // key-value list.
    //
    // Get host and user.
    $host = (isset($response['host']) === TRUE) ?
      $response['host'] : 'Unknown host';

    // Create an alternate configuration array with user-friendly names.
    $alt = [];
    $alt['Web services'] = [];
    $alt['File handling'] = [];

    $showExtensions = TRUE;

    foreach ($response as $k => $r) {
      switch ($k) {
        case 'host':
          // Already handled.
          break;

        case 'GET':
        case 'POST':
        case 'DELETE':
        case 'PATCH':
          $webalt = [];
          foreach ($r as $kk => $rr) {
            switch ($kk) {
              case 'serializer-formats':
                $webalt['Formats'] = $rr;
                break;

              case 'authentication-providers':
                $webalt['Authentication'] = $rr;
                break;

              default:
                $webalt[$kk] = $rr;
            }
          }

          $alt['Web services'][$k] = $webalt;
          break;

        case 'file-restrict-extensions':
          $alt['File handling']['Restrict extensions'] = $r;
          if (is_bool($r) === TRUE && $r === FALSE) {
            $showExtensions = FALSE;
          }
          elseif (is_scalar($r) === TRUE &&
              (((string) $r) === "false") || ((string) $r) === "FALSE") {
            $showExtensions = FALSE;
          }
          break;

        case 'file-allowed-extensions':
          $alt['File handling']['Allowed extensions'] = $r;
          break;

        default:
          if (isset($alt['Other']) === FALSE) {
            $alt['Other'] = [];
          }

          $alt['Other'][$k] = $r;
          break;
      }
    }

    if ($showExtensions === FALSE) {
      unset($alt['File handling']['Allowed extensions']);
    }

    $text = "$host configuration:\n";
    $text .= self::formatAsText($alt, '  ');
    return $text;
  }

  /*--------------------------------------------------------------------
   *
   * Version report formatting.
   *
   *--------------------------------------------------------------------*/

  /**
   * Formats a version number report as text.
   *
   * The keys and values of the array are interpreted as a version number
   * report and formatted as a text table of values.
   *
   * @param array $response
   *   The key-value response to convert to text.
   *
   * @return string
   *   The string representation.
   */
  public static function formatAsVersion(array $response) {
    //
    // Validate
    // --------
    // It is not an error to try and format an empty response array.
    // It could simply mean that there is no response. But it is unlikely.
    if (empty($response) === TRUE) {
      return '';
    }

    // Confirm that this does seem to be a version response.
    if (isset($response['client']) === FALSE) {
      throw new \InvalidArgumentException(
        "Programmer error: Response array is not in key-value form when formatting version data.");
    }

    //
    // Generate output
    // ---------------
    // The output has several rows:
    // - The application name and version.
    // - The client API name and version.
    // - The host server name.
    // - A list of server item names and versions.
    //
    // Normally all of these are present in a version request's response.
    // But to be robust we need to check for each one and have a fallback.
    $text = '';
    $indent = '  ';

    //
    // Print versions.
    //
    foreach (['client', 'server'] as $section) {
      if (isset($response[$section]) === FALSE) {
        continue;
      }

      if ($section === 'client') {
        $text .= "Client software\n";
      }
      elseif ($section === 'server') {
        if (isset($response['host']) === FALSE) {
          // If there is no host, then there cannot be server side version
          // numbers. Anything that might be present is bogus. Skip it.
          break;
        }

        $hostname = $response['host'];
        $text .= "\nWeb services at $hostname\n";
      }

      foreach ($response[$section] as $k => $v) {
        $name = $k;
        $version = '';
        $protocol = '';

        if (isset($response[$section][$k]['name']) === TRUE) {
          $name = $response[$section][$k]['name'];
        }

        if (isset($response[$section][$k]['version']) === TRUE) {
          $version = ', version ' . $response[$section][$k]['version'];
        }

        if (isset($response[$section][$k]['protocol_version']) === TRUE) {
          $protocol = ', protocol version ' .
            number_format($response[$section][$k]['protocol_version'], 1);
        }

        $text .= "$indent$name$version$protocol\n";
      }
    }

    return $text;
  }

}



/**
 * Implements Linux/BSD/macOS-like commands for access to FolderShare content.
 *
 * This class provides a variety of utility methods that implement
 * commands similar to standard Linux/BSD/macOS file system commands,
 * such as "ls", "stat", "mkdir", "cp", etc.
 */
class FolderShareCommands {

  /*----------------------------------------------------------------------
   *
   * Constants.
   *
   *----------------------------------------------------------------------*/

  /**
   * The default wait interval when waiting for items to become enabled.
   *
   * @var int
   */
  const DEFAULT_WAIT_UNTIL_ENABLED_TIME = 5;

  /**
   * The anonymous login.
   *
   * Technically, the name of the anonymous account can be changed by
   * the server's site admin. This value is only used when that changed
   * value is unknown.
   *
   * @var string
   */
  const ANONYMOUS = 'anonymous';

  /*----------------------------------------------------------------------
   *
   * Available commands.
   *
   *----------------------------------------------------------------------*/

  /**
   * Describes commands and their options.
   *
   * The associative array's keys are command names available for use on the
   * command line (e.g. "ls" and "stat"). For each command, an array of values
   * describes the command, including its help text, a list of supported
   * flags, its return formats, synonyms, and finally the name of the function
   * to invoke to execute the command.
   *
   * Command help:
   *
   * - 'synopsis' = a one-line note on the command name and options, similar to
   *   the synopsis line of a traditional Linux/macOS/BSD man page.
   *
   * - 'description' = a multiparagraph description of the command.
   *
   * - 'flags' = an associative array that lists no-argument flags for the
   *   command. For each flag, the array key names the flag, including leading
   *   dashes ("-" or "--" or both). The key's value is an associative array
   *   with keys for:
   *   - 'brief' = a one-line description of the flag.
   *   - 'synonyms' = an array of equivalent flag names. Defaults to empty.
   *
   * - 'synonyms' = an array of alternate names for the command. Defaults to
   *   empty.
   *
   * Command return format keys:
   *
   * - 'formats' = an array of return format names supported by the command.
   *   Known values are: 'full', 'keyvalue', 'text', and 'linux'.
   *
   * - 'defaultFormat' = the default format.
   *
   * Execution keys:
   *
   * - 'function' = the name of the function to invoke for the command.
   *
   * @var array
   */
  const COMMANDS = [
    //
    // Local state.
    // ------------
    //
    // Print user name.
    //
    'whoami' => [
      'synopsis' => 'whoami',
      'brief'    => 'Show the current user name.',
      'description' => <<<'EOS'
Show the user name of the current user.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
      ],
      'synonyms' => [
        'id',
      ],
      'formats' => [],
      'defaultFormat' => '',
      'function' => 'FolderShareCommands::whoami',
    ],

    //
    // Print host name.
    //
    'hostname' => [
      'synopsis' => 'hostname',
      'brief'    => 'Show the current host name.',
      'description' => <<<'EOS'
Show the host name of the current server connection.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
      ],
      'formats' => [],
      'defaultFormat' => '',
      'function' => 'FolderSharecommands::hostname',
    ],

    //
    // HTTP GET operations supported.
    // ------------------------------
    //
    // GET version numbers.
    //
    'version' => [
      'synopsis' => 'version [OPTIONS]',
      'brief' => 'Show version numbers.',
      'description' => <<<'EOS'
Show version numbers for client and server software.

If a host name is provided, the host is contacted and its software version
numbers reported along with those for the client software. But if no host
name is provided, only client software version numbers are reported.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
      ],
      'formats' => [
        'full',
        'keyvalue',
        'text',
      ],
      'defaultFormat' => 'text',
      'function' => 'FolderShareCommands::version',
    ],

    //
    // GET server configuration.
    //
    'config' => [
      'synopsis' => 'config [OPTIONS]',
      'brief' => 'Show the host administrator configuration.',
      'description' => <<<'EOS'
Summarize the administrator configuration settings for the host.

Reported configuration values include:
  - A list of HTTP verbs supported by the host.
  - The serialization formats supported for each HTTP verb.
  - The authentication providers supported for each HTTP verb.
  - The maximum file upload size and number.
  - The file name extensions supported, if restrictions are enabled.

This information is primiarily of interest to host administrators and to those
developing client-server software. The reported values cannot be altered
through this client software. Administrators may adjust their host's
configuration using the web interface to the REST and FolderShare modules.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
      ],
      'synonyms' => [
        'configuration',
      ],
      'formats' => [
        'full',
        'keyvalue',
        'text',
      ],
      'defaultFormat' => 'text',
      'function' => 'FolderShareCommands::config',
    ],

    //
    // GET user's usage.
    //
    'usage' => [
      'synopsis' => 'usage [OPTIONS]',
      'brief' => 'Show the user\'s storage use.',
      'description' => <<<'EOS'
Report the number of top-level folders, subfolders, files, and bytes in use
by the user on the host.

The user must have permission to create and modify remote files and folders.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
      ],
      'formats' => [
        'full',
        'keyvalue',
        'text',
      ],
      'defaultFormat' => 'text',
      'function' => 'FolderShareCommands::usage',
    ],

    //
    // GET file or folder status.
    //
    'stat' => [
      'synopsis' => 'stat [OPTIONS] REMOTE_PATHS...',
      'brief' => 'Show the status of files and folders.',
      'description' => <<<'EOS'
Show detailed status for remote files or folders.

Status information includes the item's name, remote folder path, owner, size,
MIME type, numeric entity ID, parent entity ID, top-level folder entity ID,
creation date, modified date, and whether the item is private, shared with
others, or shared with the public.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to view the remote files and folders.

This command is similar to the 'stat' command on Linux, BSD, and macOS.
EOS
      ,
      'flags' => [
        '-t' => [
          'brief' => 'Show a terse one-line version of the information.',
          'synonyms' => [
            '--terse',
          ],
        ],
        '--help' => [
          'brief' => 'Show this help information.',
        ],
      ],
      'synonyms' => [
        'status',
      ],
      'formats' => [
        'full',
        'keyvalue',
        'linux',
        'text',
      ],
      'defaultFormat' => 'linux',
      'function' => 'FolderSharecommands::stat',
    ],

    //
    // GET folder contents.
    //
    'ls' => [
      'synopsis' => 'ls [OPTIONS] REMOTE_PATHS...',
      'brief' => 'List files and folders.',
      'description' => <<<'EOS'
List remote files and folders.

The command supports a default short form and a long form with the '-l' option.
Both forms default to sorting items by name:
  - The short form lists item names in multiple columns.
  - The long form lists item names and attributes in a single-column list.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to view the remote files and folders.

This command is similar to the 'ls' command on Linux, BSD, and macOS.
EOS
      ,
      'flags' => [
        '-1' => [
          'brief' => 'Force output to be one entry per line.',
        ],
        '-d' => [
          'brief' => 'List folders without recursion.',
        ],
        '-f' => [
          'brief' => 'Do not sort.',
        ],
        '-F' => [
          'brief' => 'Mark folders by adding a "/" suffix.',
        ],
        '-h' => [
          'brief' => 'Simplify numbers with byte suffixes (e.g. MB).',
        ],
        '-i' => [
          'brief' => 'Show the numeric entity ID for each item.',
        ],
        '-l' => [
          'brief' => 'Show a long form that lists more detail.',
        ],
        '-r' => [
          'brief' => 'Reverse the sort order.',
        ],
        '-R' => [
          'brief' => 'Recurse to list folder contents.',
        ],
        '-s' => [
          'brief' => 'Show the size, in bytes, for each item.',
        ],
        '-S' => [
          'brief' => 'Sort by size instead of name.',
        ],
        '-t' => [
          'brief' => 'Sort by modification time instead of name.',
        ],
        '--help' => [
          'brief' => 'Show this help information.',
        ],
      ],
      'synonyms' => [
        'list',
        'dir',
      ],
      'formats' => [
        'full',
        'keyvalue',
        'linux',
        'text',
      ],
      'defaultFormat' => 'linux',
      'function' => 'FolderShareCommands::ls',
    ],

    //
    // GET to download file.
    //
    'download' => [
      'synopsis' => 'download [OPTIONS] REMOTE_PATH [LOCAL_PATH]',
      'brief' => 'Download files and folders.',
      'description' => <<<'EOS'
Download a remote file or folder indicated to the local host.

The first path indicates a remote file or folder to download, while the second
path selects the local host location in which to save the downloaded item. If
the second path is omitted, the current directory is used and the new local
file has the same name as the remote file.

When downloading a remote folder, that folder and its contents are first
compressed into a ZIP archive and that archive is returned as a file saved onto
the local host. The ZIP archive is not automatically un-zipped.

By default, local files are silently overwritten by downloaded files. Add the
'-n' option to prevent overwriting. Downloaded files will be automatically
renamed with a unique sequence number starting at 2 (e.g. "file-2.txt").

The '-p' option sets downloaded file modification and access dates to match
those of the remote file.

The '-u' option updates downloaded files only if they are missing or the
remote file's modification date is newer than that of the local file. This
is typically used in combination with '-p' so that local and remote file
modification dates are comparable.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to view the remote files and folders, and create
the local file.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
        '-n' => [
          'brief' => 'Do not overwrite an existing local file.',
          'synonyms' => [],
        ],
        '-p' => [
          'brief' => 'Preserve timestamps on downloaded items.',
          'synonyms' => [],
        ],
        '--sync' => [
          'brief' => 'Synchronize local and remote files (same as -pu).',
          'synonyms' => [],
        ],
        '-u' => [
          'brief' => 'Update by only downloading missing or newer files.',
          'synonyms' => [],
        ],
        '-v' => [
          'brief' => 'Show the name of each item as it is downloaded.',
          'synonyms' => [],
        ],
      ],
      'synonyms' => [
        'get',
      ],
      'formats' => [],
      'defaultFormat' => '',
      'function' => 'FolderShareCommands::download',
    ],

    //
    // GET to get specific attributes of a file or folder.
    //
    'xattr' => [
      'synopsis' => 'xattr [OPTIONS] REMOTE_PATHS',
      'brief' => 'Get extended attributes of files and folders.',
      'description' => <<<'EOS'
Get extended attributes of a remote file or folder.

The path selects a remote file or folder. The path must start with '/'.
Wild cards are not supported.

Extended attributes include whether a file or folder is disabled because
it is in use by another operation.

The user must have permission to view the remote file or folder.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
        '--disabled' => [
          'brief' => 'Return "true" if the item is disabled, "false" otherwise.',
          'synonyms' => [
            '--systemdisabled',
          ],
        ],
        '--hidden' => [
          'brief' => 'Return "true" if the item is hidden, "false" otherwise.',
          'synonyms' => [
            '--systemhidden',
          ],
        ],
        '--kind' => [
          'brief' => 'Return the item kind (e.g. "file", "folder", etc.',
          'synonyms' => [],
        ],
        '--mime' => [
          'brief' => 'Return the item MIME type.',
          'synonyms' => [
            '--mimetype',
          ],
        ],
        '--size' => [
          'brief' => 'Return the item size, in bytes.',
          'synonyms' => [],
        ],
        // TODO Add view and author grant UIDs.
      ],
      'synonyms' => [],
      'formats' => [],
      'defaultFormat' => '',
      'function' => 'FolderShareCommands::xattr',
    ],

    //
    // GET and wait to check when an item becomes enabled.
    //
    'wait' => [
      'synopsis' => 'wait REMOTE_PATHS',
      'brief' => 'Wait until remote files and folders are enabled.',
      'description' => <<<'EOS'
Synchronize with remote operations by waiting until an item is enabled.

The path selects a remote file or folder. The path must start with '/'.
Wild cards are not supported.

Operations that copy, move, or change ownership can take a long time and
require background processing. Files and folders involved are marked
disabled while processing is in progress. Meanwhile, the request returns
before the full operation is complete. This command waits until the
indicated file or folder becomes marked enabled.

The user must have permission to view the remote file or folder.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
        '-v' => [
          'brief' => 'Be verbose.',
        ],
      ],
      'synonyms' => [],
      'formats' => [],
      'defaultFormat' => '',
      'function' => 'FolderShareCommands::wait',
    ],

    //
    // HTTP DELETE operations supported.
    // ---------------------------------
    //
    // DELETE file or folder.
    //
    'rm' => [
      'synopsis' => 'rm [OPTIONS] REMOTE_PATHS...',
      'brief' => 'Remove files or folders.',
      'description' => <<<'EOS'
Remove remote files and and folders.

Use 'rm' without options to remove remote files. Use 'rm -d' to also remove
empty folders. Use 'rm -r' to recursively remove files and non-empty folders
and their contents, recursively.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to remove the remote files and folders.

This command is similar to the 'rm' command on Linux, BSD, and macOS.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
        '-d' => [
          'brief' => 'Delete folders as well as files.',
          'synonyms' => [],
        ],
        '-f' => [
          'brief' => 'Force deletion to continue even after errors.',
          'synonyms' => [],
        ],
        '-r' => [
          'brief' => 'Recursively remove folders and their contents.',
          'synonyms' => [
            '-R',
          ],
        ],
        '-v' => [
          'brief' => 'Show the name of each item as it is deleted.',
          'synonyms' => [],
        ],
      ],
      'synonyms' => [
        'remove',
        'del',
        'delete',
      ],
      'formats' => [],
      'defaultFormat' => '',
      'function' => 'FolderShareCommands::rm',
    ],

    //
    // DELETE folder.
    //
    'rmdir' => [
      'synopsis' => 'rmdir [OPTIONS] REMOTE_PATHS...',
      'brief' => 'Remove empty folders.',
      'description' => <<<'EOS'
Remove remote empty folders.

Use 'rmdir' to remove remote empty folders. It is an error to attempt to
remove a non-empty folder.

To remove files and non-empty folders, use the 'rm -r' command instead.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to remove the remote folders.

This command is similar to the 'rmdir' command on Linux, BSD, and macOS.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
        '-v' => [
          'brief' => 'Show the name of each item as it is deleted.',
          'synonyms' => [],
        ],
      ],
      'formats' => [],
      'defaultFormat' => '',
      'function' => 'FolderShareCommands::rmdir',
    ],

    //
    // HTTP POST operations supported.
    // -------------------------------
    //
    // POST new root folder or subfolder.
    //
    'mkdir' => [
      'synopsis' => 'mkdir [OPTIONS] REMOTE_PATHS...',
      'brief' => 'Make new folders.',
      'description' => <<<'EOS'
Make new remote empty folders.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to create the remote folders.

This command is similar to the 'mkdir' command on Linux, BSD, and macOS.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
        '-p' => [
          'brief' => 'Create intermediate folders as required.',
          'synonyms' => [],
        ],
        '-v' => [
          'brief' => 'Show the name of each item as it is created.',
          'synonyms' => [],
        ],
      ],
      'formats' => [
        'full',
        'keyvalue',
      ],
      'defaultFormat' => 'keyvalue',
      'function' => 'FolderShareCommands::mkdir',
    ],

    //
    // POST to upload file.
    //
    'upload' => [
      'synopsis' => 'upload [OPTIONS] LOCAL_PATH REMOTE_PATH',
      'brief' => 'Upload files and folders.',
      'description' => <<<'EOS'
Upload a local file or folder to a remote folder.

The first path selects a local file or folder to upload, while the second
path indicates the remote location for the uploaded items.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to view the local file and create the remote
files and folders.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
        '-n' => [
          'brief' => 'Do not overwrite an existing remote file.',
          'synonyms' => [],
        ],
        '-p' => [
          'brief' => 'Preserve timestamps on uploaded items.',
          'synonyms' => [],
        ],
        '--sync' => [
          'brief' => 'Synchronize local and remote files (same as -pu).',
          'synonyms' => [],
        ],
        '-u' => [
          'brief' => 'Update by only uploaded missing or newer files.',
          'synonyms' => [],
        ],
        '-v' => [
          'brief' => 'Show the name of each item as it is uploaded.',
          'synonyms' => [],
        ],
      ],
      'synonyms' => [
        'put',
      ],
      'formats' => [],
      'defaultFormat' => '',
      'function' => 'FolderShareCommands::upload',
    ],

    //
    // HTTP PATCH operations supported.
    // --------------------------------
    //
    // PATCH name and/or location.
    //
    'mv' => [
      'synopsis' => 'mv [OPTIONS] REMOTE_PATHS... REMOTE_DESTINATION_PATH',
      'brief' => 'Move files and folders.',
      'description' => <<<'EOS'
Move remote files or folders.

The command has two forms:
  - With two paths, the command moves the file or folder indicated by the
    first path into the destination selected by the second path.

  - With more than two paths, the command moves the files and folders indicated
    by all of the paths, except the last, into the destination folder selected
    by the last path.

With two paths, if the destination does not exist, but its parent folder does,
the moved item will be moved into the parent and renamed to use the name in
the destination path.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to modify the remote folders.

This command is similar to the 'mv' command on Linux, BSD, and macOS.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
        '--wait' => [
          'brief' => 'Wait for move to complete.',
          'synonyms' => [
            '--wait',
          ],
        ],
        '-n' => [
          'brief' => 'Do not overwrite an existing file.',
          'synonyms' => [],
        ],
        '-v' => [
          'brief' => 'Show the name of each item as it is moved.',
          'synonyms' => [],
        ],
      ],
      'synonyms' => [
        'move',
      ],
      'formats' => [
        'full',
        'keyvalue',
      ],
      'defaultFormat' => 'keyvalue',
      'function' => 'FolderShareCommands::mv',
    ],

    //
    // PATCH to create a copy.
    //
    'cp' => [
      'synopsis' => 'cp [OPTIONS] REMOTE_PATHS... REMOTE_DESTINATION_PATH',
      'brief' => 'Copy files and folders.',
      'description' => <<<'EOS'
Copy remote files or folders.

The command has two forms:
  - With two paths, the command copies the file or folder indicated by the
    first path into the destination selected by the second path.

  - With more than two paths, the command copies the files and folders
    indicated by all of the paths, except the last, into the destination folder
    selected by the last path.

With two paths, if the destination does not exist, but its parent folder does,
the copied item will be copied into the parent and renamed to use the name in
the destination path.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to create and modify the remote files and
folders.

This command is similar to the 'cp' command on Linux, BSD, and macOS.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
        '--wait' => [
          'brief' => 'Wait for copy to complete.',
          'synonyms' => [
            '--wait',
          ],
        ],
        '-n' => [
          'brief' => 'Do not overwrite an existing file.',
          'synonyms' => [],
        ],
        '-v' => [
          'brief' => 'Show the name of each item as it is copied.',
          'synonyms' => [],
        ],
      ],
      'synonyms' => [
        'copy',
      ],
      'formats' => [
        'full',
        'keyvalue',
      ],
      'defaultFormat' => 'keyvalue',
      'function' => 'FolderShareCommands::cp',
    ],

    //
    // PATCH to update fields.
    //
    'update' => [
      'synopsis' => 'update [OPTIONS] FIELD_NAME FIELD_VALUE REMOTE_PATHS...',
      'brief' => 'Update fields on files and folders.',
      'description' => <<<'EOS'
Update the value for a named field on remote files or folders.

Fields that may be updated include:
  - 'name' = the name of the remote file or folder (see also the 'mv' command).
  - 'description' = the text description of the remote file or folder.

Additional fields may be supported by third-party extensions or customizations
made on specific hosts.

Field values that are more than one word (such as a description's text) or that
include special characters (such as in HTML) should be surrounded by quotes.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to modify the remote files and folders.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
        '-v' => [
          'brief' => 'Show the name of each item as it is changed.',
          'synonyms' => [],
        ],
      ],
      'formats' => [
        'full',
        'keyvalue',
        'text',
      ],
      'defaultFormat' => 'text',
      'function' => 'FolderShareCommands::update',
    ],

    //
    // PATCH to change ownership.
    //
    'chown' => [
      'synopsis' => 'chown [OPTIONS] USER REMOTE_PATHS...',
      'brief' => 'Change ownership on files and folders.',
      'description' => <<<'EOS'
Change the owner of a remote file or folder, and optionally its descendants.

The user argument gives a user account name or ID for the new owner. The
remainder of the arguments are remote paths to change.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to modify the ownership of remote files and
folders.
EOS
      ,
      'flags' => [
        '--help' => [
          'brief' => 'Show this help information.',
        ],
        '-v' => [
          'brief' => 'Show the name of each item as it is changed.',
          'synonyms' => [],
        ],
        '-R' => [
          'brief' => 'Recursively change all descendents too.',
          'synonyms' => [],
        ],
      ],
      'formats' => [
        'full',
        'keyvalue',
      ],
      'defaultFormat' => 'keyvalue',
      'function' => 'FolderShareCommands::chown',
    ],
  ];

  /*--------------------------------------------------------------------
   *
   * Utilities.
   *
   *--------------------------------------------------------------------*/

  /**
   * Prints an error message to STDERR.
   *
   * @param string $commandName
   *   The name of the current command.
   * @param string $message
   *   The message to print.
   */
  private static function printError(
    string $commandName,
    string $message) {

    fprintf(STDERR, "%s: %s\n", $commandName, strip_tags($message));
  }

  /**
   * Prints an exception error message to STDERR.
   *
   * @param string $commandName
   *   The name of the current command.
   * @param \Exception $e
   *   The exception with a message to print.
   */
  private static function printException(
    string $commandName,
    \Exception $e) {

    fprintf(STDERR, "%s: %s\n", $commandName, strip_tags($e->getMessage()));
  }

  /**
   * Waits for all items to be enabled.
   *
   * This function enters an infinite loop. On each pass, it checks one
   * or more of the indicated remote paths to see if the corresponding
   * item is enabled. If any item is not enabled, the pass completes
   * and the process sleeps for several seconds before the next pass
   * through the loop.
   *
   * If all of the items are enabled, then all pending operations on them
   * are presumed to be complete and this function returns.
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param string $commandName
   *   The name of the command that called this function.
   * @param string[] $remoteUris
   *   The remote file or folder URIs to monitor.
   * @param bool $verbose
   *   (optional, default = FALSE) When TRUE, print a "." after each check
   *   of the items. When FALSE, print nothing.
   */
  public static function waitUntilEnabled(
    FolderShareConnect $server,
    string $commandName,
    array $remoteUris,
    bool $verbose = FALSE) {

    // Repeatedly get each entity and check if they are all enabled.
    // If any one of them is not, wait and repeat.
    while (TRUE) {
      $anyDisabled = FALSE;
      foreach ($remoteUris as $remoteUri) {
        try {
          $response = $server->getFileOrFolder($remoteUri, FALSE);
          if (isset($response['systemdisabled']) === TRUE &&
              isset($response['systemdisabled'][0]) === TRUE &&
              isset($response['systemdisabled'][0]['value']) === TRUE &&
              $response['systemdisabled'][0]['value'] === TRUE) {
            $anyDisabled = TRUE;
            break;
          }
        }
        catch (\Exception $e) {
          self::printException($commandName, $e);
          return FALSE;
        }
      }

      if ($anyDisabled === FALSE) {
        break;
      }

      if ($verbose === TRUE) {
        print(".");
        flush();
      }

      sleep(self::DEFAULT_WAIT_UNTIL_ENABLED_TIME);
    }
  }

  /*--------------------------------------------------------------------
   *
   * Connection commands.
   *
   *--------------------------------------------------------------------*/

  /**
   * Prints host configuration parameters.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | --help | Show help on command.                            |
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @see ::hostname()
   * @see ::version()
   */
  public static function config(
    FolderShareConnect $server,
    array $options) {

    //
    // Execute
    // -------
    // Report configuration.
    try {
      $response = $server->getServerConfiguration();

      switch ($options['format']) {
        case 'keyvalue':
        case 'text':
          print(FolderShareFormat::formatAsConfiguration($response));
          break;

        default:
        case 'full':
          print_r($response);
          break;
      }
    }
    catch (\Exception $e) {
      self::printException(reset($options['command']), $e);
      return FALSE;
    }

    return TRUE;
  }

  /**
   * Prints the name of the current host.
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @see ::config()
   * @see ::version()
   */
  public static function hostname(
    FolderShareConnect $server,
    array $options) {

    printf("%s\n", $server->getHostNameAndPortNumber());
    return TRUE;
  }

  /**
   * Prints software version numbers.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | --help | Show help on command.                            |
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection. If the connection is NULL, only the client
   *   side's version information is returned.
   * @param array $options
   *   The command-line options array.
   * @param bool $doConnect
   *   (optional, default = TRUE) When TRUE, a request is sent to the server
   *   to get its version information, which is then merged with information
   *   about the client API and PHP version. When FALSE, no request is sent
   *   and the returned array only includes the client API and PHP version.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @see ::config()
   * @see ::hostname()
   */
  public static function version(
    FolderShareConnect $server,
    array $options,
    bool $doConnect = TRUE) {

    //
    // Execute
    // -------
    // Report configuration.
    try {
      $response = $server->getVersion($doConnect);

      if (is_array($response) === FALSE) {
        print_r($response);
      }
      else {
        if (isset($response['client']) === FALSE) {
          $response['client'] = [];
        }

        // Add an application entry to the front of the client version list.
        $response['client'] = array_merge(
          [
            'application' => [
              'name'      => NAME,
              'version'   => VERSION,
            ],
          ],
          $response['client']);

        if ($options['format'] === 'text') {
          print(FolderShareFormat::formatAsVersion($response));
        }
        else {
          print_r($response);
        }
      }
    }
    catch (\Exception $e) {
      self::printException(reset($options['command']), $e);
      return FALSE;
    }

    return TRUE;
  }

  /*--------------------------------------------------------------------
   *
   * User commands.
   *
   *--------------------------------------------------------------------*/

  /**
   * Prints the name of the current user.
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @see ::usage()
   */
  public static function whoami(
    FolderShareConnect $server,
    array $options) {

    $username = $server->getUserName();
    if (empty($username) === TRUE) {
      $username = self::ANONYMOUS;
    }

    printf("%s\n", $username);
    return TRUE;
  }

  /**
   * Prints file, folder, and storage usage for a user.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | --help | Show help on command.                            |
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @see ::whoami()
   */
  function usage(
    FolderShareConnect $server,
    array $options) {

    //
    // Execute
    // -------
    // Report usage.
    try {
      $response = $server->getUsage();

      switch ($options['format']) {
        case 'keyvalue':
        case 'text':
          print(FolderShareFormat::formatAsUsage($response));
          break;

        default:
        case 'full':
          print_r($response);
          break;
      }
    }
    catch (\Exception $e) {
      self::printException(reset($options['command']), $e);
      return FALSE;
    }

    return TRUE;
  }

  /*--------------------------------------------------------------------
   *
   * File and folder status commands.
   *
   *--------------------------------------------------------------------*/

  /**
   * Prints a list of files and folders.
   *
   * This command emulates the Linux/macOS/BSD "ls" command.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -1     | Force one-column output.                         |
   * | -d     | List directories without recursion.              |
   * | -f     | Do not sort.                                     |
   * | -F     | Add special symbols on files and folders.        |
   * | -h     | Simplify numbers with byte suffixes (e.g. MB).   |
   * | -i     | Include the entity ID.                           |
   * | -l     | Show a long listing format.                      |
   * | -r     | Reverse the sort order.                          |
   * | -R     | Recursively list directories.                    |
   * | -s     | Include the size of each item.                   |
   * | -S     | Sort by size.                                    |
   * | -t     | Sort by modification time.                       |
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @see ::chown()
   * @see ::stat()
   * @see ::update()
   * @see ::xattr()
   *
   * @internal
   * POSIX, Linux, macOS, and BSD "ls" support the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -1     | Force one-column output.                         |
   * | -a     | Show all entries, including "." entries.         |
   * | -c     | Show last status change time.                    |
   * | -C     | Force multi-column output.                       |
   * | -d     | List directories without recursion.              |
   * | -f     | Do not sort.                                     |
   * | -F     | Add special symbols on files and folders.        |
   * | -g     | Like -l, skip owner names (just show groups).    |
   * | -i     | Include the inode number.                        |
   * | -l     | Show a long listing format.                      |
   * | -L     | Show info on symbolic link target.               |
   * | -o     | Like -l, skip group names (just show owners).    |
   * | -q     | Replace non-printing characters with ?.          |
   * | -r     | Reverse the sort order.                          |
   * | -R     | Recursively list directories.                    |
   * | -s     | Include the size of each item.                   |
   * | -t     | Sort by modification time.                       |
   * | -u     | Sort by last access time.                        |
   *
   * Linux, macOS, and BSD support the following additional flags,
   * but not POSIX:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -h     | Simplify numbers with byte suffixes (e.g. MB).   |
   *
   * Linux and macOS support the following additional flags, but
   * not BSD:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -A     | Same as -a, but skip "." and "..".               |
   * | -H     | Follow symbolic links.                           |
   * | -k     | Show sizes in kilobytes, not blocks.             |
   * | -m     | Full width output with comma separated entries.  |
   * | -n     | Like -l, show numeric IDs.                       |
   * | -p     | Append '/' to directory names.                   |
   * | -S     | Sort by size.                                    |
   * | -x     | Order values side-to-side, instead of up-and-down.|
   *
   * Linux supports the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -b     | Show non-printing characters with C escape codes.|
   * | -B     | Ignore backup files ending with "~".             |
   * | -D     | Generate output for Emacs dired mode.            |
   * | -G     | With -l, skip group names.                       |
   * | -I     | Suppress entries matching a pattern.             |
   * | -N     | Print raw names, including control characters.   |
   * | -Q     | Enclose names in double-quotes.                  |
   * | -T     | Set tab stops.                                   |
   * | -U     | Do not sort.                                     |
   * | -v     | Use a natural sort for numbers in text.          |
   * | -w     | Set output width.                                |
   * | -X     | Sort by file name extension.                     |
   * | --all        | Same as -a.                                |
   * | --almost-all | Same as -A.                                |
   * | --author     | With -l, print the author of each file.    |
   * | --escape     | Same as -b.                                |
   * | --block-size | Show sizes in blocks.                      |
   * | --classify   | Same as -F.                                |
   * | --color      | Colorize output.                           |
   * | --dereference| Same as -L.                                |
   * | --dereference-command-line | Same as -H.                  |
   * | --dereference-command-line-symlink-to-dir| Follow symbolic links to dirs.|
   * | --directory  | Same as -d.                                |
   * | --dired      | Same as -D.                                |
   * | --file-type  | Same as -F, but don't add '*' on executables.|
   * | --format     | Customize formatting.                      |
   * | --full-time  | Same as -l, but use full ISO times.        |
   * | --help       | Show help on command.                      |
   * | --hide       | Hide entries that match a pattern.         |
   * | --hide-control-chars| Same as -q.                         |
   * | --human-readable | Same as -h.                            |
   * | --ignore     | Same as -I.                                |
   * | --ignore-backups | Same as -B.                            |
   * | --indicator-style| Same as -p, --file-type, or -F.        |
   * | --inode      | Same as -i.                                |
   * | --literal    | Same as -N.                                |
   * | --no-group   | Same as -G.                                |
   * | --quote-name | Same as -Q.                                |
   * | --quoting-style| Same as -Q but specify quoting.          |
   * | --numeric-uid-gid | Same as -n.                           |
   * | --recursive  | Same as -R.                                |
   * | --reverse    | Same as -r.                                |
   * | --show-control-characters| Show non-printing characters as-is.|
   * | --si         | Same as -h, but use powers of 1000 not 1024.|
   * | --size       | Same as -s.                                |
   * | --sort       | Select the sort key.                       |
   * | --tabsize    | Same as -T.                                |
   * | --time       | Select different time value.               |
   * | --time-style | Select time formatting.                    |
   * | --width      | Same as -w.                                |
   * | --version    | Show version information.                  |
   *
   * macOS supports the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -@     | With -l, show extended attributes.               |
   * | -b     | Show non-printing characters with octal escapes. |
   * | -B     | Same as -b, but use C escape codes too.          |
   * | -e     | With -l, show ACLs.                              |
   * | -G     | Colorize output.                                 |
   * | -O     | With -l, include file flags.                     |
   * | -P     | Show in on symbolic link, not target.            |
   * | -T     | With -l, show full detailed time.                |
   * | -U     | Sort by creation time.                           |
   * | -v     | Show non-printing characters as-is.              |
   * | -w     | Force raw printing of non-printable characters.  |
   * | -W     | Show whiteouts when scanning directories.        |
   *
   * For FolderShare, some of the above do not apply:
   *
   * - -b:  Linux/macOS "ls -b" shows names with non-printing characters using C
   *   escape codes. But FolderShare does not allow non-printing characters in
   *   names. A "-b" option has no meaning here.
   *
   * - -c:  Linux/macOS/BSD distinguish between when a file's content was
   *   last modified, and when its status (e.g. permissions, ownership) was
   *   last changed. "ls" defaults to showing the last content modified time.
   *   The "-c" option shifts to showing the last status change time.
   *   FolderShare only has one change time to show. A "-c" option has
   *   no meaning here.
   *
   * - -C:  Linux/macOS/BSD "ls" defaults to showing multi-column output on a
   *   terminal, but single-column output when redirected to a file. The "-C"
   *   option overrides this and forces multi-column output. This client,
   *   however, doesn't make a distinction between terminal and redirected
   *   output, so it always defaults to multi-column output. It only goes
   *   single column with the "-1" option. A "-C" option is redundant here.
   *
   * - -g:  Linux/macOS/BSD "ls" defaults to showing user names and group
   *   names in a "-l" output. The "-g" option suppresses the owner names
   *   and just shows group names. But FolderShare has no notion of account
   *   groups, so there are no group names to show.  A "-g" option has no
   *   meaning here.
   *
   * - -G:  Linux "ls -G" is the same as "ls -lo". It outputs a list that
   *   skips group names. But FolderShare has no notion of account groups,
   *   so there are no group names to show anyway. A "-G" option has no
   *   meaning here.
   *
   * - -H: Linux/macOS with "-H" will follow symbolic links. But FolderShare
   *   has no notion of symbolic links, so there is nothing to do with this.
   *   A "-H" option has no meaning here.
   *
   * - -k: Linux/macOS "ls" defaults to showing file/folder sizes in blocks.
   *   The "-k" option shifts to kilobytes, which is usually more useful.
   *   But FolderShare has no notion of blocks and always shows sizes in
   *   bytes. A "-k" option is redundant here.
   *
   * - -L:  Linux/macOS/BSD "ls" with "-l" shows symbolic links with the link's
   *   size and date. Add "-L" and it shows the symbolic link target's size
   *   and date instead. But FolderShare has no notion of symbolic links,
   *   so there is nothing to show. A "-L" option has no meaning here.
   *
   * - -N:  Linux "ls" with "-N" suppress showing non-printing characters as
   *   "?" characters and instead shows them as-is. Since FolderShare does not
   *   support non-printing characters, the "-N" option has nothing to do.
   *   The "-N" option is redundant here.
   *
   * - -o:  Linux/macOS/BSD "ls" defaults to showing user names and group
   *   names in a "-l" output. The "-o" option suppresses the group names
   *   and just shows owner names. But FolderShare has no notion of account
   *   groups, so there is nothing to suppress. A "-o" option is redundant.
   *
   * - -q: Linux/macOS/BSD "ls" defaults to showing non-printing characters as
   *   "?" characters when outputing to a terminal, and disables this when
   *   redirected to a file. The "-q" option forces redirected output to revert
   *   to terminal-style output. But this client does not make a distinction
   *   between terminal and redirected output. Further, FolderShare does not
   *   support non-printing characters in file names. A "-q" option has no
   *   meaning here.
   *
   * - -u: Linux/macOS/BSD "ls" defaults to sorting by name. The "-t" option
   *   sorts instead by modification date, and the "-u" option sorts by
   *   access time. But FolderShare does not maintain access times. A "-u"
   *   option has no meaning here.
   *
   * - -v: macOS "ls -v" is the same as Linux "ls -N" above and shows names
   *   as-is, even with non-printing characters. FolderShare does not support
   *   non-printing characters in names. A "-v" option has no meaning here.
   *
   * And so on. The above is enough to get the idea. Options that deal with
   * non-printing characters, creation times, symbolic links, or screen width
   * have no meaning here.
   */
  public static function ls(
    FolderShareConnect $server,
    array $options) {

    //
    // Parse options
    // -------------
    // Synonyms have already been mapped to primary flag names.
    $recurse = FALSE;
    $formatFlags = [];

    foreach ($options['flags'] as $flagName) {
      switch ($flagName) {
        case '-d':
          $recurse = FALSE;
          break;

        case '-R':
          $recurse = TRUE;
          break;

        case '-1':
        case '-f':
        case '-F':
        case '-h':
        case '-i':
        case '-l':
        case '-r':
        case '-s':
        case '-S':
        case '-t':
          $formatFlags[] = $flagName;
          break;
      }
    }

    //
    // Validate
    // --------
    // If there are no paths given, default to to the user's root list ('/').
    $remoteUris = $options['paths'];
    if (empty($remoteUris) === TRUE) {
      $remoteUris = ['/'];
    }
    else {
      $remoteUris = FolderShareConnect::normalizeUris($remoteUris, FALSE);
    }

    if ($recurse === TRUE &&
        $options['format'] !== 'linux') {
      self::printError(
        reset($options['command']),
        "Recursive lists must use a 'linux' output format.");
      return FALSE;
    }

    //
    // Execute
    // -------
    // Get a list of entities. Format the response using the flags, if any.
    try {
      while (empty($remoteUris) === FALSE) {
        $remoteUri = array_shift($remoteUris);

        if ($recurse === TRUE) {
          print("$remoteUri:\n");
        }

        // Get the list.
        switch ($remoteUri) {
          case '/':
          case '/personal':
            $response = $server->getRootItems('personal');
            break;

          case '/public':
            $response = $server->getRootItems('public');
            break;

          default:
            $response = $server->getDescendants($remoteUri);
            break;
        }

        // Print the response.
        if (empty($response) === FALSE) {
          switch ($options['format']) {
            case 'linux':
              print(FolderShareFormat::formatAsLinuxLs($response, $formatFlags));
              break;

            case 'text':
              print(FolderShareFormat::formatAsText($response));
              break;

            default:
            case 'full':
            case 'keyvalue':
              print_r($response);
          }
        }

        // Update the paths array by adding child paths to the front.
        if ($recurse === TRUE) {
          $recurseUris = [];
          if (is_array($response) === TRUE) {
            // Loop through the response and create a path for each folder item.
            foreach ($response as $r) {
              if (isset($r['path']) === TRUE && isset($r['kind']) === TRUE) {
                $k = $r['kind'];
                if ($k === 'folder') {
                  $recurseUris[] = $r['path'];
                }
              }
            }
          }

          // Add recursion paths to the front of the path list.
          // This causes us to do a depth-first traversal.
          $remoteUris = array_merge($recurseUris, $remoteUris);

          if (empty($remoteUris) === FALSE) {
            print("\n");
          }
        }
      }
    }
    catch (\Exception $e) {
      self::printException(reset($options['command']), $e);
      return FALSE;
    }

    return TRUE;
  }

  /**
   * Prints file or folder status.
   *
   * This command emulates the Linux/macOS/BSD "stat" command.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -t     | Show a terse form of the information.            |
   * | --help | Show help on command.                            |
   * | --terse| Same as -t.                                      |
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @see ::chown()
   * @see ::ls()
   * @see ::update()
   * @see ::xattr()
   *
   * @internal
   * Linux "stat" supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -c     | Use a custom output format.                      |
   * | -f     | Show file system status instead of file status.  |
   * | -L     | Follow symbolic links.                           |
   * | -t     | Show a terse form of the information.            |
   * | --dereference | Same as -L.                               |
   * | --filesystem  | Same as -f.                               |
   * | --format      | Same as -c.                               |
   * | --help        | Show help on command.                     |
   * | --terse       | Same as -t.                               |
   * | --version     | Show version information.                 |
   *
   * BSD and macOS "stat" support the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -f     | Use a custom output format.                      |
   * | -F     | Add special symbols on files and folders.        |
   * | -l     | Same as "ls -lT".                                |
   * | -L     | Follow symbolic links.                           |
   * | -n     | Suppress newline after each item.                |
   * | -q     | Suppress error messages.                         |
   * | -r     | Show raw information from the 'stat' syscall.    |
   * | -s     | Show information in a shell compatible format.   |
   * | -t     | Display time stamps in a custom output format.   |
   * | -x     | Show a verbose output format similar to Linux.   |
   *
   * BSD supports the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -H     | Treat arguments as hex NFS file handles.         |
   *
   * There is no POSIX "stat" command.
   *
   * The set of flags for Linux and macOS/BSD are entirely disjoint -
   * there is nothing in common. Some flags, like -t, show up in both
   * versions of "stat", but with different meanings.
   */
  public static function stat(
    FolderShareConnect $server,
    array $options) {

    //
    // Parse flags
    // -----------
    // Synonyms have already been mapped to primary flag names.
    $terseMode = FALSE;

    foreach ($options['flags'] as $flagName) {
      switch ($flagName) {
        case '-t':
          $terseMode = TRUE;
          break;
      }
    }

    //
    // Validate
    // --------
    // If there are no remote URIs given, default to the user's
    // root list at '/'.
    $remoteUris = $options['paths'];
    if (empty($remoteUris) === TRUE) {
      $remoteUris = ['/'];
    }
    else {
      $remoteUris = FolderShareConnect::normalizeUris($remoteUris);
    }

    //
    // Execute
    // -------
    // Get entity information. Do not recurse into folders.
    try {
      foreach ($remoteUris as $remoteUri) {
        $response = $server->getFileOrFolder($remoteUri, FALSE);

        if (empty($response) === FALSE) {
          switch ($options['format']) {
            case 'linux':
              print(FolderShareFormat::formatAsLinuxStat($response, $terseMode));
              break;

            case 'text':
            case 'keyvalue':
              print(FolderShareFormat::formatAsText($response));
              break;

            case 'full':
            default:
              print_r($response);
              break;
          }
        }
      }
    }
    catch (\Exception $e) {
      self::printException(reset($options['command']), $e);
      return FALSE;
    }

    return TRUE;
  }

  /**
   * Waits until a file or folder becomes enabled.
   *
   * This command does not emulate any particular Linux/macOS/BSD
   * command, though it is very roughly modeled after the "sync"
   * command.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | --help | Show help on command.                            |
   * | -v     | Be verbose.                                      |
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @see ::waitUntilEnabled()
   */
  public static function wait(
    FolderShareConnect $server,
    array $options) {

    //
    // Parse flags
    // -----------
    // Synonyms have already been mapped to primary flag names.
    $verbose = FALSE;

    foreach ($options['flags'] as $flagName) {
      switch ($flagName) {
        case '-v':
          $verbose = TRUE;
          break;
      }
    }

    //
    // Validate
    // --------
    // If there are no paths given, default to '/'.
    $remoteUris = $options['paths'];
    if (empty($remoteUris) === TRUE) {
      $remoteUris = ['/'];
    }
    else {
      $remoteUris = FolderShareConnect::normalizeUris($remoteUris);
    }

    //
    // Execute
    // -------
    // Repeatedly get each entity and check if they are all enabled.
    // If any one of them is not, wait and repeat.
    self::waitUntilEnabled(
      $server,
      reset($options['command']),
      $remoteUris,
      $verbose);
    return TRUE;
  }

  /**
   * Prints extended attributes values.
   *
   * This command does not emulate any particular Linux/macOS/BSD
   * command, though it is named after the macOS "xattr" command.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | --help | Show help on command.                            |
   * | --ATTR | The name of an attribute.                        |
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @see ::ls()
   * @see ::stat()
   * @see ::update()
   */
  public static function xattr(
    FolderShareConnect $server,
    array $options) {

    //
    // Parse flags
    // -----------
    // Synonyms have already been mapped to primary flag names.
    $attrs = [];

    foreach ($options['flags'] as $flagName) {
      switch ($flagName) {
        case '--disabled':
          $attrs['systemdisabled'] = 'bool';
          break;

        case '--hidden':
          $attrs['systemhidden'] = 'bool';
          break;

        case '--kind':
          $attrs['kind'] = 'string';
          break;

        case '--mime':
          $attrs['mime'] = 'string';
          break;

        case '--size':
          $attrs['size'] = 'int';
          break;
      }
    }

    if (empty($attrs) === TRUE) {
      // Default to all available attributes.
      $attrs = [
        'systemdisabled' => 'bool',
        'systemhidden'   => 'bool',
        'kind'           => 'string',
        'mime'           => 'string',
        'size'           => 'int',
      ];
    }

    $nAttrs = count($attrs);

    //
    // Validate
    // --------
    // If there are no paths given, default to '/'.
    $remoteUris = $options['paths'];
    if (empty($remoteUris) === TRUE) {
      $remoteUris = ['/'];
    }
    else {
      $remoteUris = FolderShareConnect::normalizeUris($remoteUris);
    }

    //
    // Execute
    // -------
    // Get entity information.
    try {
      foreach ($remoteUris as $remoteUri) {
        $response = $server->getFileOrFolder($remoteUri, FALSE);

        foreach ($attrs as $attr => $cast) {
          if (isset($response[$attr]) === TRUE &&
              isset($response[$attr][0]) === TRUE &&
              isset($response[$attr][0]['value']) === TRUE) {
            $value = $response[$attr][0]['value'];
            if ($nAttrs > 1) {
              print("$attr: ");
            }

            switch ($cast) {
              case 'bool':
                if (empty($value) === TRUE || $value === FALSE) {
                  print("false\n");
                }
                else {
                  print("true\n");
                }
                break;

              case 'string':
                print((string) $value . "\n");
                break;

              case 'int':
                print((int) $value . "\n");
                break;
            }
          }
        }
      }
    }
    catch (\Exception $e) {
      self::printException(reset($options['command']), $e);
      return FALSE;
    }

    return TRUE;
  }

  /**
   * Updates file and folder field values.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -v     | Show the name of each item modified.             |
   * | --help | Show help on command.                            |
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @see ::chown()
   * @see ::ls()
   * @see ::stat()
   * @see ::xattr()
   *
   * @internal
   * There is no standard Linux/macOS/BSD command for changing file metadata.
   *
   * The Linux 'getfattr' and 'setfattr' commands get and set arbitrary file
   * metadata:
   * - getfattr -d files...
   *   Print all metadata.
   *
   * - getfattr -n fieldname files...
   *   Print the metadata for the selected field.
   *
   * - setfattr -n fieldname -v fieldvalue files...
   *   Write the metadata for the selected field.
   *
   * - setfattr -x fieldname files...
   *   Delete the metadata for the selected field.
   *
   * The Linux commands support the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -e     | Set text encoding.                               |
   * | -h     | Apply to link, not target of link.               |
   * | -m     | Only show fields that match a pattern.           |
   * | -R     | Recurse into directories.                        |
   * | -L     | Follow symbolic links.                           |
   * | -P     | Do not follow symbolic links.                    |
   * | --absolute-name | Don't remove leading '/'.               |
   * | --dump    | Same as -d.                                   |
   * | --encoding| Same as -e.                                   |
   * | --help    | Show help on command.                         |
   * | --logical | Same as -L.                                   |
   * | --match   | Same as -m.                                   |
   * | --no-dereference| Same as -h.                             |
   * | --only-values | Only print out field values.              |
   * | --physical| Same as -P.                                   |
   * | --recursive| Same as -r.                                  |
   * | --version | Show version information.                     |
   *
   * The macOS 'xattr' command gets, sets, and deletes arbitrary file metadata:
   * - xattr files...
   *   Print all metadata.
   *
   * - xattr -p fieldname files...
   *   Print the metadata for the selected field.
   *
   * - xattr -w fieldname fieldvalue files...
   *   Write the metadata for the selected field.
   *
   * - xattr -d fieldname files...
   *   Delete the metadata for the selected field.
   *
   * - xattr -c files...
   *   Clear all metadata.
   *
   * The macOS commands support the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -l     | Long form that shows field names and values.     |
   * | -r     | Recurse into directories.                        |
   * | -s     | Apply to link, not target of link.               |
   * | -v     | Show the name of each item modified.             |
   * | -x     | Print output in hex.                             |
   *
   * The BSD 'getextattr', 'lsextattr', 'rmextattr', and 'setextattr' commands
   * get, list, delete, and set arbitrary file metadata:
   * - lsextattr namespace files...
   *   Print all metadata. 'namespace' is either 'user' or 'system'.
   *
   * - getextattr namespace fieldname files...
   *   Print the metadata for the selected field.
   *
   * - setextattr namespace fieldname fieldvalue files...
   *   Write the metadata for the selected field.
   *
   * - rmextattr namespace fieldname files...
   *   Delete the metadata for the selected field.
   *
   * The BSD commands support the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -f     | Don't prompt for comfirmation and ignore errors. |
   * | -h     | Apply to link, not target of link.               |
   * | -i     | Read attributes from stdin.                      |
   * | -n     | NULL terminate output data.                      |
   * | -q     | Be quiet, don't print path name or errors.       |
   * | -s     | Convert non-printing characters to escapes.      |
   * | -x     | Print output in hex.                             |
   *
   * This FolderShare "update" supports a structure similar to the Linux,
   * macOS, and BSD commands, but not identical to any of them.
   *
   * - FolderShare does not have arbitrary metadata - the fields have
   *   to be predefined by the FolderShare module, by third-party
   *   modules, or by the site administrator. So Linux/macOS/BSD-style
   *   operations to create or delete metadata fields are not meaningful.
   *
   * - The 'stat' command already outputs all entity fields. All we need
   *   here is a command to update them.
   *
   * - The Linux, macOS, and BSD commands all have a form that gives
   *   the name of a field, the value, and a list of files. We use
   *   that same form.
   */
  public static function update(
    FolderShareConnect $server,
    array $options) {

    //
    // Parse options
    // -------------
    // Synonyms have already been mapped to primary flag names.
    $verbose = FALSE;

    foreach ($options['flags'] as $flagName) {
      switch ($flagName) {
        case '-v':
          $verbose = TRUE;
          break;
      }
    }

    //
    // Validate
    // --------
    // The command must have at least:
    // - A field name.
    // - A field value.
    // - A path.
    //
    // All further items are paths for additional entities.
    $remoteUris = FolderShareConnect::normalizeUris($options['paths']);
    switch (count($remoteUris)) {
      case 0:
        self::printError(
          reset($options['command']),
          "Missing field name, value, and remote file path.");
        return FALSE;

      case 1:
        self::printError(
          reset($options['command']),
          "Missing field value and remote file path.");
        return FALSE;

      case 2:
        self::printError(
          reset($options['command']),
          "Missing remote file path.");
        return FALSE;

      case 3:
        $fieldName = array_shift($remoteUris);
        $fieldValue = array_shift($remoteUris);
        break;

      default:
        self::printError(
          reset($options['command']),
          "Too many arguments.");
        return FALSE;
    }

    //
    // Execute
    // -------
    // Change a series of items.
    try {
      foreach ($remoteUris as $remoteUri) {
        if ($verbose === TRUE) {
          print("$remoteUri\n");
        }

        // There is normally no response.
        $response = $server->update($remoteUri, $fieldName, $fieldValue);

        if (empty($response) === FALSE) {
          print_r($response);
        }
      }
    }
    catch (\Exception $e) {
      self::printException(reset($options['command']), $e);
      return FALSE;
    }

    return TRUE;
  }

  /**
   * Changes the owner of files and folders.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -R     | Recursively change descendents.                  |
   * | -v     | Show the name of each item modified.             |
   * | --help | Show help on command.                            |
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @see ::ls()
   * @see ::stat()
   * @see ::xattr()
   */
  public static function chown(
    FolderShareConnect $server,
    array $options) {

    //
    // Parse options
    // -------------
    // Synonyms have already been mapped to primary flag names.
    $verbose = FALSE;
    $recurse = FALSE;

    foreach ($options['flags'] as $flagName) {
      switch ($flagName) {
        case '-R':
          $recurse = TRUE;
          break;

        case '-v':
          $verbose = TRUE;
          break;
      }
    }

    //
    // Validate
    // --------
    // The command must have at least:
    // - A user name or ID.
    // - A path.
    //
    // All further items are paths for additional entities.
    $userName = '';
    switch (count($options['paths'])) {
      case 0:
        self::printError(
          reset($options['command']),
          "Missing user name and remote file path.");
        return FALSE;

      case 1:
        self::printError(
          reset($options['command']),
          "Missing remote file path.");
        return FALSE;

      default:
        break;
    }

    $userName = array_shift($options['paths']);
    $remoteUris = FolderShareConnect::normalizeUris($options['paths']);

    //
    // Execute
    // -------
    // Change a series of items.
    try {
      foreach ($remoteUris as $remoteUri) {
        if ($verbose === TRUE) {
          print("$remoteUri\n");
        }

        // There is normally no response.
        $response = $server->changeOwner($userName, $remoteUri, $recurse);

        if (empty($response) === FALSE) {
          print_r($response);
        }
      }
    }
    catch (\Exception $e) {
      self::printException(reset($options['command']), $e);
      return FALSE;
    }

    return TRUE;
  }

  /*--------------------------------------------------------------------
   *
   * File and folder delete commands.
   *
   *--------------------------------------------------------------------*/

  /**
   * Deletes files and folders.
   *
   * This command emulates the Linux/macOS/BSD "rm" command.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -d     | Remove directories as well as files.             |
   * | -f     | Don't prompt for comfirmation and ignore errors. |
   * | -R     | Recursively delete directory trees (implies -d). |
   * | -r     | Same as -R.                                      |
   * | -v     | Print the name of each item as it is deleted.    |
   * | --help | Show help on command.                            |
   *
   * By default, this method does not remove folders. Use "-d"
   * to remove a file or folder.
   *
   * By default, this method does not recurse and will not remove
   * folders that are not empty. Use "-r" to recurse.
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @internal
   * POSIX, Linux, macOS, and BSD "rm" support the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -f     | Don't prompt for comfirmation and ignore errors. |
   * | -i     | Interactively confirm each item before deletion. |
   * | -R     | Recursively delete directory trees (implies -d). |
   * | -r     | Same as -R.                                      |
   *
   * Linux, macOS, and BSD "rm" support the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -v     | Print the name of each item as it is deleted.    |
   *
   * macOS and BSD "rm" support the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -d     | Remove directories as well as files.             |
   * | -P     | Overwrite regular files before deleting them.    |
   * | -W     | Undelete white-out deleted files.                |
   *
   * BSD "rm" supports the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -I     | Interactively confirm deletes > 3 files or dirs. |
   * | -x     | Do not cross mount points during recursive delete.|
   *
   * All Linux versions of "rm" support the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -I     | Interactively confirm deletes > 3 files or dirs. |
   * | --force            | Same as -f.                          |
   * | --help             | Show help on command.                |
   * | --interactive=WHEN | Same as -i and -I.                   |
   * | --no-preserve-root | Don't prevent '/' delete.            |
   * | --one-file-system  | Same as BSD -x.                      |
   * | --preserve-root    | Do prevent '/' delete.               |
   * | --recursive        | Same as -R.                          |
   * | --verbose          | Same as -v.                          |
   * | --version          | Show version information.            |
   *
   * RedHat Linux "rm" supports the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -d     | Remove directories as well as files.             |
   * | --directory        | Same as -d.                          |
   *
   * CentOS Linux "rm" supports the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -d     | Remove directories as well as files.             |
   * | --dir  | Same as -d.                                      |
   */
  public static function rm(
    FolderShareConnect $server,
    array $options) {

    //
    // Parse flags
    // -----------
    // Synonyms have already been mapped to primary flag names.
    $verbose      = FALSE;
    $recurse      = FALSE;
    $fileOrFolder = FALSE;
    $ignoreErrors = FALSE;

    foreach ($options['flags'] as $flagName) {
      switch ($flagName) {
        case '-d':
          $fileOrFolder = TRUE;
          break;

        case '-f':
          $ignoreErrors = TRUE;
          break;

        case '-r':
          $recurse = TRUE;
          $fileOrFolder = TRUE;
          break;

        case '-v':
          $verbose = TRUE;
          break;
      }
    }

    //
    // Validate
    // --------
    // There must be at least one path.
    if (empty($options['paths']) === TRUE) {
      self::printError(
        reset($options['command']),
        "Missing remote file path.");
      return FALSE;
    }

    //
    // Execute
    // -------
    // Remove each of the indicated entities.
    $remoteUris = FolderShareConnect::normalizeUris($options['paths']);
    foreach ($remoteUris as $remoteUri) {
      if ($verbose === TRUE) {
        print("$remoteUri\n");
      }

      try {
        // There is normally no response.
        if ($fileOrFolder === FALSE) {
          $response = $server->deleteFile($remoteUri);
        }
        else {
          $response = $server->deleteFileOrFolder($remoteUri, $recurse);
        }

        if (empty($response) === FALSE) {
          print_r($response);
        }
      }
      catch (\Exception $e) {
        if ($ignoreErrors === TRUE) {
          // The -f flag was given, which blocks does-not-exist error
          // messages and setting the exit code to failure on messages.
          continue;
        }

        self::printException(reset($options['command']), $e);
        return FALSE;
      }
    }

    return TRUE;
  }

  /**
   * Deletes empty folders.
   *
   * This command emulates the Linux/macOS/BSD "rmdir" command.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -v     | Show the name of each item deleted.              |
   * | --help | Show help on command.                            |
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @internal
   * POSIX, Linux, macOS, and BSD "rmdir" support the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -p     | Remove every directory on the path.              |
   *
   * Linux supports the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -v     | Show the name of each item deleted.              |
   * | --help    | Show help on command.                         |
   * | --ignore-fail-on-non-empty | Ignore non-empty errors.     |
   * | --parents | Same as -p.                                   |
   * | --verbose | Same as -v.                                   |
   * | --version | Show version information.                     |
   *
   * BSD supports the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -v     | Show the name of each item deleted.              |
   */
  public static function rmdir(
    FolderShareConnect $server,
    array $options) {

    //
    // Parse flags
    // -----------
    // Synonyms have already been mapped to primary flag names.
    $verbose = FALSE;

    foreach ($options['flags'] as $flagName) {
      switch ($flagName) {
        case '-v':
          $verbose = TRUE;
          break;
      }
    }

    //
    // Validate
    // --------
    // There must be at least one path.
    if (empty($options['paths']) === TRUE) {
      self::printError(
        reset($options['command']),
        "Missing remote file path.");
      return FALSE;
    }

    //
    // Execute
    // -------
    // Remove each of the indicated entities.
    $remoteUris = FolderShareConnect::normalizeUris($options['paths']);
    try {
      foreach ($remoteUris as $remoteUri) {
        if ($verbose === TRUE) {
          print("$remoteUri\n");
        }

        // There is normally no response.
        $response = $server->deleteFolder($remoteUri);

        if (empty($response) === FALSE) {
          print_r($response);
        }
      }
    }
    catch (\Exception $e) {
      self::printException(reset($options['command']), $e);
      return FALSE;
    }

    return TRUE;
  }

  /*--------------------------------------------------------------------
   *
   * Folder create commands.
   *
   *--------------------------------------------------------------------*/

  /**
   * Creates a new root folder or subfolder.
   *
   * This command emulates the Linux/macOS/BSD "mkdir" command.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -p     | Create intermediate folders as required.         |
   * | -v     | Show the name of each item created.              |
   * | --help | Show help on command.                            |
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @internal
   * POSIX, Linux, macOS, and BSD "mkdir" support the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -m     | Set the permissions mode for new directories.    |
   * | -p     | Create parent directories too, if needed.        |
   * | -v     | Show the name of each item created.              |
   *
   * Linux has the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | --help    | Show help on command.                         |
   * | --mode    | Same as -m.                                   |
   * | --parents | Same as -p.                                   |
   * | --verbose | Same as -v.                                   |
   * | --version | Show version information.                     |
   */
  public static function mkdir(
    FolderShareConnect $server,
    array $options) {

    //
    // Parse options
    // -------------
    // Synonyms have already been mapped to primary flag names.
    $verbose = FALSE;
    $createAncestors = FALSE;

    foreach ($options['flags'] as $flagName) {
      switch ($flagName) {
        case '-p':
          $createAncestors = TRUE;
          break;

        case '-v':
          $verbose = TRUE;
          break;
      }
    }

    //
    // Validate
    // --------
    // There must be at least one path.
    if (empty($options['paths']) === TRUE) {
      self::printError(
        reset($options['command']),
        "Missing remote file path.");
      return FALSE;
    }

    $remoteUris = FolderShareConnect::normalizeUris($options['paths']);

    //
    // Execute
    // -------
    // Create a series of folders. None of these should already exist.
    // If one does, report an error.
    //
    // For each path, build a list of folders to create for that path.
    // Without "-p", this will just be the last folder on the path.
    // But with "-p", this may include any of the intermediate folders
    // that do not exist.
    foreach ($remoteUris as $remoteUri) {
      $foldersToCreate = [];

      // We have these cases:
      // - The path is only a /. Report an error.
      // - The path does not start with a /. Report an error.
      // - The only / is at the start. Create a root folder.
      // - The last slash is anywhere in the middle. Create a subfolder.
      if ($remoteUri === '/') {
        self::printError(
          reset($options['command']),
          "The remote \"/\" folder already exists.");
        return FALSE;
      }

      $firstCharacter = mb_substr($remoteUri, 0, 1);
      if ($firstCharacter !== '/') {
        self::printError(
          reset($options['command']),
          "Paths must start with '/'.");
        return FALSE;
      }

      $indexOfLastSlash = mb_strrpos($remoteUri, '/');

      if ($indexOfLastSlash === 0) {
        // The path has the form "/ROOT" without further slashes.
        // Verify that it doesn't exist.
        try {
          $response = $server->getFileOrFolder($remoteUri, FALSE);

          self::printError(
            reset($options['command']),
            "A file or folder \"$remoteUri\" already exists.");
          return FALSE;
        }
        catch (\Exception $e) {
          // The root folder doesn't exist. Add it to the creation list.
          $foldersToCreate[] = [
            'parent' => '/',
            'name'   => mb_substr($remoteUri, 1),
          ];
        }
      }
      elseif ($createAncestors === FALSE) {
        // The path has the form "/ROOT/CHILD...". Do not create ancestors,
        // so verify that they all exist and are folders.
        $parent = mb_substr($remoteUri, 0, $indexOfLastSlash);
        $name = mb_substr($remoteUri, ($indexOfLastSlash + 1));

        try {
          $response = $server->getFileOrFolder($parent, FALSE);

          if ($response['kind'] !== 'folder') {
            // Parent is not a folder!
            self::printError(
              reset($options['command']),
              "\"$parent\" is not a folder.");
            return FALSE;
          }
        }
        catch (\Exception $e) {
          $commandName = reset($options['command']);
          print("$commandName: " . strip_tags($e->getMessage()) . "\n");
          return FALSE;
        }

        try {
          $response = $server->getFileOrFolder($remoteUri, FALSE);

          self::printError(
            reset($options['command']),
            "A remote file or folder \"$remoteUri\" already exists.");
          return FALSE;
        }
        catch (\Exception $e) {
          // The parent exists, but the child doesn't. Add the child to
          // the creation list.
          $foldersToCreate[] = [
            'parent' => $parent,
            'name'   => $name,
          ];
        }
      }
      else {
        // The path has the form "/ROOT/CHILD...". Do create ancestors
        // as needed. Loop over all of the ancestors and add them to list
        // to create if they don't already exist. If they do exist, make
        // sure they are folders.
        $names = mb_split('/', $remoteUri);
        array_shift($names);
        $parent = '/';
        $ancestorsExist = TRUE;

        // Loop through the names on the path, starting with the root.
        $n = count($names);
        for ($i = 0; $i < $n; ++$i) {
          $name = $names[$i];
          $path = ($parent === '/') ? ('/' . $name) : ($parent . '/' . $name);
          $errorIfExists = ($i === ($n - 1));

          if ($ancestorsExist === TRUE) {
            // The ancestors so far exist, but the new child might not.
            // Test first.
            try {
              $response = $server->getFileOrFolder($path, FALSE);

              if ($errorIfExists === TRUE) {
                // The last item on the path already exists, report an error.
                self::printError(
                  reset($options['command']),
                  "A file or folder \"$path\" already exists.");
                return FALSE;
              }

              if ($response['kind'] !== 'folder') {
                // Ancestor is not a folder!
                self::printError(
                  reset($options['command']),
                  "\"$parent\" is not a folder.");
                return FALSE;
              }

              // Otherwise it is OK that the ancestor exists. Don't add it
              // to the list of folders to create and keep going to check
              // the next name on the path.
            }
            catch (\Exception $e) {
              // The child doesn't exist. Add it to the list and note that we
              // found an ancestor that doesn't exist.  All further children
              // won't exist either, so there is no further need to test them.
              $foldersToCreate[] = [
                'parent' => $parent,
                'name'   => $name,
              ];
              $ancestorsExist = FALSE;
            }
          }
          else {
            // The ancestors don't exist yet, so the child can't exist
            // either. Just add it to the list.
            $foldersToCreate[] = [
              'parent' => $parent,
              'name'   => $name,
            ];
          }

          $parent = $path;
        }
      }

      // Now create each of the folders. Usually there will be just one,
      // but if "-p" was given, there may be multiple folders to create.
      foreach ($foldersToCreate as $folderInfo) {
        $name = $folderInfo['name'];
        $parent = $folderInfo['parent'];
        if ($parent === '/') {
          $path = '/' . $name;
        }
        else {
          $path = $parent . '/' . $name;
        }

        if ($verbose === TRUE) {
          print("Create folder \"$path\"\n");
        }

        try {
          // There is normally no response from newRootFolder() or newFolder().
          if ($parent === '/') {
            $response = $server->newRootFolder($name);
          }
          else {
            $response = $server->newFolder($parent, $name);
          }

          if (empty($response) === FALSE) {
            print_r($response);
          }
        }
        catch (\Exception $e) {
          // The folder could not be created. Perhaps it already exists.
          // Or perhaps the user does not have sufficient permissions.
          self::printException(reset($options['command']), $e);
          return FALSE;
        }
      }
    }

    return TRUE;
  }

  /*--------------------------------------------------------------------
   *
   * File or folder copy and move commands.
   *
   *--------------------------------------------------------------------*/

  /**
   * Moves a file or folder to a new location.
   *
   * This command emulates the Linux/macOS/BSD "mv" command.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -n     | Do not overwrite an existing file.               |
   * | -v     | Show the name of each item moved.                |
   * | --help | Show help on command.                            |
   * | --wait | Wait for move to complete.                       |
   *
   * This command always recursively copies folders.
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @internal
   * POSIX, Linux, macOS, and BSD "mv" support the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -f     | Don't prompt for comfirmation and ignore errors. |
   * | -i     | Interactively confirm each item before moving.   |
   *
   * Linux, macOS, and BSD have the following additional flags, but
   * not POSIX:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -n     | Do not overwrite an existing file.               |
   * | -v     | Show the name of each item moved.                |
   *
   * BSD has the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -h     | Do not follow target symbolic links.             |
   *
   * Linux has the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -S     | Override the usual backup suffix.                |
   * | -t     | Move everything into the target directory.       |
   * | -T     | Treat the target as a file, not a directory.     |
   * | -u     | Only move if the source is newer.                |
   * | --force       | Same as -f.                               |
   * | --help    | Show help on command.                         |
   * | --interactive | Same as -i.                               |
   * | --no-clobber  | Same as -n.                               |
   * | --no-target-directory | Same as -T.                       |
   * | --suffix      | Same as -S.                               |
   * | --target-directory | Same as -t.                          |
   * | --update  | Same as -u.                                   |
   * | --verbose | Same as -v.                                   |
   * | --version | Show version information.                     |
   */
  public static function mv(
    FolderShareConnect $server,
    array $options) {

    //
    // Parse options
    // -------------
    // Synonyms have already been mapped to primary flag names.
    $verbose = FALSE;
    $overwrite = TRUE;
    $wait = FALSE;

    foreach ($options['flags'] as $flagName) {
      switch ($flagName) {
        case '-n':
          $overwrite = FALSE;
          break;

        case '-v':
          $verbose = TRUE;
          break;

        case '--wait':
          $wait = TRUE;
          break;
      }
    }

    //
    // Validate
    // --------
    // The command has one of two forms:
    // - mv source destination
    // - mv source1 source2 source3... destination
    //
    // The first form is a degenerate case of the second that supports
    // optional renaming of the source. In that case the destination does
    // not refer to an entity that exists, yet.
    //
    // However, only the server knows whether a destination exists. So
    // we need to break this down into a loop of source-to-destination
    // operations and watch for failure.
    //
    // Confirm there are at least two paths given.
    $remoteUris = FolderShareConnect::normalizeUris($options['paths']);
    switch (count($remoteUris)) {
      case 0:
        self::printError(
          reset($options['command']),
          "Missing remote file paths.");
        return FALSE;

      case 1:
        self::printError(
          reset($options['command']),
          "Missing remote destination file path.");
        return FALSE;

      default:
        $destinationUri = array_pop($remoteUris);
        break;
    }

    //
    // Execute
    // -------
    // Move a series of items to the same destination. Abort on the first error.
    foreach ($remoteUris as $remoteUri) {
      if ($verbose === TRUE) {
        print("$remoteUri\n");
      }

      try {
        // There is normally no response.
        $response = $server->move($remoteUri, $destinationUri, $overwrite);
        if (empty($response) === FALSE) {
          print_r($response);
        }
      }
      catch (\Exception $e) {
        self::printException(reset($options['command']), $e);
        return FALSE;
      }
    }

    if ($wait === TRUE) {
      self::waitUntilEnabled(
        $server,
        reset($options['command']),
        [$destinationUri],
        $verbose);
    }

    return TRUE;
  }

  /**
   * Copies a file or folder to a new location.
   *
   * This command emulates the Linux/macOS/BSD "cp" command.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -n     | Do not overwrite existing files.                 |
   * | -v     | Show the name of each item copied.               |
   * | --help | Show help on command.                            |
   * | --wait | Wait for copy to complete.                       |
   *
   * This command always recursively copies folders.
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @internal
   * POSIX, Linux, macOS, and BSD "cp" support the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -f     | Don't prompt for comfirmation and ignore errors. |
   * | -H     | With -R, follow command line symbolic links.     |
   * | -i     | Interactively confirm each item before copying.  |
   * | -L     | With -R, follow recursive symbolic links.        |
   * | -P     | With -R, don't follow symbolic links (default).  |
   * | -p     | Preserve dates, permissions, and owner on copy.  |
   * | -R     | Recursively copy trees.                          |
   *
   * Linux, macOS, and BSD have the following additional flags, but
   * not POSIX:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -a     | Same as -pPR.                                    |
   * | -n     | Do not overwrite existing files.                 |
   * | -v     | Show the name of each item copied.               |
   *
   * BSD has the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -l     | Hard link files instead of copying.              |
   * | -x     | Do not cross mount points during recursive copy. |
   *
   * macOS has the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -c     | Copy files useing clonefile.                     |
   * | -X     | Do not copy extended attributes.                 |
   *
   * Linux has the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -b     | Make a backup of each destination file.          |
   * | -d     | Same as -P --preserve=links.                     |
   * | -l     | Hard link files instead of copying.              |
   * | -n     | Do not overwrite existing files.                 |
   * | -r     | Same as -R.                                      |
   * | -s     | Symbolic link files instead of copying.          |
   * | -S     | Override backup file name suffix.                |
   * | -t     | Specify destination (target) directory.          |
   * | -T     | Treat destination as a file, not a directory.    |
   * | -u     | Copy only if the source file is newer.           |
   * | -x     | Do not cross mount points during recursive copy. |
   * | --archive| Same as -a.                                    |
   * | --backup | Same as -b.                                    |
   * | --copy-contents | Copy special files when recursive.      |
   * | --dereference   | Same as -L.                             |
   * | --force         | Same as -f.                             |
   * | --help | Show help on command.                            |
   * | --interactive   | Same as -i.                             |
   * | --link          | Same as -l.                             |
   * | --no-clobber    | Same as -n.                             |
   * | --no-dereference| Same as -P.                             |
   * | --no-preserve   | Don't preserve attributes on copy.      |
   * | --no-target-directory| Same as -T.                        |
   * | --parents       | Use full source file name under dir.    |
   * | --one-file-system| Same as -x.                            |
   * | --preserve      | Preserve specific attributes on copy.   |
   * | --recursive     | Same as -R.                             |
   * | --reflink       | Control clones.                         |
   * | --remove-directories| Remove existing destinations first. |
   * | --sparse        | Control sparse files.                   |
   * | --strip-trailing-slashes| Remove last slashes in source.  |
   * | --symbolic-link | Same as -s.                             |
   * | --suffix        | Same as -S.                             |
   * | --target-directory| Same as -t.                           |
   * | --update        | Same as -u.                             |
   * | --verbose       | Same as -v.                             |
   * | --version       | Show version information.               |
   */
  public static function cp(
    FolderShareConnect $server,
    array $options) {

    //
    // Parse options
    // -------------
    // Synonyms have already been mapped to primary flag names.
    $verbose = FALSE;
    $overwrite = TRUE;
    $wait = FALSE;

    foreach ($options['flags'] as $flagName) {
      switch ($flagName) {
        case '-n':
          $overwrite = FALSE;
          break;

        case '-v':
          $verbose = TRUE;
          break;

        case '--wait':
          $wait = TRUE;
          break;
      }
    }

    //
    // Validate
    // --------
    // The command has one of two forms:
    // - cp source destination
    // - cp source1 source2 source3... destination
    //
    // The first form is a degenerate case of the second that supports
    // optional renaming of the copy. In that case the destination does
    // not refer to an entity that exists, yet.
    //
    // However, only the server knows whether a destination exists. So
    // we need to break this down into a loop of source-to-destination
    // operations and watch for failure.
    //
    // Confirm there are at least two paths given.
    $remoteUris = FolderShareConnect::normalizeUris($options['paths']);
    switch (count($remoteUris)) {
      case 0:
        self::printError(
          reset($options['command']),
          "Missing remote file paths.");
        return FALSE;

      case 1:
        self::printError(
          reset($options['command']),
          "Missing remote destination file path.");
        return FALSE;

      default:
        $destinationUri = array_pop($remoteUris);
        break;
    }

    //
    // Execute
    // -------
    // Copy a series of items to the same destination. Abort on the first error.
    foreach ($remoteUris as $remoteUri) {
      if ($verbose === TRUE) {
        print("$remoteUri\n");
      }

      try {
        // There is normally no response.
        $response = $server->copy($remoteUri, $destinationUri, $overwrite);
        if (empty($response) === FALSE) {
          print_r($response);
        }
      }
      catch (\Exception $e) {
        self::printException(reset($options['command']), $e);
        return FALSE;
      }
    }

    if ($wait === TRUE) {
      self::waitUntilEnabled(
        $server,
        reset($options['command']),
        [$destinationUri],
        $verbose);
    }

    return TRUE;
  }

  /*--------------------------------------------------------------------
   *
   * File or folder download and upload.
   *
   *--------------------------------------------------------------------*/

  /**
   * Downloads a file and folder.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -n     | Do not overwrite existing files.                 |
   * | -p     | Preserve dates on download.                      |
   * | -u     | Copy only if the source file is newer.           |
   * | -v     | Show the name of each item downloaded.           |
   * | --help | Show help on command.                            |
   * | --sync | Same as -pu.                                     |
   *
   * The default behavior is to overwrite local files with downloaded files.
   * The -n option blocks overwriting and instead adds a unique numeric sequence
   * number onto the base name of the downloaded file (e.g. "file-2.txt",
   * "file-3.txt", ...).
   *
   * The default is for newly downloaded files and folders to have the
   * current date and time as their timestamps. The -p option uses the
   * remote item's date and time instead.
   *
   * The default is to download all files, overwriting if allowed to.
   * The -u option causes downloads to occur only if the remote file is
   * newer or if there is no local file downloaded yet with the same name.
   * If used together with -n, which prevents overwriting, -nu only
   * downloads missing files.
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @see ::cp()
   * @see ::upload()
   *
   * @internal
   * There is no standard Linux/macOS/BSD command for downloading a file.
   * If we use 'cp' as a rough model, POSIX, Linux, macOS, and BSD "cp"
   * support the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -f     | Don't prompt for comfirmation and ignore errors. |
   * | -H     | With -R, follow command line symbolic links.     |
   * | -i     | Interactively confirm each item before copying.  |
   * | -L     | With -R, follow recursive symbolic links.        |
   * | -P     | With -R, don't follow symbolic links (default).  |
   * | -p     | Preserve dates, permissions, and owner on copy.  |
   * | -R     | Recursively copy trees.                          |
   *
   * Linux, macOS, and BSD have the following additional flags, but
   * not POSIX:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -a     | Same as -pPR.                                    |
   * | -n     | Do not overwrite existing files.                 |
   * | -v     | Show the name of each item copied.               |
   *
   * BSD has the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -l     | Hard link files instead of copying.              |
   * | -x     | Do not cross mount points during recursive copy. |
   *
   * macOS has the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -c     | Copy files useing clonefile.                     |
   * | -X     | Do not copy extended attributes.                 |
   *
   * Linux has the following additional flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -b     | Make a backup of each destination file.          |
   * | -d     | Same as -P --preserve=links.                     |
   * | -l     | Hard link files instead of copying.              |
   * | -n     | Do not overwrite existing files.                 |
   * | -r     | Same as -R.                                      |
   * | -s     | Symbolic link files instead of copying.          |
   * | -S     | Override backup file name suffix.                |
   * | -t     | Specify destination (target) directory.          |
   * | -T     | Treat destination as a file, not a directory.    |
   * | -u     | Copy only if the source file is newer.           |
   * | -x     | Do not cross mount points during recursive copy. |
   * | --archive| Same as -a.                                    |
   * | --backup | Same as -b.                                    |
   * | --copy-contents | Copy special files when recursive.      |
   * | --dereference   | Same as -L.                             |
   * | --force         | Same as -f.                             |
   * | --help | Show help on command.                            |
   * | --interactive   | Same as -i.                             |
   * | --link          | Same as -l.                             |
   * | --no-clobber    | Same as -n.                             |
   * | --no-dereference| Same as -P.                             |
   * | --no-preserve   | Don't preserve attributes on copy.      |
   * | --no-target-directory| Same as -T.                        |
   * | --parents       | Use full source file name under dir.    |
   * | --one-file-system| Same as -x.                            |
   * | --preserve      | Preserve specific attributes on copy.   |
   * | --recursive     | Same as -R.                             |
   * | --reflink       | Control clones.                         |
   * | --remove-directories| Remove existing destinations first. |
   * | --sparse        | Control sparse files.                   |
   * | --strip-trailing-slashes| Remove last slashes in source.  |
   * | --symbolic-link | Same as -s.                             |
   * | --suffix        | Same as -S.                             |
   * | --target-directory| Same as -t.                           |
   * | --update        | Same as -u.                             |
   * | --verbose       | Same as -v.                             |
   * | --version       | Show version information.               |
   */
  public static function download(
    FolderShareConnect $server,
    array $options) {

    //
    // Parse options
    // -------------
    // Synonyms have already been mapped to primary flag names.
    $verbose = FALSE;
    $overwrite = TRUE;
    $preserve = FALSE;
    $update = FALSE;

    foreach ($options['flags'] as $flagName) {
      switch ($flagName) {
        case '-n':
          $overwrite = FALSE;
          break;

        case '-p':
          $preserve = TRUE;
          break;

        case '--sync':
          $update = TRUE;
          $preserve = TRUE;
          break;

        case '-u':
          $update = TRUE;
          break;

        case '-v':
          $verbose = TRUE;
          break;
      }
    }

    $downloadFlags = 0;
    if ($overwrite === TRUE) {
      $downloadFlags |= FolderShareConnect::DOWNLOAD_OVERWRITE;
    }
    if ($preserve === TRUE) {
      $downloadFlags |= FolderShareConnect::DOWNLOAD_PRESERVE;
    }
    if ($update === TRUE) {
      $downloadFlags |= FolderShareConnect::DOWNLOAD_UPDATE;
    }

    //
    // Validate
    // --------
    // The command needs two paths:
    // - URI to remote file or folder.
    // - Path to local file or folder.
    //
    // If the local path is not given, it defaults to the current directory.
    switch (count($options['paths'])) {
      case 0:
        self::printError(
          reset($options['command']),
          "Missing remote file path.");
        return FALSE;

      case 1:
        // One path: Remote. Use current directory as local path.
        $remoteUri = $options['paths'][0];
        $localPath = getcwd();
        if ($localPath === FALSE) {
          // On some UNIX variants, getcwd() returns FALSE if one of the
          // current directory's ancestors is not readable/searchable. This
          // is sufficient to cause failure of the download.
          self::printError(
            reset($options['command']),
            "The current directory is not readable so it cannot be used to receive a download.");
          return FALSE;
        }
        break;

      case 2:
        // Two paths: Remote & Local.
        $remoteUri = $options['paths'][0];
        $localPath = $options['paths'][1];
        break;

      default:
        self::printError(
          reset($options['command']),
          "Too many file paths.");
        return FALSE;
    }

    $remoteUri = FolderShareConnect::normalizeUri($remoteUri);

    //
    // Execute
    // -------
    // Download the file.
    try {
      $priorProgress = $server->isProgress();

      if ($verbose === TRUE) {
        print("Download \"$remoteUri\" to \"$localPath\"\n");
        $server->setProgress(TRUE);
      }

      $server->download($remoteUri, $localPath, $downloadFlags);

      $server->setProgress($priorProgress);
    }
    catch (\Exception $e) {
      if ($verbose === TRUE) {
        print("\n");
      }

      self::printException(reset($options['command']), $e);
      return FALSE;
    }

    return TRUE;
  }

  /**
   * Uploads a local file or folder.
   *
   * This method supports the following flags:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -n     | Do not overwrite existing files.                 |
   * | -p     | Preserve dates on download.                      |
   * | -u     | Copy only if the source file is newer.           |
   * | -v     | Show the name of each item uploaded.             |
   * | --help | Show help on command.                            |
   * | --sync | Same as -pu.                                     |
   *
   * The default behavior is to overwrite local files with downloaded files.
   * The -n option blocks overwriting and instead adds a unique numeric sequence
   * number onto the base name of the downloaded file (e.g. "file-2.txt",
   * "file-3.txt", ...).
   *
   * The default is for newly downloaded files and folders to have the
   * current date and time as their timestamps. The -p option uses the
   * remote item's date and time instead.
   *
   * The default is to download all files, overwriting if allowed to.
   * The -u option causes downloads to occur only if the remote file is
   * newer or if there is no local file downloaded yet with the same name.
   * If used together with -n, which prevents overwriting, -nu only
   * downloads missing files.
   *
   * @param \FolderShare\FolderShareConnect $server
   *   The server connection.
   * @param array $options
   *   The command-line options array.
   *
   * @return bool
   *   Returns TRUE on success, and FALSE on failure. On failure an error
   *   message has already been output.
   *
   * @see ::cp()
   * @see ::download()
   *
   * @internal
   * There is no standard Linux/macOS/BSD command for uploading a file.
   * If we use 'cp' as a rough model. See runDownload() comments for more.
   */
  public static function upload(
    FolderShareConnect $server,
    array $options) {

    //
    // Parse options
    // -------------
    // Synonyms have already been mapped to primary flag names.
    $verbose = FALSE;
    $overwrite = TRUE;
    $preserve = FALSE;
    $update = FALSE;

    foreach ($options['flags'] as $flagName) {
      switch ($flagName) {
        case '-n':
          $overwrite = FALSE;
          break;

        case '-p':
          $preserve = TRUE;
          break;

        case '--sync':
          $update = TRUE;
          $preserve = TRUE;
          break;

        case '-u':
          $update = TRUE;
          break;

        case '-v':
          $verbose = TRUE;
          break;
      }
    }

    $uploadFlags = 0;
    if ($overwrite === TRUE) {
      $uploadFlags |= FolderShareConnect::UPLOAD_OVERWRITE;
    }
    if ($preserve === TRUE) {
      $uploadFlags |= FolderShareConnect::UPLOAD_PRESERVE;
    }
    if ($update === TRUE) {
      $uploadFlags |= FolderShareConnect::UPLOAD_UPDATE;
    }

    //
    // Validate
    // --------
    // The command needs two paths:
    // - Path to local file or folder.
    // - URI to remote file or folder.
    switch (count($options['paths'])) {
      case 0:
        self::printError(
          reset($options['command']),
          "Missing local and remote file paths.");
        return FALSE;

      case 1:
        self::printError(
          reset($options['command']),
          "Missing remote file path.");
        break;

      case 2:
        // Two paths: Remote & Local.
        $localPath = $options['paths'][0];
        $remoteUri = $options['paths'][1];
        break;

      default:
        self::printError(
          reset($options['command']),
          "Too many file paths.");
        return FALSE;
    }

    $remoteUri = FolderShareConnect::normalizeUri($remoteUri, FALSE);

    //
    // Execute
    // -------
    // Upload the file or folder.
    try {
      // There is normally no response.
      $priorProgress = $server->isProgress();
      $server->setProgress($verbose);

      if ($verbose === TRUE) {
        print("Upload \"$localPath\" to \"$remoteUri\"...\n");
      }

      $server->upload($localPath, $remoteUri, $uploadFlags);

      $server->setProgress($priorProgress);
    }
    catch (\Exception $e) {
      if ($verbose === TRUE) {
        print("\n");
      }

      self::printException(reset($options['command']), $e);
      return FALSE;
    }

    return TRUE;
  }

}

/**
 * @file
 * Issues command-line requests to a host using the FolderShare module.
 */



/*----------------------------------------------------------------------
 *
 * Verify execution environment.
 *
 *----------------------------------------------------------------------*/

/**
 * The required PHP version.
 */
define('REQUIRED_PHP_VERSION', '7.0.0');

/**
 * The required PHP packages.
 */
define('REQUIRED_PACKAGES', [
  [
    'extension' => 'curl',
    'name'      => 'PHP CURL',
    'version'   => '7.0.0',
  ],
  [
    'extension' => 'date',
    'name'      => 'PHP Date',
    'version'   => '7.0.0',
  ],
  [
    'extension' => 'json',
    'name'      => 'PHP JSON',
    'version'   => '1.5.0',
  ],
  [
    'extension' => 'mbstring',
    'name'      => 'PHP Multi-byte String',
    'version'   => '7.0.0',
  ],
  [
    'extension' => 'readline',
    'name'      => 'PHP Readline',
    'version'   => '7.0.0',
  ],
]);

/**
 * Verify suitability of PHP installation.
 *
 * This file uses PHP 7 syntax, such as for type hints on function arguments.
 * If the file is read by PHP <7, it will report syntax errors *before* we
 * get a chance to check the version number.
 */
if (version_compare(phpversion(), REQUIRED_PHP_VERSION) < 0) {
  $v = REQUIRED_PHP_VERSION;
  fwrite(STDERR, "Abort. The current version of PHP is out of date.\n");
  fwrite(STDERR, "This application requires at least version $v.\n");
  exit(1);
}

foreach (REQUIRED_PACKAGES as $package) {
  $e = $package['extension'];
  $v = $package['version'];
  $n = $package['name'];
  $pv = phpversion($e);

  if ($pv === FALSE) {
    fwrite(STDERR, "Abort. The required $n package is not installed.\n");
    exit(1);
  }

  if (empty($v) === FALSE && empty($pv) === FALSE) {
    // A specific version number is required.
    if (version_compare($pv, $v) < 0) {
      fwrite(STDERR, "Abort. A newer version of the $n package is required.\n");
      fwrite(STDERR, "This application requires at least version $v, but only $pv is available.\n");
      exit(1);
    }
  }
}

/*----------------------------------------------------------------------
 *
 * Define constants.
 *
 *----------------------------------------------------------------------*/

/**
 * This application name.
 */
define('NAME', 'FolderShare application');

/**
 * This application version number.
 */
define('VERSION', '1.1.0 (February 2020)');

/*--------------------------------------------------------------------
 *
 * Utilities for help and error messages.
 *
 *--------------------------------------------------------------------*/

/**
 * Prints help information for command line use.
 *
 * The printed information is written for users that add commands to
 * the Linux/macOS/BSD shell command line. The host, user name, password,
 * and other base options are listed.
 *
 * @param string $appPath
 *   The path to the application.
 */
function printCommandLineHelp(string $appPath) {

  $appName = basename($appPath);
  $helpStart = <<<EOS
Usage is: $appName [HOST_OPTIONS] [COMMAND] [OPTIONS]

Create, delete, change, and manage files and folders on a remote web site that uses the FolderShare module.

Commands
--------

EOS;

  $helpEnd = <<<EOS

Add "--help" after any command to show its description and flags.

Host and account
----------------
All commands require a remote host and account:

  --host HOSTNAME   Select the host (and optional port) for the site.
  --port NUMBER     Select the port for the site.
  --username NAME   Specify the user login name on the site.
  --password PASS   Specify the user password on the site.

A host name may be a text name or numeric IPv4 or IPv6 address. Text names and IPv4 addresses may include a colon (":") and port number at the end. To include a port number with an IPv6 address, surround the address with square brackets first. Alternatively, use "--port" to specify a port number.

If the port number is omitted, a default is used.

Examples:
  $appName --host example.com --username me --password pw ls /
  $appName --host example.com:80 --username me --password pw ls /
  $appName --host 127.0.0.1 --username me --password pw ls /
  $appName --host 127.0.0.1:80 --username me --password pw ls /
  $appName --host 2001:0db8:85a3:0000:0000:8a2e:0370:7334 --username me --password pw ls /
  $appName --host [2001:0db8:85a3:0000:0000:8a2e:0370:7334]:80 --username me --password pw ls /

If the username and/or password are omitted, the command will prompt for them.

Additional options
------------------
  --help            Show this help information.
  --verbose         Be verbose while performing the operation.
  --version         Show application version numbers.
  --format type     Select how information is displayed:
                      auto     (default) Use an operation-specific default
                      full     Show full-detail nested-array output
                      keyvalue Show a table of key-value pairs
                      linux    Show a Linux-style output
                      text     Show key-value pairs as text

For Linux/macOS/BSD-style commands, the format type defaults to 'linux' and output is formatted similar to those OS commands.

Example:
  $appName --host myhost --format full stat /myfolder

Paths
-----
Remote file and folder paths have the form:

  [SCHEME:][//USER]/PATH.

SCHEME is optional and one of:
  "personal"  (default) Your files and folders, and those shared with you.
  "public"    The host's public files and folders available to anyone.

USER is optional and selects the user ID or account name. It defaults to the current user.

PATH is a file and folder path, separated by forward slashes. Wildcards are not accepted. If a path contains spaces or special characters, the whole path should be included in quotes.

Examples:
  $appName --host example.com ls /
  $appName --host example.com ls personal:/
  $appName --host example.com ls public:/

EOS;

  $help = $helpStart;

  $commandNames = array_keys(FolderShareCommands::COMMANDS);
  sort($commandNames, (SORT_STRING | SORT_FLAG_CASE));

  foreach ($commandNames as $commandName) {
    $commandInfo = FolderShareCommands::COMMANDS[$commandName];

    if (isset($commandInfo['brief']) === TRUE) {
      $brief = $commandInfo['brief'];
    }
    else {
      $brief = $commandName;
    }

    $help .= sprintf("  %-18s%s\n", $commandName, $brief);
  }

  $help .= $helpEnd;

  fwrite(STDOUT, $help);
}

/**
 * Prints help information for prompt use.
 *
 * The printed information is written for users that are using the interactive
 * prompt. The host, user name, password, and other base options are not listed
 * since they would already have been provided.
 *
 * @param string $appPath
 *   The path to the application.
 */
function printPromptHelp(string $appPath) {
  $helpStart = <<<EOS
Commands
--------

EOS;

  $helpEnd = <<<EOS

Add "--help" after any command to show its description and flags.

Paths
-----
Remote file and folder paths have the form:

  [SCHEME:][//USER]/PATH.

SCHEME is optional and one of:
  "personal"  (default) Your files and folders, and those shared with you.
  "public"    The host's public files and folders available to anyone.

USER is optional and selects the user ID or account name. It defaults to the current user.

PATH is a file and folder path, separated by forward slashes. Wildcards are not accepted. If a path contains spaces or special characters, the whole path should be included in quotes.

Examples:
  ls /
  ls personal:/
  ls public:/

EOS;

  $help = $helpStart;

  $commandNames = array_keys(FolderShareCommands::COMMANDS);
  $commandNames[] = 'help';
  $commandNames[] = 'quit';
  $commandNames[] = 'exit';
  sort($commandNames, (SORT_STRING | SORT_FLAG_CASE));

  foreach ($commandNames as $commandName) {
    if ($commandName === 'help') {
      $brief = "Show this help information.";
    }
    elseif ($commandName === 'quit') {
      $brief = "Quit.";
    }
    elseif ($commandName === 'exit') {
      $brief = "Quit.";
    }
    else {
      $commandInfo = FolderShareCommands::COMMANDS[$commandName];

      if (isset($commandInfo['brief']) === TRUE) {
        $brief = $commandInfo['brief'];
      }
      else {
        $brief = $commandName;
      }
    }

    $help .= sprintf("  %-18s%s\n", $commandName, $brief);
  }

  $help .= $helpEnd;

  fwrite(STDOUT, $help);
}

/**
 * Prints help information for a command.
 *
 * @param string $appName
 *   The name of this command-line application.
 * @param string $commandName
 *   The name of the command.
 */
function printCommandHelp(string $appName, string $commandName) {
  if (isset(FolderShareCommands::COMMANDS[$commandName]) === FALSE) {
    // Unknown command. Print nothing.
    return;
  }

  $command = FolderShareCommands::COMMANDS[$commandName];

  //
  // Print synopsis
  // --------------
  // Print a command-line template for the command.
  $synopsis = "Usage: $appName [HOST_OPTIONS] ";
  if (isset($command['synopsis']) === FALSE) {
    $synopsis .= $commandName;
  }
  else {
    $synopsis .= $command['synopsis'];
  }

  fwrite(STDOUT, "$synopsis\n");

  //
  // Print description
  // -----------------
  // Print a multi-line text description.
  $description = "\n";
  if (isset($command['description']) === TRUE) {
    $description .= $command['description'] . "\n";
  }

  fwrite(STDOUT, $description);

  //
  // Print flags (if any)
  // -----------
  // Print a list of flags and their descriptions.
  if (isset($command['flags']) === TRUE) {
    fwrite(STDOUT, "\nOptions:\n");

    // Get flag names then sort them.
    $flagNames = array_keys($command['flags']);
    sort($flagNames, (SORT_STRING | SORT_FLAG_CASE));

    // Print them out.
    $flagIndent = '  ';
    $flagHelpIndent = '      ';

    foreach ($flagNames as $flagName) {
      $flagInfo = &$command['flags'][$flagName];

      // Print the flag line, with synonyms.
      $flagLine = "$flagIndent$flagName";
      if (isset($flagInfo['synonyms']) === TRUE) {
        foreach ($flagInfo['synonyms'] as $flagSynonym) {
          $flagLine .= ", $flagSynonym";
        }
      }

      fwrite(STDOUT, "$flagLine\n");

      // Print the flag command.
      if (isset($flagInfo['brief']) === TRUE) {
        $helpLines = mb_split("\n", $flagInfo['brief']);
        foreach ($helpLines as $helpLine) {
          fwrite(STDOUT, "$flagHelpIndent$helpLine\n");
        }
      }
    }
  }

  //
  // Print command synonyms (if any)
  // ----------------------
  // Print a list of synonyms.
  if (isset($command['synonyms']) === TRUE) {
    $names = [$commandName];
    foreach ($command['synonyms'] as $synonym) {
      $names[] = $synonym;
    }

    sort($names, SORT_NATURAL);
    $text = implode(', ', $names);

    fwrite(STDOUT, "\nSynonyms:\n  $text\n");
  }
}

/**
 * Prints the client side version to STDERR and exits.
 *
 * @param array $options
 *   The command-line options array.
 */
function printVersionAndExit(array $options) {
  // Create a dummy server connection without a host or authentication.
  // Then get the version of the client side only.
  $dummyServer = new FolderShareConnect();
  $options['format'] = 'text';
  $text = FolderShareCommands::version($dummyServer, $options, FALSE);
  fwrite(STDERR, $text);
  exit(1);
}

/**
 * Prints an error message to STDERR and exits.
 *
 * @param string $appPath
 *   The path to the application.
 * @param string $message
 *   The error message.
 */
function printErrorAndExit(string $appPath, string $message) {
  $appName = basename($appPath, '.php');
  fwrite(STDERR, "$appName: $message\n");
  exit(1);
}

/*--------------------------------------------------------------------
 *
 * Command-line parsing.
 *
 * These functions parse the command line.
 *
 *--------------------------------------------------------------------*/

/**
 * Parses the command line and returns values.
 *
 * The command line is parsed and its values validated and returned in
 * an associative array.
 *
 * @param array $argv
 *   The array of command-line arguments.
 */
function parseCommandLine(array $argv) {
  //
  // Set initial values
  // ------------------
  // Get the application name and set up defaults for all values.
  $options = [];
  $appPath = $options['appPath'] = array_shift($argv);
  $appName = $options['appName'] = basename($appPath, '.php');

  // Connection options.
  $options['host'] = '';
  $options['port'] = '';
  $options['username'] = '';
  $options['password'] = '';

  // Flags.
  $options['format'] = 'auto';
  $options['verbose'] = FALSE;

  // Command.
  $options['command'] = [];
  $options['paths'] = [];
  $options['flags'] = [];

  $showVersion = FALSE;

  $usage = "\nUse '--help' for a list of commands and options.";

  //
  // Parse arguments
  // ---------------
  // Loop through the arguments and look for options and commands.
  // When a command name is found, all further arguments are considered
  // part of that command.
  $n = count($argv);
  for ($i = 0; $i < $n; ++$i) {
    // The first argument that does not start with '-' is the command.
    // Add it to the command's argument list, along with all further
    // arguments. It is up to the command to parse them.
    $dash = mb_substr($argv[$i], 0, 1);
    if ($dash !== '-') {
      // Command found!
      $options['command'] = array_slice($argv, $i);
      break;
    }

    // Otherwise, parse generic options relating to the connection
    // or flags.
    //
    // Ignore one or two leading dashes while parsing options.
    $dashes = mb_substr($argv[$i], 0, 2);
    if ($dashes === '--') {
      $arg = mb_substr($argv[$i], 2);
    }
    else {
      $arg = mb_substr($argv[$i], 1);
    }

    switch ($arg) {
      // Immediate response options.
      case 'help':
        // Print help information and stop.
        printCommandLineHelp($appName);
        exit(0);

      case 'version':
        // Print application version and stop.
        $showVersion = TRUE;
        break;

      // Connection options.
      case 'host':
        if (($i + 1) >= $n) {
          printErrorAndExit(
            $appName,
            "A host name is required after '--$arg'.$usage");
        }

        ++$i;
        $options['host'] = $argv[$i];
        break;

      case 'port':
        if (($i + 1) >= $n) {
          printErrorAndExit(
            $appName,
            "A port number is required after '--$arg'.$usage");
        }

        ++$i;
        $options['port'] = $argv[$i];
        break;

      case 'user':
      case 'username':
        if (($i + 1) >= $n) {
          printErrorAndExit(
            $appName,
            "A user name is required after '--$arg'.$usage");
        }

        ++$i;
        $options['username'] = $argv[$i];
        break;

      case 'password':
        if (($i + 1) >= $n) {
          printErrorAndExit(
            $appName,
            "A password is required after '--$arg'.$usage");
        }

        ++$i;
        $options['password'] = $argv[$i];
        break;

      // Flags.
      case 'verbose':
        $options['verbose'] = TRUE;
        break;

      case 'format':
        if (($i + 1) >= $n) {
          printErrorAndExit(
            $appName,
            "A format name is required after '--$arg'.$usage");
        }

        ++$i;
        $value = $argv[$i];
        switch ($value) {
          // Principal values.
          case 'auto':
          case 'full':
          case 'keyvalue':
          case 'linux':
          case 'text':
            break;

          // Synonyms.
          case 'all':
          case 'raw':
            $value = 'full';
            break;

          case 'kv':
            $value = 'keyvalue';
            break;

          case 'macos':
          case 'osx':
          case 'unix':
          case 'bsd':
            $value = 'linux';
            break;

          case 'default':
            $value = 'auto';
            break;

          default:
            printErrorAndExit(
              $appName,
              "Unknown format name: '$value'.$usage");
            break;
        }

        $options['format'] = $value;
        break;

      default:
        // Otherwise the option is not generic.
        $a = $argv[$i];
        printErrorAndExit(
          $appName,
          "Unknown option: '--$a'.$usage");
        break;
    }
  }

  //
  // Handle version
  // --------------
  // The --version flag can be used with or without a host.
  //
  // Without a host, just show the client side's versions.
  //
  // With a host, map --version to the 'version' command.
  if ($showVersion === TRUE) {
    if (empty($options['host']) === TRUE) {
      printVersionAndExit($options);
    }

    // Override any additional command given and make it "version".
    $options['command'] = ["version"];
  }

  //
  // Validate
  // --------
  // Check that a host name has been given.
  if (empty($options['host']) === TRUE) {
    printErrorAndExit(
      $appName,
      "A host name is required. Use '--host hostname'.$usage");
  }

  return $options;
}

/**
 * Validates a command and its flags.
 *
 * @param array $options
 *   The command-line options array.
 * @param bool $exitOnError
 *   (optional, default = TRUE) When TRUE, on an error a message is output
 *   and the application exits. When FALSE, on an error a message is output
 *   and FALSE is returned.
 *
 * @return bool
 *   Returns TRUE on successful validation, and FALSE otherwise.
 */
function validateCommand(array &$options, bool $exitOnError = TRUE) {
  //
  // Recognize command
  // -----------------
  // Check if the command is recognized. It can be a primary command name
  // or one of the synonyms.
  $appName = $options['appName'];
  if ($exitOnError === TRUE) {
    $usage = "\nUse '--help' for a list of commands and options.";
  }
  else {
    $usage = "\nType 'help' for a list of commands and options.\n";
  }

  if (isset($options['command']) === FALSE) {
    if ($exitOnError === TRUE) {
      printErrorAndExit(
        $appName,
        "Missing command.$usage");
    }

    print("Missing command.$usage");
    return FALSE;
  }

  $commandName = reset($options['command']);
  $found = FALSE;

  if (isset(FolderShareCommands::COMMANDS[$commandName]) === TRUE) {
    $found = TRUE;
  }
  else {
    // Look through the synonyms of all commands. If found, swap the
    // command name from the synonym to the primary name.
    foreach (FolderShareCommands::COMMANDS as $name => &$info) {
      if (isset($info['synonyms']) === TRUE) {
        if (in_array($commandName, $info['synonyms']) === TRUE) {
          $found = TRUE;
          $commandName = $name;
          $options['command'][0] = $name;
          break;
        }
      }
    }
  }

  if ($found === FALSE) {
    if ($exitOnError === TRUE) {
      printErrorAndExit(
        $appName,
        "Unknown command: '$commandName'.$usage");
    }

    print("Unknown command: '$commandName'.$usage");
    return FALSE;
  }

  //
  // Check implementation
  // --------------------
  // Make sure the command has a function! If it doesn't, the command is
  // not yet implemented.
  if (isset(FolderShareCommands::COMMANDS[$commandName]['function']) === FALSE) {
    if ($exitOnError === TRUE) {
      printErrorAndExit(
        $appName,
        "$commandName is not supported yet.");
    }

    print("$commandName is not supported yet.\n");
    return FALSE;
  }

  //
  // Handle return formats
  // ---------------------
  // Map the 'auto' return type to the actual type.
  if ($options['format'] === 'auto') {
    $options['format'] = FolderShareCommands::COMMANDS[$commandName]['defaultFormat'];
  }

  // Check that only valid return types were provided.
  if (empty(FolderShareCommands::COMMANDS[$commandName]['formats']) === FALSE &&
      in_array($options['format'], FolderShareCommands::COMMANDS[$commandName]['formats']) === FALSE) {
    $rt = $options['format'];
    if ($exitOnError === TRUE) {
      printErrorAndExit(
        $appName,
        "Unsupported format name '$rt' for '$commandName'.$usage");
    }

    print("Unsupported format name '$rt' for '$commandName'.$usage");
    return FALSE;
  }

  //
  // Parse flags and paths
  // ---------------------
  // Check that the flags make sense.
  $pathsAndFlags = parseCommandFlags(
    $appName,
    $commandName,
    $options['command']);
  if ($pathsAndFlags === FALSE) {
    return FALSE;
  }

  $options['paths'] = $pathsAndFlags['paths'];
  $options['flags'] = $pathsAndFlags['flags'];

  return TRUE;
}

/**
 * Parses flags for a specific command.
 *
 * An array arguments for a command is split into:
 * - Flags that start with '-' or '--'.
 * - Paths or other non-dash arguments.
 *
 * Flags are parsed for the command and errors generated for unrecognized
 * flags.
 *
 * Flags with a single dash are presumed to be single-letter flags
 * (e.g. "-a"). If multiple letters are given, the flags are expanded
 * into multiple flags (e.g. "-abc" becomes "-a", "-b", and "-c).
 *
 * Flags with a double dash are presumed to be multi-letter word flags
 * and are not changed.
 *
 * Flag synonyms are transparently mapped to their primary names (e.g.
 * "--stuff" becomes "-s" if "-s" is the primary name).
 *
 * @param string $appName
 *   The name of the command-line application.
 * @param string $commandName
 *   The name of the command.
 * @param array $args
 *   The arguments array from the basic command-line parser.
 *
 * @return array|bool
 *   Returns an associative array with 'flags' and 'paths' keys whose
 *   values are each arrays. The 'paths' array contains a list of
 *   paths or non-flag arguments, in order. The 'flags' array contains
 *   a list of flags. Returns FALSE on error.
 */
function parseCommandFlags(string $appName, string $commandName, array $args) {
  //
  // Split args
  // ----------
  // Divide up the incoming arguments into paths and flags. A flag starts
  // with a '-' or '--', while a path does not.
  $paths = [];
  $flags = [];

  array_shift($args);
  foreach ($args as $arg) {
    // Look at the first character to decide if the argument is a flag
    // or a path.
    $dash = mb_substr($arg, 0, 1);
    if ($dash === '-') {
      $flags[] = $arg;
    }
    else {
      $paths[] = $arg;
    }
  }

  //
  // Expand flags
  // ------------
  // For single-dash options with multiple letters, split the letters into
  // separate flags. For instance "-abc" becomes "-a", "-b", and "-c".
  // Leave double-dash options alone.
  $expandedFlags = [];
  foreach ($flags as $flag) {
    // Don't expand double-dash flags.
    $firstTwo = mb_substr($flag, 0, 2);
    if ($firstTwo === '--') {
      $expandedFlags[] = $flag;
      continue;
    }

    // No need to expand flags that are one letter after '-'.
    $len = mb_strlen($flag);
    if ($len === 2) {
      $expandedFlags[] = $flag;
      continue;
    }

    for ($i = 1; $i < $len; ++$i) {
      $f = mb_substr($flag, $i, 1);
      $expandedFlags[] = '-' . $f;
    }
  }

  $flags = $expandedFlags;
  unset($expandedFlags);

  //
  // Simplify flags
  // --------------
  // For all flags, map synonyms to their primary flag name.
  $flagsInfo = FolderShareCommands::COMMANDS[$commandName]['flags'];

  $simplifiedFlags = [];
  foreach ($flags as $flag) {
    if (isset($flagsInfo[$flag]) === TRUE) {
      // The flag is a primary flag name.
      $simplifiedFlags[] = $flag;
    }
    else {
      $found = FALSE;
      foreach ($flagsInfo as $flagName => &$flagInfo) {
        if (isset($flagInfo['synonyms']) === TRUE) {
          foreach ($flagInfo['synonyms'] as $synonymName) {
            if ($flag === $synonymName) {
              // Map the synonym to the primary flag name.
              $simplifiedFlags[] = $flagName;
              $found = TRUE;
              break 2;
            }
          }
        }
      }

      // If the flag was not found as a synonym of anything, then
      // report an error.
      if ($found === FALSE) {
        print("$commandName: Unrecognized option \"$flag\".\n");
        return FALSE;
      }
    }
  }

  return [
    'paths' => $paths,
    'flags' => $simplifiedFlags,
  ];
}

/*--------------------------------------------------------------------
 *
 * Execute!
 *
 * Run the application.
 *
 *--------------------------------------------------------------------*/

//
// Set unlimited memory use. File uploads and downloads can require
// large memory buffers, and the larger the file the larger the buffer.
// To avoid hitting a memory limit, disable it.
//
ini_set('memory_limit', (-1));

//
// Set unlimited execution time. PHP's command-line scripts are supposed to
// default to unlimited execution time, but be sure. This avoids time limit
// interrupts during long file transfers.
//
set_time_limit(0);

//
// Parse the command line. There may not be a command.
//
$options = parseCommandLine($argv);
$appName = $options['appName'];

//
// Open server connection
// ----------------------
// If no user name was provided, assume anonymous access to the site.
// If a user name was given, but no password, prompt for the password.
//
// Then use the given host and open a server connection and set the return
// format and verbosity level.
try {
  if (empty($options['username']) === FALSE &&
      $options['username'] !== FolderShareCommands::ANONYMOUS) {
    if (empty($options['password']) === TRUE) {
      // Prompt for password.
      print("Password: ");
      $options['password'] = stream_get_line(STDIN, 1024, PHP_EOL);
    }
  }
  elseif ($options['username'] === FolderShareCommands::ANONYMOUS) {
    $options['username'] = '';
  }

  // Open server connection.
  $server = new FolderShareConnect();

  // Enable/disable verbosity.
  if ($options['verbose'] === TRUE) {
    $server->setVerbose(TRUE);
  }

  // Set the host and port.
  $server->setHostNameAndPortNumber($options['host'], $options['port']);

  // Log in.
  //
  // Provide the user name and password to log in. This typically triggers
  // a connection. It will fail if the host, user name, or password are bad,
  // or if there are problems communicating with the host.
  if ($server->login($options['username'], $options['password']) === FALSE) {
    printErrorAndExit($appName, "Login failed.");
  }
}
catch (\Exception $e) {
  printErrorAndExit($appName, $e->getMessage());
}

//
// Execute single command
// ----------------------
// If a command was given on the command line, execute it.
if (empty($options['command']) === FALSE) {
  //
  // Validate command
  // ----------------
  // If a command is given, it must be valid.
  // - Check if the command is a primary name or a synonym.
  // - Check that there is a function for the command.
  // - Check that the return format is supported.
  // - Check that the given flags make sense.
  if (empty($options['command']) === FALSE) {
    validateCommand($options);
  }

  if (in_array('--help', $options['flags']) === TRUE) {
    printCommandHelp($appName, $options['command'][0]);
    exit(0);
  }

  // Set the preferred return format.
  if ($options['format'] === 'linux' || $options['format'] === 'text') {
    $server->setReturnFormat('keyvalue');
  }
  else {
    $server->setReturnFormat($options['format']);
  }

  try {
    //
    // Dispatch
    // --------
    // Invoke the command.
    $commandName = reset($options['command']);
    $fun = FolderShareCommands::COMMANDS[$commandName]['function'];
    if (is_callable($fun) === FALSE) {
      $fun = 'FolderShare\\' . $fun;
      if (is_callable($fun) === FALSE) {
        printErrorAndExit($appName, "Cannot find function: $fun");
      }
    }
    $status = $fun($server, $options);
    exit(($status === TRUE) ? 0 : 1);
  }
  catch (\Exception $e) {
    printErrorAndExit($appName, $e->getMessage());
  }
}

//
// Execute multiple commands
// -------------------------
// Enter a prompt loop and execute commands as given.
$username = $server->getUserName();
if (empty($username) === TRUE) {
  $username = FolderShareCommands::ANONYMOUS;
}

printf("Foldershare shell.\nLogged in as '%s'.\nType 'help' for a list of commands, 'quit' or 'exit' to exit.\n", $username);

while (TRUE) {
  try {
    //
    // Prompt
    // ------
    // Get a single line of input.
    $prompt = "$appName> ";
    if (PHP_OS === 'WINNT') {
      $line = stream_get_line(STDIN, 1024, PHP_EOL);
    }
    else {
      $line = readline($prompt);
    }

    if ($line === FALSE) {
      // EOF.
      break;
    }

    if (empty($line) === TRUE) {
      continue;
    }

    if (PHP_OS !== 'WINNT') {
      readline_add_history($line);
    }

    //
    // Split into arguments
    // --------------------
    // Quotes require special handling to keep values together as a single
    // argument.
    $parts = mb_split('["\']', $line);
    $inQuoted = FALSE;
    $args = [];
    foreach ($parts as $part) {
      if ($inQuoted === TRUE) {
        // This part is a quoted string, with the quotes removed. Do not
        // trim or change in any way.
        $args[] = $part;
        $inQuoted = FALSE;
      }
      else {
        // The part is one or more non-quoted arguments. Remove redundant
        // white space, then split into arguments at white space boundaries.
        foreach (mb_split(' ', mb_ereg_replace('\s+', ' ', $part)) as $p) {
          if (empty($p) === FALSE) {
            $args[] = $p;
          }
        }

        $inQuoted = TRUE;
      }
    }

    // Build an options array.
    $localOptions = $options;
    $localOptions['command'] = $args;

    $commandName = reset($localOptions['command']);
    switch ($commandName) {
      case 'help':
        printPromptHelp($appName);
        continue 2;

      case 'quit':
      case 'exit':
        exit(0);
    }

    //
    // Validate command
    // ----------------
    // If a command is given, it must be valid.
    // - Check if the command is a primary name or a synonym.
    // - Check that there is a function for the command.
    // - Check that the return format is supported.
    // - Check that the given flags make sense.
    if (validateCommand($localOptions, FALSE) === FALSE) {
      continue;
    }

    $commandName = reset($localOptions['command']);

    if (in_array('--help', $localOptions['flags']) === TRUE) {
      printCommandHelp($appName, $commandName);
      continue;
    }

    // Set the preferred return format.
    if ($localOptions['format'] === 'linux' ||
        $localOptions['format'] === 'text') {
      $server->setReturnFormat('keyvalue');
    }
    else {
      $server->setReturnFormat($localOptions['format']);
    }

    //
    // Dispatch
    // --------
    // Invoke the command.
    FolderShareCommands::COMMANDS[$commandName]['function']($server, $localOptions);
  }
  catch (\Exception $e) {
    print($e->getMessage());
  }
}
